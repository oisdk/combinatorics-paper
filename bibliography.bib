
@book{golanSemiringsTheirApplications1999,
  title = {Semirings and Their {{Applications}}},
  publisher = {{Springer Science \& Business Media}},
  author = {Golan, Jonathan S.},
  year = {1999},
  file = {/Users/doisinkidney/Zotero/storage/7WDTV3YM/Golan - 1999 - Semirings and their Applications.pdf}
}

@article{goodmanSemiringParsing1999,
  title = {Semiring {{Parsing}}},
  volume = {25},
  number = {4},
  journal = {Computational Linguistics},
  author = {Goodman, Joshua},
  year = {1999},
  pages = {573--605},
  file = {/Users/doisinkidney/Zotero/storage/HBF9Q8A5/Goodman - Semiring Parsing.pdf;/Users/doisinkidney/Zotero/storage/KVJP8F9R/research.html;/Users/doisinkidney/Zotero/storage/M7PWXU2P/cat.inist.fr.html;/Users/doisinkidney/Zotero/storage/VK4ZF4RE/citation.html}
}

@inproceedings{rivasMonoidsNearsemiringsEssence2015,
  title = {From Monoids to Near-Semirings: The Essence of {{MonadPlus}} and {{Alternative}}},
  isbn = {978-1-4503-3516-4},
  shorttitle = {From Monoids to Near-Semirings},
  abstract = {It is well-known that monads are monoids in the category of endo-functors, and in fact so are applicative functors. Unfortunately, the benefits of this unified view are lost when the additional non-determinism structure of |MonadPlus| or |Alternative| is required.

This article recovers the essence of these two type classes by extending monoids to near-semirings with both additive and multiplicative structure. This unified algebraic view enables us to generically define the free construction as well as a novel double Cayley representation that optimises both left-nested sums and left-nested products.},
  language = {en},
  booktitle = {Proceedings of the 17th {{International Symposium}} on {{Principles}} and {{Practice}} of {{Declarative Programming}}},
  publisher = {{ACM}},
  doi = {10.1145/2790449.2790514},
  author = {Rivas, Exequiel and Jaskelioff, Mauro and Schrijvers, Tom},
  year = {2015},
  pages = {196-207},
  file = {/Users/doisinkidney/Zotero/storage/TQ2SUXE7/Rivas et al. - From monoids to near-semirings the essence of Mon.pdf}
}

@inproceedings{kepnerMathematicalFoundationsGraphBLAS2016,
  title = {Mathematical Foundations of the {{GraphBLAS}}},
  booktitle = {High {{Performance Extreme Computing Conference}} ({{HPEC}}), 2016 {{IEEE}}},
  publisher = {{IEEE}},
  author = {Kepner, Jeremy and Aaltonen, Peter and Bader, David and Bulu{\c c}, Aydin and Franchetti, Franz and Gilbert, John and Hutchison, Dylan and Kumar, Manoj and Lumsdaine, Andrew and Meyerhenke, Henning and others},
  year = {2016},
  pages = {1--9},
  file = {/Users/doisinkidney/Zotero/storage/W6QT46EA/1606.05790.pdf}
}

@inproceedings{reedDistanceMakesTypes2010,
  title = {Distance Makes the Types Grow Stronger: A Calculus for Differential Privacy},
  volume = {45},
  shorttitle = {Distance Makes the Types Grow Stronger},
  booktitle = {{{ACM Sigplan Notices}}},
  publisher = {{ACM}},
  author = {Reed, Jason and Pierce, Benjamin C.},
  year = {2010},
  pages = {157--168},
  file = {/Users/doisinkidney/Zotero/storage/FU78V8H8/Reed and Pierce - 2010 - Distance makes the types grow stronger a calculus.pdf;/Users/doisinkidney/Zotero/storage/M66WU4PF/citation.html}
}

@incollection{giryCategoricalApproachProbability1982,
  address = {{Berlin, Heidelberg}},
  title = {A Categorical Approach to Probability Theory},
  volume = {915},
  isbn = {978-3-540-11211-2 978-3-540-39041-1},
  booktitle = {Categorical {{Aspects}} of {{Topology}} and {{Analysis}}},
  publisher = {{Springer Berlin Heidelberg}},
  doi = {10.1007/BFb0092872},
  author = {Giry, Mich{\`e}le},
  editor = {Dold, A. and Eckmann, B. and Banaschewski, B.},
  year = {1982},
  keywords = {Category Theory,Probability},
  pages = {68-85},
  file = {/Users/doisinkidney/Zotero/storage/N7WJCNMA/giry1982.pdf}
}

@inproceedings{dworkDifferentialPrivacy2006,
  address = {{Venice, Italy}},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Differential {{Privacy}}},
  volume = {4052},
  copyright = {\textcopyright{}2006 Springer-Verlag Berlin Heidelberg},
  isbn = {978-3-540-35907-4 978-3-540-35908-1},
  abstract = {In 1977 Dalenius articulated a desideratum for statistical databases: nothing about an individual should be learnable from the database that cannot be learned without access to the database. We give a general impossibility result showing that a formalization of Dalenius' goal along the lines of semantic security cannot be achieved. Contrary to intuition, a variant of the result threatens the privacy even of someone not in the database. This state of affairs suggests a new measure, differential privacy, which, intuitively, captures the increased risk to one's privacy incurred by participating in a database. The techniques developed in a sequence of papers [8, 13, 3], culminating in those described in [12], can achieve any desired level of privacy under this measure. In many cases, extremely accurate information about the database can be provided while simultaneously ensuring very high levels of privacy.},
  language = {en},
  booktitle = {33rd {{International Colloquium}} on {{Automata}}, {{Languages}} and {{Programming}}, Part {{II}} ({{ICALP}} 2006)},
  publisher = {{Springer Verlag}},
  doi = {10.1007/11787006_1},
  author = {Dwork, Cynthia},
  editor = {Bugliesi, Michele and Preneel, Bart and Sassone, Vladimiro and Wegener, Ingo},
  month = jul,
  year = {2006},
  keywords = {Data Structures,Programming Techniques,Theory of Computation,Software Engineering/Programming and Operating Systems,Discrete Mathematics in Computer Science,Numeric Computing},
  pages = {1-12},
  file = {/Users/doisinkidney/Zotero/storage/EE8TZ2UQ/dwork.pdf;/Users/doisinkidney/Zotero/storage/MRNBSBIZ/10.html}
}

@incollection{kohlasComputationValuationAlgebras2000,
  series = {Handbook of {{Defeasible Reasoning}} and {{Uncertainty Management Systems}}},
  title = {Computation in {{Valuation Algebras}}},
  copyright = {\textcopyright{}2000 Springer Science+Business Media Dordrecht},
  isbn = {978-90-481-5603-0 978-94-017-1737-3},
  abstract = {The main goal of this chapter is to describe an abstract framework called valuation algebra for computing marginals using local computation. The valuation algebra framework is useful in many domains, and especially for managing uncertainty in expert systems using probability, Dempster-Shafer belief functions, Spohnian epistemic belief theory, and possibility theory.},
  language = {en},
  number = {5},
  booktitle = {Handbook of {{Defeasible Reasoning}} and {{Uncertainty Management Systems}}},
  publisher = {{Springer Netherlands}},
  doi = {10.1007/978-94-017-1737-3_2},
  author = {Kohlas, J{\"u}rg and Shenoy, Prakash P.},
  editor = {Kohlas, J{\"u}rg and Moral, Seraf{\'i}n},
  year = {2000},
  keywords = {Mathematical Logic and Foundations,Programming Languages; Compilers; Interpreters,Theory of Computation,Logic,Artificial Intelligence (incl. Robotics)},
  pages = {5-39},
  file = {/Users/doisinkidney/Zotero/storage/A8IAQV8Z/download.pdf}
}

@article{kohlasSemiringInducedValuation2008,
  title = {Semiring {{Induced Valuation Algebras}}: {{Exact}} and {{Approximate Local Computation Algorithms}}},
  volume = {172},
  issn = {0004-3702},
  shorttitle = {Semiring {{Induced Valuation Algebras}}},
  abstract = {Local computation in join trees or acyclic hypertrees has been shown to be linked to a particular algebraic structure, called valuation algebra. There are many models of this algebraic structure ranging from probability theory to numerical analysis, relational databases and various classical and non-classical logics. It turns out that many interesting models of valuation algebras may be derived from semiring valued mappings. In this paper we study how valuation algebras are induced by semirings and how the structure of the valuation algebra is related to the algebraic structure of the semiring. In particular, c-semirings with idempotent multiplication induce idempotent valuation algebras and therefore permit particularly efficient architectures for local computation. Also important are semirings whose multiplicative semigroup is embedded in a union of groups. They induce valuation algebras with a partially defined division. For these valuation algebras, the well-known architectures for Bayesian networks apply. We also extend the general computational framework to allow derivation of bounds and approximations, for when exact computation is not feasible.},
  number = {11},
  journal = {Artificial Intelligence},
  doi = {10.1016/j.artint.2008.03.003},
  author = {Kohlas, Juerg and Wilson, Nic},
  month = jul,
  year = {2008},
  keywords = {Semirings,Valuation algebras,Local computation,Join tree decompositions,Soft constraints,Uncertainty,Valuation networks},
  pages = {1360--1399},
  file = {/Users/doisinkidney/Zotero/storage/RXZXM9GX/Kohlasa and Wilsonb - 2008 - Semiring induced valuation algebras Exact and app.pdf}
}

@article{spiveyAlgebrasCombinatorialSearch2009,
  title = {Algebras for Combinatorial Search},
  volume = {19},
  issn = {1469-7653, 0956-7968},
  abstract = {AbstractCombinatorial search strategies including depth-first, breadth-first and depth-bounded search are shown to be different implementations of a common algebraic specification that emphasizes the compositionality of the strategies. This specification is placed in a categorical setting that combines algebraic specifications and monads.},
  number = {3-4},
  journal = {Journal of Functional Programming},
  doi = {10.1017/S0956796809007321},
  author = {Spivey, J. Michael},
  month = jul,
  year = {2009},
  pages = {469-487},
  file = {/Users/doisinkidney/Zotero/storage/RJBV6ADB/373bb6e7e7837ebc524da0a25903958554ed.pdf;/Users/doisinkidney/Zotero/storage/HVBMPBM2/AB57FF99CEA76C1C31A336B560D6FD3C.html}
}

@article{ebadiFeatherweightPINQ2015,
  archivePrefix = {arXiv},
  eprint = {1505.02642},
  primaryClass = {cs},
  title = {Featherweight {{PINQ}}},
  abstract = {Differentially private mechanisms enjoy a variety of composition properties. Leveraging these, McSherry introduced PINQ (SIGMOD 2009), a system empowering non-experts to construct new differentially private analyses. PINQ is an LINQ-like API which provides automatic privacy guarantees for all programs which use it to mediate sensitive data manipulation. In this work we introduce featherweight PINQ, a formal model capturing the essence of PINQ. We prove that any program interacting with featherweight PINQ's API is differentially private.},
  journal = {arXiv:1505.02642 [cs]},
  author = {Ebadi, Hamid and Sands, David},
  month = may,
  year = {2015},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/doisinkidney/Zotero/storage/URLNQJLV/Ebadi and Sands - 2015 - Featherweight PINQ.pdf;/Users/doisinkidney/Zotero/storage/UETPNDVU/1505.html}
}

@inproceedings{machanavajjhalaLdiversityPrivacyKanonymity2006,
  title = {L-Diversity: Privacy beyond k-Anonymity},
  shorttitle = {L-Diversity},
  abstract = {Publishing data about individuals without revealing sensitive information about them is an important problem. In recent years, a new definition of privacy called kappa-anonymity has gained popularity. In a kappa-anonymized dataset, each record is indistinguishable from at least k\textemdash{}1 other records with respect to certain "identifying" attributes. In this paper we show with two simple attacks that a kappa-anonymized dataset has some subtle, but severe privacy problems. First, we show that an attacker can discover the values of sensitive attributes when there is little diversity in those sensitive attributes. Second, attackers often have background knowledge, and we show that kappa-anonymity does not guarantee privacy against attackers using background knowledge. We give a detailed analysis of these two attacks and we propose a novel and powerful privacy definition called ell-diversity. In addition to building a formal foundation for ell-diversity, we show in an experimental evaluation that ell-diversity is practical and can be implemented efficiently.},
  booktitle = {22nd {{International Conference}} on {{Data Engineering}} ({{ICDE}}'06)},
  doi = {10.1109/ICDE.2006.1},
  author = {Machanavajjhala, A. and Gehrke, J. and Kifer, D. and Venkitasubramaniam, M.},
  month = apr,
  year = {2006},
  keywords = {Computer science,Information analysis,Cardiac disease,Data privacy,Information resources,Insurance,Joining processes,Medical conditions,Medical diagnostic imaging,Publishing},
  pages = {24-24},
  file = {/Users/doisinkidney/Zotero/storage/3A784HFN/Machanavajjhala et al. - 2006 - L-diversity privacy beyond k-anonymity.pdf;/Users/doisinkidney/Zotero/storage/4AMFBX8C/1617392.html}
}

@article{sweeneyKanonymityModelProtecting2002,
  title = {K-Anonymity: {{A Model}} for {{Protecting Privacy}}},
  volume = {10},
  issn = {0218-4885},
  shorttitle = {K-Anonymity},
  abstract = {Consider a data holder, such as a hospital or a bank, that has a privately held collection of person-specific, field structured data. Suppose the data holder wants to share a version of the data with researchers. How can a data holder release a version of its private data with scientific guarantees that the individuals who are the subjects of the data cannot be re-identified while the data remain practically useful? The solution provided in this paper includes a formal protection model named k-anonymity and a set of accompanying policies for deployment. A release provides k-anonymity protection if the information for each person contained in the release cannot be distinguished from at least k-1 individuals whose information also appears in the release. This paper also examines re-identification attacks that can be realized on releases that adhere to k- anonymity unless accompanying policies are respected. The k-anonymity protection model is important because it forms the basis on which the real-world systems known as Datafly, {$\mathrm{\mu}$}-Argus and k-Similar provide guarantees of privacy protection.},
  number = {5},
  journal = {Int. J. Uncertain. Fuzziness Knowl.-Based Syst.},
  doi = {10.1142/S0218488502001648},
  author = {Sweeney, Latanya},
  month = oct,
  year = {2002},
  keywords = {data privacy,privacy,data anonymity,data fusion,re-identification},
  pages = {557--570},
  file = {/Users/doisinkidney/Zotero/storage/FIEUNLJI/Sweeney - 2002 - k-ANONYMITY A MODEL FOR PROTECTING PRIVACY 1.pdf;/Users/doisinkidney/Zotero/storage/99BNRQKY/summary.html}
}

@inproceedings{liTClosenessPrivacyKAnonymity2007,
  title = {T-{{Closeness}}: {{Privacy Beyond}} k-{{Anonymity}} and l-{{Diversity}}},
  shorttitle = {T-{{Closeness}}},
  abstract = {The k-anonymity privacy requirement for publishing microdata requires that each equivalence class (i.e., a set of records that are indistinguishable from each other with respect to certain "identifying" attributes) contains at least k records. Recently, several authors have recognized that k-anonymity cannot prevent attribute disclosure. The notion of l-diversity has been proposed to address this; l-diversity requires that each equivalence class has at least l well-represented values for each sensitive attribute. In this paper we show that l-diversity has a number of limitations. In particular, it is neither necessary nor sufficient to prevent attribute disclosure. We propose a novel privacy notion called t-closeness, which requires that the distribution of a sensitive attribute in any equivalence class is close to the distribution of the attribute in the overall table (i.e., the distance between the two distributions should be no more than a threshold t). We choose to use the earth mover distance measure for our t-closeness requirement. We discuss the rationale for t-closeness and illustrate its advantages through examples and experiments.},
  booktitle = {2007 {{IEEE}} 23rd {{International Conference}} on {{Data Engineering}}},
  doi = {10.1109/ICDE.2007.367856},
  author = {Li, N. and Li, T. and Venkatasubramanian, S.},
  month = apr,
  year = {2007},
  keywords = {Computer science,data privacy,Privacy,Publishing,Databases,Diseases,Protection,Data security,attribute disclosure,database theory,Earth,earth mover distance measure,equivalence class,identifying attributes,k-anonymity privacy requirement,l-diversity,microdata publishing,Motion measurement,Remuneration,t-closeness},
  pages = {106-115},
  file = {/Users/doisinkidney/Zotero/storage/HJN44YDS/Li et al. - 2007 - t-Closeness Privacy Beyond k-Anonymity and l-Dive.pdf;/Users/doisinkidney/Zotero/storage/PWK47BRU/4221659.html}
}

@inproceedings{danielssonBagEquivalenceProofRelevant2012,
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Bag {{Equivalence}} via a {{Proof}}-{{Relevant Membership Relation}}},
  isbn = {978-3-642-32346-1 978-3-642-32347-8},
  abstract = {Two lists are bag equivalent if they are permutations of each other, i.e. if they contain the same elements, with the same multiplicity, but perhaps not in the same order. This paper describes how one can define bag equivalence as the presence of bijections between sets of membership proofs. This definition has some desirable properties: Many bag equivalences can be proved using a flexible form of equational reasoning. The definition generalises easily to arbitrary unary containers, including types with infinite values, such as streams. By using a slight variation of the definition one gets set equivalence instead, i.e. equality up to order and multiplicity. Other variations give the subset and subbag preorders. The definition works well in mechanised proofs.},
  language = {en},
  booktitle = {Interactive {{Theorem Proving}}},
  publisher = {{Springer, Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-32347-8_11},
  author = {Danielsson, Nils Anders},
  month = aug,
  year = {2012},
  pages = {149-165},
  file = {/Users/doisinkidney/Zotero/storage/48TN8RVW/Danielsson - 2012 - Bag Equivalence via a Proof-Relevant Membership Re.pdf;/Users/doisinkidney/Zotero/storage/6FHBRC2J/Danielsson - 2012 - Bag Equivalence via a Proof-Relevant Membership Re.pdf;/Users/doisinkidney/Zotero/storage/Z3C57Z7B/10.html}
}

@inproceedings{bartheProvingDifferentialPrivacy2014,
  title = {Proving {{Differential Privacy}} in {{Hoare Logic}}},
  abstract = {Differential privacy is a rigorous, worst-case notion of privacy-preserving computation. Informally, a probabilistic program is differentially private if the participation of a single individual in the input database has a limited effect on the program's distribution on outputs. More technically, differential privacy is a quantitative 2-safety property that bounds the distance between the output distributions of a probabilistic program on adjacent inputs. Like many 2-safety properties, differential privacy lies outside the scope of traditional verification techniques. Existing approaches to enforce privacy are based on intricate, non-conventional type systems, or customized relational logics. These approaches are difficult to implement and often cumbersome to use. We present an alternative approach that verifies differential privacy by standard, non-relational reasoning on non-probabilistic programs. Our approach transforms a probabilistic program into a non-probabilistic program which simulates two executions of the original program. We prove that if the target program is correct with respect to a Hoare specification, then the original probabilistic program is differentially private. We provide a variety of examples from the differential privacy literature to demonstrate the utility of our approach. Finally, we compare our approach with existing verification techniques for privacy.},
  booktitle = {2014 {{IEEE}} 27th {{Computer Security Foundations Symposium}}},
  doi = {10.1109/CSF.2014.36},
  author = {Barthe, G. and Gaboardi, M. and Arias, E. J. G. and Hsu, J. and Kunz, C. and Strub, P. Y.},
  month = jul,
  year = {2014},
  keywords = {verification,data privacy,differential privacy,Privacy,privacy,Data privacy,Databases,formal logic,relational hoare logic,differential privacy literature,hoare logic,Hoare logic,Hoare specification,many 2-safety properties,nonprobabilistic programs,nonrelational reasoning,privacy-preserving computation,probabilistic hoare logic,Probabilistic logic,quantitative 2-safety property,Safety,Standards,Synchronization,verification techniques,worst-case notion},
  pages = {411-424},
  file = {/Users/doisinkidney/Zotero/storage/NIT965PQ/Barthe et al. - 2014 - Proving Differential Privacy in Hoare Logic.pdf;/Users/doisinkidney/Zotero/storage/QMV5IRQD/6957126.html}
}

@techreport{norellDependentlyTypedProgramming2008,
  title = {Dependently {{Typed Programming}} in {{Agda}}},
  copyright = {Springer-Verlag},
  language = {en},
  author = {Norell, Ulf and Chapman, James},
  year = {2008},
  file = {/Users/doisinkidney/Zotero/storage/N2JXRX7J/Norell and Chapman - Dependently Typed Programming in Agda.pdf}
}

@article{cohenCubicalTypeTheory2016,
  archivePrefix = {arXiv},
  eprint = {1611.02108},
  primaryClass = {cs, math},
  title = {Cubical {{Type Theory}}: A Constructive Interpretation of the Univalence Axiom},
  shorttitle = {Cubical {{Type Theory}}},
  abstract = {This paper presents a type theory in which it is possible to directly manipulate \$n\$-dimensional cubes (points, lines, squares, cubes, etc.) based on an interpretation of dependent type theory in a cubical set model. This enables new ways to reason about identity types, for instance, function extensionality is directly provable in the system. Further, Voevodsky's univalence axiom is provable in this system. We also explain an extension with some higher inductive types like the circle and propositional truncation. Finally we provide semantics for this cubical type theory in a constructive meta-theory.},
  language = {en},
  journal = {arXiv:1611.02108 [cs, math]},
  author = {Cohen, Cyril and Coquand, Thierry and Huber, Simon and M{\"o}rtberg, Anders},
  month = nov,
  year = {2016},
  keywords = {F.3.2,Computer Science - Logic in Computer Science,F.4.1,Mathematics - Logic},
  pages = {34},
  file = {/Users/doisinkidney/Zotero/storage/JPB35LT3/Cohen et al. - 2016 - Cubical Type Theory a constructive interpretation.pdf;/Users/doisinkidney/Zotero/storage/SAVUJFRF/Cohen et al. - 2016 - Cubical Type Theory a constructive interpretation.pdf;/Users/doisinkidney/Zotero/storage/WNZZ885E/Cohen et al. - 2016 - Cubical Type Theory a constructive interpretation.pdf;/Users/doisinkidney/Zotero/storage/YYV2LT9Q/Cohen et al. - Cubical Type Theory a constructive interpretation.pdf;/Users/doisinkidney/Zotero/storage/JRUQW2TM/1611.html;/Users/doisinkidney/Zotero/storage/V8XZUFR6/1611.html}
}

@inproceedings{oconnorApplicationsApplicativeProof2016,
  address = {{New York, NY, USA}},
  series = {{{TyDe}} 2016},
  title = {Applications of {{Applicative Proof Search}}},
  isbn = {978-1-4503-4435-7},
  abstract = {In this paper, we develop a library of typed proof search procedures, and demonstrate their remarkable utility as a mechanism for proof-search and automation. We describe a framework for describing proof-search procedures in Agda, with a library of tactical combinators based on applicative functors. This framework is very general, so we demonstrate the approach with two common applications from the field of software verification: a library for property-based testing in the style of SmallCheck, and the embedding of a basic model checker inside our framework, which we use to verify the correctness of common concurrency algorithms.},
  booktitle = {Proceedings of the 1st {{International Workshop}} on {{Type}}-{{Driven Development}}},
  publisher = {{ACM}},
  doi = {10.1145/2976022.2976030},
  author = {O'Connor, Liam},
  year = {2016},
  keywords = {Agda,automation,concurrency,critical section,model checking,proof,properties,testing},
  pages = {43--55},
  file = {/Users/doisinkidney/Zotero/storage/L9AIHCP8/O'Connor - 2016 - Applications of Applicative Proof Search.pdf}
}

@article{muAlgebraProgrammingAgda2009,
  title = {Algebra of Programming in {{Agda}}: {{Dependent}} Types for Relational Program Derivation},
  volume = {19},
  issn = {1469-7653, 0956-7968},
  shorttitle = {Algebra of Programming in {{Agda}}},
  abstract = {Relational program derivation is the technique of stepwise refining a relational specification to a program by algebraic rules. The program thus obtained is correct by construction. Meanwhile, dependent type theory is rich enough to express various correctness properties to be verified by the type checker. We have developed a library, AoPA (Algebra of Programming in Agda), to encode relational derivations in the dependently typed programming language Agda. A program is coupled with an algebraic derivation whose correctness is guaranteed by the type system. Two non-trivial examples are presented: an optimisation problem and a derivation of quicksort in which well-founded recursion is used to model terminating hylomorphisms in a language with inductive types.},
  language = {en},
  number = {5},
  journal = {Journal of Functional Programming},
  doi = {10.1017/S0956796809007345},
  author = {Mu, Shin-Cheng and Ko, Hsiang-Shang and Jansson, Patrik},
  month = sep,
  year = {2009},
  pages = {545-579},
  file = {/Users/doisinkidney/Zotero/storage/D7UWNTJ4/Mu et al. - 2009 - Algebra of programming in Agda Dependent types fo.pdf;/Users/doisinkidney/Zotero/storage/D8FNYT4X/Mu et al. - 2009 - Algebra of programming in Agda Dependent types fo.pdf;/Users/doisinkidney/Zotero/storage/5D6VGKJQ/ACA0C08F29621A892FB0C0B745254D15.html}
}

@book{martin-lofIntuitionisticTypeTheory1980,
  address = {{Padua}},
  title = {Intuitionistic {{Type Theory}}},
  author = {{Martin-L{\"o}f}, Per},
  month = jun,
  year = {1980},
  file = {/Users/doisinkidney/Zotero/storage/IQS3729C/MartinLöf1984.pdf}
}

@inproceedings{abelMiniAgdaIntegratingSized2010,
  title = {{{MiniAgda}}: {{Integrating}} Sized and Dependent Types},
  shorttitle = {Miniagda},
  abstract = {Sized types are a modular and theoretically well-understood tool for checking termination of recursive and productivity of corecursive definitions. The essential idea is to track structural descent and guardedness in the type system to make termination checking robust and suitable for strong abstractions like higher-order functions and polymorphism. To study the application of sized types to proof assistants and programming languages based on dependent type theory, we have implemented a core language, MiniAgda, with explicit handling of sizes. New considerations were necessary to soundly integrate sized types with dependencies and pattern matching, which was made possible by modern concepts such as inaccessible patterns and parametric function spaces. This paper provides an introduction to MiniAgda by example and informal explanations of the underlying principles. 1},
  language = {en},
  booktitle = {{{PAR}}, Volume 43 of {{EPTCS}}},
  author = {Abel, Andreas},
  year = {2010},
  pages = {14--28},
  file = {/Users/doisinkidney/Zotero/storage/C8SGX7MN/Abel - 2010 - Miniagda Integrating sized and dependent types.pdf;/Users/doisinkidney/Zotero/storage/KP266WFQ/Abel - MiniAgda Integrating Sized and Dependent Types.pdf;/Users/doisinkidney/Zotero/storage/LCKS32ZV/summary\;jsessionid=11EAC1E0ADB87A0CC4E950303BE9DB40.html}
}

@phdthesis{girardInterpretationFonctionelleElimination1972,
  type = {{PhD Thesis}},
  title = {{Interpr{\'e}tation fonctionelle et {\'e}limination des coupures de l'arithm{\'e}tique d'ordre sup{\'e}rieur}},
  language = {fr},
  school = {PhD thesis, Universit{\'e} Paris VII},
  author = {Girard, Jean-Yves},
  year = {1972},
  file = {/Users/doisinkidney/Zotero/storage/QLIN2G73/Girard - Interprétation fonctionnelle et élimination des co.pdf}
}

@book{mcbrideDatatypesDatatypes2015,
  title = {Datatypes of {{Datatypes}}},
  author = {McBride, Conor},
  month = jul,
  year = {2015},
  file = {/Users/doisinkidney/Zotero/storage/QKDM8YLS/conor.pdf}
}

@article{firsovVariationsNoetherianness2016a,
  archivePrefix = {arXiv},
  eprint = {1604.01186},
  title = {Variations on {{Noetherianness}}},
  volume = {207},
  issn = {2075-2180},
  abstract = {In constructive mathematics, several nonequivalent notions of finiteness exist. In this paper, we continue the study of Noetherian sets in the dependently typed setting of the Agda programming language. We want to say that a set is Noetherian, if, when we are shown elements from it one after another, we will sooner or later have seen some element twice. This idea can be made precise in a number of ways. We explore the properties and connections of some of the possible encodings. In particular, we show that certain implementations imply decidable equality while others do not, and we construct counterexamples in the latter case. Additionally, we explore the relation between Noetherianness and other notions of finiteness.},
  journal = {Electronic Proceedings in Theoretical Computer Science},
  doi = {10.4204/EPTCS.207.4},
  author = {Firsov, Denis and Uustalu, Tarmo and Veltri, Niccol{\`o}},
  month = apr,
  year = {2016},
  keywords = {Computer Science - Programming Languages,Computer Science - Logic in Computer Science,F.4.1},
  pages = {76-88},
  file = {/Users/doisinkidney/Zotero/storage/QLSZIV5G/Firsov et al. - 2016 - Variations on Noetherianness.pdf;/Users/doisinkidney/Zotero/storage/WQB4B4EL/Firsov et al. - 2016 - Variations on Noetherianness.pdf;/Users/doisinkidney/Zotero/storage/CI6FAX9P/1604.html},
  ids = {firsovVariationsNoetherianness2016}
}

@article{escardoInfiniteSetsThat2013a,
  title = {Infinite Sets That {{Satisfy}} the {{Principle}} of {{Omniscience}} in Any {{Variety}} of {{Constructive Mathematics}}},
  volume = {78},
  issn = {0022-4812, 1943-5886},
  abstract = {We show that there are plenty of infinite sets that satisfy the omniscience principle, in a minimalistic setting for constructive mathematics that is compatible with classical mathematics. A first example of an omniscient set is the one-point compactification of the natural numbers, also known as the generic convergent sequence. We relate this to Grilliot's and Ishihara's Tricks. We generalize this example to many infinite subsets of the Cantor space. These subsets turn out to be ordinals in a constructive sense, with respect to the lexicographic order, satisfying both a well-foundedness condition with respect to decidable subsets, and transfinite induction restricted to decidable predicates. The use of simple types allows us to reach any ordinal below {$\epsilon$}Q, and richer type systems allow us to get higher.},
  language = {en},
  number = {3},
  journal = {The Journal of Symbolic Logic},
  doi = {10.2178/jsl.7803040},
  author = {Escard{\'o}, Mart{\'i}n H.},
  month = sep,
  year = {2013},
  pages = {764-784},
  file = {/Users/doisinkidney/Zotero/storage/6H9Q8Q8A/Escardó - 2013 - Infinite sets that Satisfy the Principle of Omnisc.pdf;/Users/doisinkidney/Zotero/storage/CKLD89PY/Escardó - 2013 - Infinite sets that Satisfy the Principle of Omnisc.pdf;/Users/doisinkidney/Zotero/storage/H6XN99YN/Escardó - 2013 - Infinite sets that Satisfy the Principle of Omnisc.pdf;/Users/doisinkidney/Zotero/storage/PTKCLWTC/0D204ADE629B703578B848B8573FC83D.html},
  ids = {escardoInfiniteSetsThat2013}
}

@article{Elliott2019-convolution-extended,
  title = {Generalized Convolution and Efficient Language Recognition (Extended Version)},
  volume = {abs/1903.10677},
  abstract = {Convolution is a broadly useful operation with applications including signal
processing, machine learning, probability, optics, polynomial multiplication,
and efficient parsing. Usually, however, this operation is understood and
implemented in more specialized forms, hiding commonalities and limiting
usefulness. This paper formulates convolution in the common algebraic framework
of semirings and semimodules and populates that framework with various
representation types. One of those types is the grand abstract template and
itself generalizes to the free semimodule monad. Other representations serve
varied uses and performance trade-offs, with implementations calculated from
simple and regular specifications.
  Of particular interest is Brzozowski's method for regular expression
matching. Uncovering the method's essence frees it from syntactic
manipulations, while generalizing from boolean to weighted membership (such as
multisets and probability distributions) and from sets to n-ary relations. The
classic trie data structure then provides an elegant and efficient alternative
to syntax.
  Pleasantly, polynomial arithmetic requires no additional implementation
effort, works correctly with a variety of representations, and handles
multivariate polynomials and power series with ease. Image convolution also
falls out as a special case.},
  language = {en},
  journal = {CoRR},
  author = {Elliott, Conal},
  month = mar,
  year = {2019},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/doisinkidney/Zotero/storage/3LB7UDNG/Elliott - 2019 - Generalized Convolution and Efficient Language Rec.pdf;/Users/doisinkidney/Zotero/storage/BFKQERZA/Elliott - 2019 - Generalized Convolution and Efficient Language Rec.pdf;/Users/doisinkidney/Zotero/storage/CEMJCIPZ/Elliott - 2019 - Generalized convolution and efficient language rec.pdf;/Users/doisinkidney/Zotero/storage/EBLWWXIK/1903.html;/Users/doisinkidney/Zotero/storage/JXJZGA8T/1903.html},
  mon = {03}
}

@unpublished{altenkirchDefinableQuotientsType2011,
  title = {Definable {{Quotients}} in {{Type Theory}}},
  abstract = {In Type Theory, a quotient set is a set representing a setoid. Categorically, this corresponds to the concept of an exact coequalizer. In the present paper we consider the case of a definable quotients, where the quotient set arises as the codomain of a normalization function \textemdash{}this corresponds to the notion of a split coequalizer. We give a number of examples of definable quotients and notice that it is preferable to use the setoid structure when reasoning about the quotient set. We also show that there are examples where setoids cannot be represented in ordinary Type Theory such as the real numbers or the partiality monad under the assumption that local continuity is admissible in Type Theory.},
  language = {en},
  author = {Altenkirch, Thorsten and Anberr{\'e}e, Thomas and Li, Nuo},
  year = {2011},
  file = {/Users/doisinkidney/Zotero/storage/YQ3ZSEZA/Altenkirch et al. - Deﬁnable Quotients in Type Theory.pdf}
}

@inproceedings{fruminFiniteSetsHomotopy2018,
  address = {{New York, NY, USA}},
  series = {{{CPP}} 2018},
  title = {Finite {{Sets}} in {{Homotopy Type Theory}}},
  isbn = {978-1-4503-5586-5},
  abstract = {We study different formalizations of finite sets in homotopy type theory to obtain a general definition that exhibits both the computational facilities and the proof principles expected from finite sets. We use higher inductive types to define the type K(A) of "finite sets over type A" {\`a} la Kuratowski without assuming that K(A) has decidable equality. We show how to define basic functions and prove basic properties after which we give two applications of our definition.  On the foundational side, we use K to define the notions of "Kuratowski-finite type" and "Kuratowski-finite subobject", which we contrast with established notions, e.g. Bishop-finite types and enumerated types. We argue that Kuratowski-finiteness is the most general and flexible one of those and we define the usual operations on finite types and subobjects.  From the computational perspective, we show how to use K(A) for an abstract interface for well-known finite set implementations such as tree- and list-like data structures. This implies that a function defined on a concrete finite sets implementation can be obtained from a function defined on the abstract finite sets K(A) and that correctness properties are inherited. Hence, HoTT is the ideal setting for data refinement. Beside this, we define bounded quantification, which lifts a decidable property on A to one on K(A).},
  booktitle = {Proceedings of the 7th {{ACM SIGPLAN International Conference}} on {{Certified Programs}} and {{Proofs}}},
  publisher = {{ACM}},
  doi = {10.1145/3167085},
  author = {Frumin, Dan and Geuvers, Herman and Gondelman, L{\'e}on and van der Weide, Niels},
  year = {2018},
  keywords = {Coq,finite sets,finite types,higher inductive types,homotopy type theory},
  pages = {201--214},
  file = {/Users/doisinkidney/Zotero/storage/CKKYWGDG/Frumin et al. - 2018 - Finite Sets in Homotopy Type Theory.pdf}
}

@inproceedings{faissoleSyntheticTopologyHomotopy2017,
  title = {Synthetic Topology in {{Homotopy Type Theory}} for Probabilistic Programming},
  abstract = {The ALEA Coq library formalizes discrete measure theory using a variant of the Giry monad, as a submonad of the CPS monad: (A \textrightarrow{} [0, 1]) \textrightarrow{} [0, 1]. This allows one to use Moggi's monadic metalanguage to give an interpretation of a language, Rml, into type theory. Rml is a functional language with a primitive for probabilistic choice. This formalization was the semantical basis for the Certicrypt system for verifying security protocols. The Easycrypt proof assistant is still based on the same semantics. We improve on the formalization by using homotopy type theory which provides e.g. quotients and functional extensionality. Moreover, homotopy type theory allows us to use synthetic topology to present a theory which also includes non-discrete (`continuous') data types, like [0, 1]. Such data types are relevant, for instance, in machine learning and differential privacy. Our axioms are justified by KleeneVesley realizability, a standard model for computation with continuous data types.},
  language = {en},
  booktitle = {{{PPS}} 2017 - {{Workshop}} on Probabilistic Programming Semantics},
  author = {Faissole, Florian and Spitters, Bas},
  month = jan,
  year = {2017},
  pages = {3},
  file = {/Users/doisinkidney/Zotero/storage/7KV6T23I/Faissole and Spitters - Synthetic topology in Homotopy Type Theory for pro.pdf;/Users/doisinkidney/Zotero/storage/N59UYWL4/Faissole and Spitters - Synthetic topology in Homotopy Type Theory for pro.pdf;/Users/doisinkidney/Zotero/storage/YQ4JZ8Z4/Faissole and Spitters - Synthetic topology in Homotopy Type Theory for pro.pdf;/Users/doisinkidney/Zotero/storage/453XWDRX/hal-01485397.html},
  ids = {faissoleSyntheticTopologyHomotopy}
}

@article{kuratowskiNotionEnsembleFini1920,
  title = {{Sur la notion d'ensemble fini}},
  volume = {1},
  issn = {0016-2736},
  language = {fra},
  number = {1},
  journal = {Fundamenta Mathematicae},
  author = {Kuratowski, Casimir},
  year = {1920},
  pages = {129-131},
  file = {/Users/doisinkidney/Zotero/storage/K77HL5NV/212596.html}
}

@inproceedings{karatsubaMultiplicationManyDigitalNumbers1962,
  title = {{Multiplication of Many-Digital Numbers by Automatic Computers}},
  volume = {145},
  language = {ru},
  booktitle = {{Doklady Akademii Nauk}},
  publisher = {{Russian Academy of Sciences}},
  author = {Karatsuba, Anatolii Alekseevich and Ofman, Yuri Petrovich},
  year = {1962},
  pages = {293--294},
  file = {/Users/doisinkidney/Zotero/storage/K4U4YKLM/Karatsuba and Ofman - Multiplication of many-digital numbers by automati.pdf;/Users/doisinkidney/Zotero/storage/XXMZMUSY/archive.html}
}

@article{hofnerDijkstraFloydWarshall2012,
  title = {Dijkstra, {{Floyd}} and {{Warshall}} Meet {{Kleene}}},
  volume = {24},
  issn = {0934-5043, 1433-299X},
  abstract = {Around 1960, Dijkstra, Floyd and Warshall published papers on algorithms for solving singlesource and all-sources shortest path problems, respectively. These algorithms, nowadays named after their inventors, are well known and well established. This paper sheds an algebraic light on these algorithms. We combine the shortest path problems with Kleene algebra, also known as Conway's regular algebra. This view yields a purely algebraic version of Dijkstra's shortest path algorithm and the one by Floyd/Warshall. Moreover, the algebraic abstraction yields applications of these algorithms to structures different from graphs and pinpoints the mathematical requirements on the underlying cost algebra that ensure their correctness.},
  language = {en},
  number = {4-6},
  journal = {Formal Aspects of Computing},
  doi = {10.1007/s00165-012-0245-4},
  author = {H{\"o}fner, Peter and M{\"o}ller, Bernhard},
  month = jul,
  year = {2012},
  pages = {459-476},
  file = {/Users/doisinkidney/Zotero/storage/DLA3SE88/Höfner and Möller - 2012 - Dijkstra, Floyd and Warshall meet Kleene.pdf}
}

@inproceedings{smolkaHereditarilyFiniteSets2016b,
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Hereditarily {{Finite Sets}} in {{Constructive Type Theory}}},
  isbn = {978-3-319-43144-4},
  abstract = {We axiomatize hereditarily finite sets in constructive type theory and show that all models of the axiomatization are isomorphic. The axiomatization takes the empty set and adjunction as primitives and comes with a strong induction principle. Based on the axiomatization, we construct the set operations of ZF and develop the basic theory of finite ordinals and cardinality. We construct a model of the axiomatization as a quotient of an inductive type of binary trees. The development is carried out in Coq.},
  language = {en},
  booktitle = {Interactive {{Theorem Proving}}},
  publisher = {{Springer International Publishing}},
  author = {Smolka, Gert and Stark, Kathrin},
  editor = {Blanchette, Jasmin Christian and Merz, Stephan},
  year = {2016},
  keywords = {Type Theory,Binary Tree,Induction Principle,Inductive Type,Transitive Closure},
  pages = {374-390},
  file = {/Users/doisinkidney/Zotero/storage/4TF4N39F/Smolka and Stark - 2016 - Hereditarily Finite Sets in Constructive Type Theo.pdf},
  ids = {smolkaHereditarilyFiniteSets2016,smolkaHereditarilyFiniteSets2016a}
}

@article{bernardyCertifiedContextFreeParsing2016,
  archivePrefix = {arXiv},
  eprint = {1601.07724},
  title = {Certified {{Context}}-{{Free Parsing}}: {{A}} Formalisation of {{Valiant}}'s {{Algorithm}} in {{Agda}}},
  volume = {12},
  issn = {18605974},
  shorttitle = {Certified {{Context}}-{{Free Parsing}}},
  abstract = {Valiant (1975) has developed an algorithm for recognition of context free languages. As of today, it remains the algorithm with the best asymptotic complexity for this purpose. In this paper, we present an algebraic specification, implementation, and proof of correctness of a generalisation of Valiant's algorithm. The generalisation can be used for recognition, parsing or generic calculation of the transitive closure of upper triangular matrices. The proof is certified by the Agda proof assistant. The certification is representative of state-of-the-art methods for specification and proofs in proof assistants based on type-theory. As such, this paper can be read as a tutorial for the Agda system.},
  number = {2},
  journal = {Logical Methods in Computer Science},
  doi = {10.2168/LMCS-12(2:6)2016},
  author = {Bernardy, Jean-Philippe and Jansson, Patrik},
  month = jun,
  year = {2016},
  keywords = {Computer Science - Logic in Computer Science,F.4.1,F.4.2},
  pages = {6},
  file = {/Users/doisinkidney/Zotero/storage/53P9TW38/Bernardy and Jansson - 2016 - Certified Context-Free Parsing A formalisation of.pdf;/Users/doisinkidney/Zotero/storage/GJQ7ZX3J/Bernardy and Jansson - 2016 - Certified Context-Free Parsing A formalisation of.pdf;/Users/doisinkidney/Zotero/storage/SJE2AMQ7/Bernardy and Jansson - 2016 - Certified Context-Free Parsing A formalisation of.pdf;/Users/doisinkidney/Zotero/storage/3MG2VFP7/1601.html;/Users/doisinkidney/Zotero/storage/8D9MHWLY/1601.html;/Users/doisinkidney/Zotero/storage/G6P4CLVI/1601.html}
}

@inproceedings{vandenbrouckeFixingNondeterminism2015,
  address = {{Koblenz, Germany}},
  title = {Fixing Non-Determinism},
  isbn = {978-1-4503-4273-5},
  abstract = {Non-deterministic computations are conventionally modelled by lists of their outcomes. This approach provides a concise declarative description of certain problems, as well as a way of generically solving such problems.},
  language = {en},
  booktitle = {Proceedings of the 27th {{Symposium}} on the {{Implementation}} and {{Application}} of {{Functional Programming Languages}} - {{IFL}} '15},
  publisher = {{ACM Press}},
  doi = {10.1145/2897336.2897342},
  author = {Vandenbroucke, Alexander and Schrijvers, Tom and Piessens, Frank},
  year = {2015},
  pages = {1-12},
  file = {/Users/doisinkidney/Zotero/storage/CDD9XNVG/Vandenbroucke et al. - 2015 - Fixing non-determinism.pdf;/Users/doisinkidney/Zotero/storage/K2Q3SXL7/Vandenbroucke et al. - 2015 - Fixing non-determinism.pdf;/Users/doisinkidney/Zotero/storage/QLYSWAJB/Vandenbroucke et al. - 2015 - Fixing non-determinism.pdf},
  ids = {vandenbrouckeFixingNondeterminism2015}
}

@article{uustaluFinitenessRationalSequences2017a,
  title = {Finiteness and Rational Sequences, Constructively*},
  volume = {27},
  issn = {0956-7968, 1469-7653},
  abstract = {Rational sequences are possibly infinite sequences with a finite number of distinct suffixes. In this paper, we present different implementations of rational sequences in Martin\textendash{}L{\"o}f type theory. First, we literally translate the above definition of rational sequence into the language of type theory, i.e., we construct predicates on possibly infinite sequences expressing the finiteness of the set of suffixes. In type theory, there exist several inequivalent notions of finiteness. We consider two of them, listability and Noetherianness, and show that in the implementation of rational sequences the two notions are interchangeable. Then we introduce the type of lists with backpointers, which is an inductive implementation of rational sequences. Lists with backpointers can be unwound into rational sequences, and rational sequences can be truncated into lists with backpointers. As an example, we see how to convert the fractional representation of a rational number into its decimal representation and vice versa.},
  language = {en},
  journal = {Journal of Functional Programming},
  doi = {10.1017/S0956796817000041},
  author = {Uustalu, Tarmo and Veltri, Niccol{\`o}},
  year = {2017/ed},
  file = {/Users/doisinkidney/Zotero/storage/78BDBIHC/Uustalu and Veltri - 2017 - Finiteness and rational sequences, constructively.pdf;/Users/doisinkidney/Zotero/storage/NDJGV6GD/Uustalu and Veltri - 2017 - Finiteness and rational sequences, constructively.pdf;/Users/doisinkidney/Zotero/storage/M9TH72I2/FCC024B602F850DDCEB2E9092E72369B.html;/Users/doisinkidney/Zotero/storage/VI9F4EKI/FCC024B602F850DDCEB2E9092E72369B.html},
  ids = {uustaluFinitenessRationalSequences2017,uustaluFinitenessRationalSequences2017b}
}

@misc{kmettFreeModulesFunctional2011,
  type = {Blog},
  title = {Free {{Modules}} and {{Functional Linear Functionals}}},
  abstract = {Today I hope to start a new series of posts exploring constructive abstract algebra in Haskell.

In particular, I want to talk about a novel encoding of linear functionals, polynomials and linear maps in Haskell, but first we're going to have to build up some common terminology.

Having obtained the blessing of Wolfgang Jeltsch, I replaced the algebra package on hackage with something... bigger, although still very much a work in progress.},
  journal = {The Comonad.Reader},
  author = {Kmett, Edward},
  month = jul,
  year = {2011},
  file = {/Users/doisinkidney/Zotero/storage/HQJATPFS/free-modules-and-functional-linear-functionals.html;/Users/doisinkidney/Zotero/storage/RCN6GHG3/free-modules-and-functional-linear-functionals.html}
}

@article{wehrungMetricPropertiesPositively1993,
  title = {Metric Properties of Positively Ordered Monoids},
  volume = {5},
  issn = {0933-7741, 1435-5337},
  abstract = {We introduce here an intrinsic (quasi-) metric on each positively ordered monoid (P.O.M.), which is defined in terms of the evaluation map from the given P.O.M. to its bidual and for which P.O.M. homomorphisms are continuous. Moreover, we find a class of refinement P.O.M.'s which, equipped with the canonical metric, are complete metric spaces; this class includes the class of weak cardinal algebras, but also most cases of completions of a certain kind (we will call it `strongly reduced products') of P.O.M.'s, and of which a prototype has been used in a previous paper for the description of the evaluation map of a given refinement P.O.M.. This result can also be viewed as a wide generalization to the non-linearly ordered case (for example weak cardinal algebras) of the (Cauchy-) completeness of the real line.},
  language = {en},
  number = {5},
  journal = {Forum Mathematicum},
  doi = {10.1515/form.1993.5.183},
  author = {Wehrung, Friedrich},
  year = {1993},
  file = {/Users/doisinkidney/Zotero/storage/H4IU3JDE/Wehrung - 1993 - Metric properties of positively ordered monoids.pdf}
}

@article{erwigFUNCTIONALPEARLSProbabilistic2006,
  title = {{{FUNCTIONAL PEARLS}}: {{Probabilistic}} Functional Programming in {{Haskell}}},
  volume = {16},
  issn = {1469-7653, 0956-7968},
  shorttitle = {Functional Pearls},
  abstract = {At the heart of functional programming rests the principle of referential transparency, which in particular means that a function f applied to a value x always yields one and the same value y=f(x). This principle seems to be violated when contemplating the use of functions to describe probabilistic events, such as rolling a die: It is not clear at all what exactly the outcome will be, and neither is it guaranteed that the same value will be produced repeatedly. However, these two seemingly incompatible notions can be reconciled if probabilistic values are encapsulated in a data type.},
  language = {en},
  number = {1},
  journal = {Journal of Functional Programming},
  doi = {10.1017/S0956796805005721},
  author = {Erwig, Martin and Kollmansberger, Steve},
  month = jan,
  year = {2006},
  pages = {21-34},
  file = {/Users/doisinkidney/Zotero/storage/664EJ355/Erwig and Kollmansberger - 2006 - FUNCTIONAL PEARLS Probabilistic functional progra.pdf;/Users/doisinkidney/Zotero/storage/EQNUDQV6/PFP_JFP06.pdf;/Users/doisinkidney/Zotero/storage/DV2L5KXW/8DF2F2B191C68260A961BA3A9F50B332.html}
}

@article{vezzosiCubicalAgdaDependently2019,
  title = {Cubical {{Agda}}: {{A Dependently Typed Programming Language}} with {{Univalence}} and {{Higher Inductive Types}}},
  volume = {3},
  issn = {2475-1421},
  shorttitle = {Cubical {{Agda}}},
  abstract = {Proof assistants based on dependent type theory provide expressive languages for both programming and proving within the same system. However, all of the major implementations lack powerful extensionality principles for reasoning about equality, such as function and propositional extensionality. These principles are typically added axiomatically which disrupts the constructive properties of these systems. Cubical type theory provides a solution by giving computational meaning to Homotopy Type Theory and Univalent Foundations, in particular to the univalence axiom and higher inductive types. This paper describes an extension of the dependently typed functional programming language Agda with cubical primitives, making it into a full-blown proof assistant with native support for univalence and a general schema of higher inductive types. These new primitives make function and propositional extensionality as well as quotient types directly definable with computational content. Additionally, thanks also to copatterns, bisimilarity is equivalent to equality for coinductive types. This extends Agda with support for a wide range of extensionality principles, without sacrificing type checking and constructivity.},
  number = {ICFP},
  journal = {Proc. ACM Program. Lang.},
  doi = {10.1145/3341691},
  author = {Vezzosi, Andrea and M{\"o}rtberg, Anders and Abel, Andreas},
  month = jul,
  year = {2019},
  keywords = {Cubical Type Theory,Dependent Pattern Matching,Higher Inductive Types,Univalence},
  pages = {87:1--87:29},
  file = {/Users/doisinkidney/Zotero/storage/MIGACFXE/Vezzosi et al. - 2019 - Cubical Agda A Dependently Typed Programming Lang.pdf}
}

@inproceedings{Henriksen:2017:FPF:3062341.3062354,
  address = {{New York, NY, USA}},
  series = {{{PLDI}} 2017},
  title = {Futhark: Purely Functional {{GPU}}-Programming with Nested Parallelism and in-Place Array Updates},
  isbn = {978-1-4503-4988-8},
  booktitle = {Proceedings of the 38th {{ACM SIGPLAN}} Conference on Programming Language Design and Implementation},
  publisher = {{ACM}},
  doi = {10.1145/3062341.3062354},
  author = {Henriksen, Troels and Serup, Niels G. W. and Elsman, Martin and Henglein, Fritz and Oancea, Cosmin E.},
  year = {2017},
  keywords = {compilers,functional language,GPGPU,parallel},
  pages = {556-571},
  file = {/Users/doisinkidney/Zotero/storage/9B77LWAR/Henriksen et al. - Futhark Purely Functional GPU-Programming with Ne.pdf},
  acmid = {3062354},
  numpages = {16}
}

@techreport{marlowHaskell2010Language2011,
  title = {Haskell 2010 {{Language Report}}},
  editor = {Marlow, Simon},
  month = may,
  year = {2011},
  file = {/Users/doisinkidney/Zotero/storage/8HDHK4EU/haskell2010.html}
}

@book{osullivanRealWorldHaskell2008,
  title = {Real {{World Haskell}}},
  isbn = {978-0-596-51498-3},
  abstract = {This easy-to-use, fast-moving tutorial introduces you to functional programming with Haskell. You'll learn how to use Haskell in a variety of practical ways, from short scripts to large and demanding applications. Real World Haskell takes you...},
  language = {en},
  author = {O'Sullivan, Bryan and Stewart, Don and Goerzen, John},
  month = nov,
  year = {2008},
  file = {/Users/doisinkidney/Zotero/storage/NNGD6V93/book.realworldhaskell.org.html;/Users/doisinkidney/Zotero/storage/WWELR4MJ/9780596514983.html},
  ids = {RealWorldHaskell}
}

@book{huttonProgrammingHaskell2016,
  address = {{New York}},
  edition = {Second edition},
  title = {Programming in {{Haskell}}},
  isbn = {978-1-316-62622-1},
  lccn = {QA76.73.H37 H88 2016},
  abstract = {"Haskell is a purely functional language that allows programmers to rapidly develop clear, concise, and correct software. The language has grown in popularity in recent years, both in teaching and in industry. This book is based on the author's experience of teaching Haskell for more than twenty years. All concepts are explained from first principles and no programming experience is required, making this book accessible to a broad spectrum of readers. While Part I focuses on basic concepts, Part II introduces the reader to more advanced topics. This new edition has been extensively updated and expanded to include recent and more advanced features of Haskell, new examples and exercises, selected solutions, and freely downloadable lecture slides and example code. The presentation is clean and simple, while also being fully compliant with the latest version of the language, including recent changes concerning applicative, monadic, foldable, and traversable types"--},
  publisher = {{Cambridge University Press}},
  author = {Hutton, Graham},
  year = {2016},
  keywords = {Haskell (Computer program language)}
}

@article{mohriSemiringFrameworksAlgorithms2002,
  title = {Semiring {{Frameworks}} and {{Algorithms}} for {{Shortest}}-Distance {{Problems}}},
  volume = {7},
  issn = {1430-189X},
  abstract = {We define general algebraic frameworks for shortest-distance problems based on the structure of semirings. We give a generic algorithm for finding single-source shortest distances in a weighted directed graph when the weights satisfy the conditions of our general semiring framework. The same algorithm can be used to solve efficiently classical shortest paths problems or to find the k-shortest distances in a directed graph. It can be used to solve single-source shortest-distance problems in weighted directed acyclic graphs over any semiring. We examine several semirings and describe some specific instances of our generic algorithms to illustrate their use and compare them with existing methods and algorithms. The proof of the soundness of all algorithms is given in detail, including their pseudocode and a full analysis of their running time complexity.},
  language = {en},
  number = {3},
  journal = {J. Autom. Lang. Comb.},
  author = {Mohri, Mehryar},
  month = jan,
  year = {2002},
  keywords = {finite automata,rational power series,semirings,shortest-paths algorithms},
  pages = {321--350},
  file = {/Users/doisinkidney/Zotero/storage/PHS7HCML/Mohri - Semiring Frameworks and Algorithms for Shortest-Di.pdf;/Users/doisinkidney/Zotero/storage/X2QAWB8Y/Mohri - Semiring Frameworks and Algorithms for Shortest-Di.pdf;/Users/doisinkidney/Zotero/storage/ZE652TTT/Mohri - Semiring Frameworks and Algorithms for Shortest-Di.pdf;/Users/doisinkidney/Zotero/storage/JB9RZRCP/summary.html},
  ids = {mohriSemiringFrameworksAlgorithms}
}

@book{hottbook,
  address = {{Institute for Advanced Study}},
  title = {Homotopy Type Theory: Univalent Foundations of Mathematics},
  publisher = {{https://homotopytypetheory.org/book}},
  author = {Univalent Foundations Program, The},
  year = {2013}
}

@article{angiuliHomotopicalPatchTheory2016,
  title = {Homotopical Patch Theory*},
  volume = {26},
  issn = {0956-7968, 1469-7653},
  abstract = {Homotopy type theory is an extension of Martin-L{\"o}f type theory, based on a correspondence with homotopy theory and higher category theory. In homotopy type theory, the propositional equality type is proof-relevant, and corresponds to paths in a space. This allows for a new class of datatypes, called higher inductive types, which are specified by constructors not only for points but also for paths. In this paper, we consider a programming application of higher inductive types. Version control systems such as Darcs are based on the notion of patches\textemdash{}syntactic representations of edits to a repository. We show how patch theory can be developed in homotopy type theory. Our formulation separates formal theories of patches from their interpretation as edits to repositories. A patch theory is presented as a higher inductive type. Models of a patch theory are given by maps out of that type, which, being functors, automatically preserve the structure of patches. Several standard tools of homotopy theory come into play, demonstrating the use of these methods in a practical programming context.},
  language = {en},
  journal = {Journal of Functional Programming},
  doi = {10.1017/S0956796816000198},
  author = {Angiuli, Carlo and Morehouse, Edward and Licata, Daniel R. and Harper, Robert},
  year = {2016/ed},
  file = {/Users/doisinkidney/Zotero/storage/Z23CU892/paper.pdf;/Users/doisinkidney/Zotero/storage/2SVVESIL/42AD8BB8A91688BCAC16FD4D6A2C3FE7.html}
}

@inproceedings{coquandHigherInductiveTypes2018,
  address = {{New York, NY, USA}},
  series = {{{LICS}} '18},
  title = {On {{Higher Inductive Types}} in {{Cubical Type Theory}}},
  isbn = {978-1-4503-5583-4},
  abstract = {Cubical type theory provides a constructive justification to certain aspects of homotopy type theory such as Voevodsky's univalence axiom. This makes many extensionality principles, like function and propositional extensionality, directly provable in the theory. This paper describes a constructive semantics, expressed in a presheaf topos with suitable structure inspired by cubical sets, of some higher inductive types. It also extends cubical type theory by a syntax for the higher inductive types of spheres, torus, suspensions, truncations, and pushouts. All of these types are justified by the semantics and have judgmental computation rules for all constructors, including the higher dimensional ones, and the universes are closed under these type formers.},
  booktitle = {Proceedings of the 33rd {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  publisher = {{ACM}},
  doi = {10.1145/3209108.3209197},
  author = {Coquand, Thierry and Huber, Simon and M{\"o}rtberg, Anders},
  year = {2018},
  keywords = {Cubical Type Theory,Higher Inductive Types,Homotopy Type Theory,Univalent Foundations},
  pages = {255--264},
  file = {/Users/doisinkidney/Zotero/storage/EJSLA6MN/Coquand et al. - 2018 - On Higher Inductive Types in Cubical Type Theory.pdf}
}

@inproceedings{chuHoTTSQLProvingQuery2017,
  address = {{New York, NY, USA}},
  series = {{{PLDI}} 2017},
  title = {{{HoTTSQL}}: {{Proving Query Rewrites}} with {{Univalent SQL Semantics}}},
  isbn = {978-1-4503-4988-8},
  shorttitle = {{{HoTTSQL}}},
  abstract = {Every database system contains a query optimizer that performs query rewrites. Unfortunately, developing query optimizers remains a highly challenging task. Part of the challenges comes from the intricacies and rich features of query languages, which makes reasoning about rewrite rules difficult. In this paper, we propose a machine-checkable denotational semantics for SQL, the de facto language for relational database, for rigorously validating rewrite rules. Unlike previously proposed semantics that are either non-mechanized or only cover a small amount of SQL language features, our semantics covers all major features of SQL, including bags, correlated subqueries, aggregation, and indexes. Our mechanized semantics, called HoTT SQL, is based on K-Relations and homotopy type theory, where we denote relations as mathematical functions from tuples to univalent types. We have implemented HoTTSQL in Coq, which takes only fewer than 300 lines of code and have proved a wide range of SQL rewrite rules, including those from database research literature (e.g., magic set rewrites) and real-world query optimizers (e.g., subquery elimination). Several of these rewrite rules have never been previously proven correct. In addition, while query equivalence is generally undecidable, we have implemented an automated decision procedure using HoTTSQL for conjunctive queries: a well studied decidable fragment of SQL that encompasses many real-world queries.},
  booktitle = {Proceedings of the 38th {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}}},
  publisher = {{ACM}},
  doi = {10.1145/3062341.3062348},
  author = {Chu, Shumo and Weitz, Konstantin and Cheung, Alvin and Suciu, Dan},
  year = {2017},
  keywords = {Equivalence,Formal Semantics,Homotopy Types,SQL},
  pages = {510--524},
  file = {/Users/doisinkidney/Zotero/storage/YN69LHCW/Chu et al. - 2017 - HoTTSQL Proving Query Rewrites with Univalent SQL.pdf}
}

@phdthesis{iversenUnivalentCategoriesFormalization2018,
  address = {{G{\"o}teborg, Sweden}},
  type = {Master's {{Thesis}}},
  title = {Univalent {{Categories}}: {{A}} Formalization of Category Theory in {{Cubical Agda}}},
  shorttitle = {Univalent {{Categories}}},
  abstract = {The usual notion of propositional equality in intensional type-theory is restrictive. For instance it does not admit functional extensionality nor univalence. This poses a severe limitation on both what is provable and the re-usability of proofs. Recent developments have, however, resulted in cubical type theory, which permits a constructive proof of univalence. The programming language Agda has been extended with capabilities for working in such a cubical setting. This thesis will explore the usefulness of this extension in the context of category theory. The thesis will motivate the need for univalence and explain why propositional equality in cubical Agda is more expressive than in standard Agda. Alternative approaches to Cubical Agda will be presented and their pros and cons will be explained. As an example of the application of univalence, two formulations of monads will be presented: Namely monads in the monoidal form and monads in the Kleisli form. Using univalence, it will be shown how these are equal. Finally the thesis will explain the challenges that a developer will face when working with cubical Agda and give some techniques to overcome these difficulties. It will suggest how further work can help alleviate some of these challenges.},
  language = {eng},
  school = {Chalmers University of Technology},
  author = {Iversen, Frederik Hangh{\o}j},
  year = {2018},
  file = {/Users/doisinkidney/Zotero/storage/HAWR9Q66/Iversen - Univalent Categories.pdf;/Users/doisinkidney/Zotero/storage/I7P33FKV/Iversen - 2018 - Univalent Categories A formalization of category t.pdf;/Users/doisinkidney/Zotero/storage/8W5H2IG2/256404.html}
}

@incollection{jacobsConvexityDualityEffects2010,
  address = {{Berlin, Heidelberg}},
  title = {Convexity, {{Duality}} and {{Effects}}},
  volume = {323},
  isbn = {978-3-642-15239-9 978-3-642-15240-5},
  abstract = {This paper describes some basic relationships between mathematical structures that are relevant in quantum logic and probability, namely convex sets, effect algebras, and a new class of functors that we call `convex functors'; they include what are usually called probability distribution functors. These relationships take the form of three adjunctions. Two of these three are `dual' adjunctions for convex sets, one time with the Boolean truth values \{0, 1\} as dualising object, and one time with the probablity values [0, 1]. The third adjunction is between effect algebras and convex functors.},
  language = {en},
  booktitle = {Theoretical {{Computer Science}}},
  publisher = {{Springer Berlin Heidelberg}},
  doi = {10.1007/978-3-642-15240-5_1},
  author = {Jacobs, Bart},
  editor = {Calude, Cristian S. and Sassone, Vladimiro},
  year = {2010},
  pages = {1-19},
  file = {/Users/doisinkidney/Zotero/storage/3QR2BTA5/Jacobs - 2010 - Convexity, Duality and Effects.pdf}
}

@article{tarizadehFreshLookMonoid2017,
  archivePrefix = {arXiv},
  eprint = {1709.01426},
  primaryClass = {math},
  title = {A Fresh Look into Monoid Rings and Formal Power Series Rings},
  abstract = {In this article, the ring of polynomials is studied in a systematic way through the theory of monoid rings. As a consequence, this study provides natural and canonical approaches in order to find easy and rigorous proofs and methods for many facts on polynomials and formal power series; some of them as sample are treated in this note. Besides the universal properties of the monoid rings and polynomial rings, a universal property for the formal power series rings is also established.},
  language = {en},
  journal = {arXiv:1709.01426 [math]},
  author = {Tarizadeh, Abolfazl},
  month = sep,
  year = {2017},
  keywords = {13F20; 13M10; 12E05; 13F25; 13J05; 30C10; 37F10; 37P05 etc,Mathematics - Commutative Algebra},
  file = {/Users/doisinkidney/Zotero/storage/MAMSMLCV/Tarizadeh - 2017 - A fresh look into monoid rings and formal power se.pdf}
}

@book{golanPowerAlgebrasSemirings2013,
  title = {Power {{Algebras}} over {{Semirings}}: {{With Applications}} in {{Mathematics}} and {{Computer Science}}},
  isbn = {978-94-015-9241-3},
  shorttitle = {Power {{Algebras}} over {{Semirings}}},
  abstract = {This monograph is a continuation of several themes presented in my previous books [146, 149]. In those volumes, I was concerned primarily with the properties of semirings. Here, the objects of investigation are sets of the form RA, where R is a semiring and A is a set having a certain structure. The problem is one of translating that structure to RA in some "natural" way. As such, it tries to find a unified way of dealing with diverse topics in mathematics and theoretical com puter science as formal language theory, the theory of fuzzy algebraic structures, models of optimal control, and many others. Another special case is the creation of "idempotent analysis" and similar work in optimization theory. Unlike the case of the previous work, which rested on a fairly established mathematical foundation, the approach here is much more tentative and docimastic. This is an introduction to, not a definitative presentation of, an area of mathematics still very much in the making. The basic philosphical problem lurking in the background is one stated suc cinctly by Hahle and Sostak [185]: ". . . to what extent basic fields of mathematics like algebra and topology are dependent on the underlying set theory?" The conflicting definitions proposed by various researchers in search of a resolution to this conundrum show just how difficult this problem is to see in a proper light.},
  language = {en},
  publisher = {{Springer Science \& Business Media}},
  author = {Golan, Jonathan S.},
  month = apr,
  year = {2013},
  keywords = {Computers / Data Processing,Mathematics / Algebra / Abstract,Mathematics / Algebra / General,Mathematics / Discrete Mathematics,Mathematics / History \& Philosophy,Mathematics / Logic},
  file = {/Users/doisinkidney/Zotero/storage/I8Q6QXLN/Golan - 2013 - Power Algebras over Semirings With Applications i.pdf},
  googlebooks = {lETwCAAAQBAJ}
}

@article{wehrungInjectivePositivelyOrdered1992,
  title = {Injective Positively Ordered Monoids {{I}}},
  volume = {83},
  issn = {0022-4049},
  abstract = {We define a certain notion of completeness for a wide class of commutative (pre)ordered monoids (from now on P.O.M.'s). This class seems to be the natural context for studying structures like measurable functions spaces, equidecomposability types of spaces, partially ordered abelian groups and cardinal algebras. Then, we can prove that roughly speaking, spaces of measures with values in complete P.O.M.'s are complete P.O.M.'s. Furthermore, this notion of completeness yields us an `arithmetical' characterization of injective P.O.M.'s.},
  number = {1},
  journal = {Journal of Pure and Applied Algebra},
  doi = {10.1016/0022-4049(92)90104-N},
  author = {Wehrung, Friedrich},
  month = nov,
  year = {1992},
  pages = {43-82},
  file = {/Users/doisinkidney/Zotero/storage/MEI8SBZD/Wehrung - 1992 - Injective positively ordered monoids I.pdf;/Users/doisinkidney/Zotero/storage/G78RPDNN/002240499290104N.html}
}

@article{daviaudVarietiesCostFunctions,
  title = {Varieties of {{Cost Functions}}},
  abstract = {Regular cost functions were introduced as a quantitative generalisation of regular languages, retaining many of their equivalent characterisations and decidability properties. For instance, stabilisation monoids play the same role for cost functions as monoids do for regular languages. The purpose of this article is to further extend this algebraic approach by generalising two results on regular languages to cost functions: Eilenberg's varieties theorem and profinite equational characterisations of lattices of regular languages. This opens interesting new perspectives, but the specificities of cost functions introduce difficulties that prevent these generalisations to be straightforward. In contrast, although syntactic algebras can be defined for formal power series over a commutative ring, no such notion is known for series over semirings and in particular over the tropical semiring.},
  language = {en},
  author = {Daviaud, Laure and Kuperberg, Denis and Pin, Jean-Eric},
  pages = {15},
  file = {/Users/doisinkidney/Zotero/storage/82Q9WR6T/Daviaud et al. - Varieties of Cost Functions.pdf}
}

@book{berstelNoncommutativeRationalSeries2011,
  title = {Noncommutative {{Rational Series}} with {{Applications}}},
  isbn = {978-0-521-19022-0},
  abstract = {The algebraic theory of automata was created by Sch{\"u}tzenberger and Chomsky over 50 years ago and there has since been a great deal of development. Classical work on the theory to noncommutative power series has been augmented more recently to areas such as representation theory, combinatorial mathematics and theoretical computer science. This book presents to an audience of graduate students and researchers a modern account of the subject and its applications. The algebraic approach allows the theory to be developed in a general form of wide applicability. For example, number-theoretic results can now be more fully explored, in addition to applications in automata theory, codes and non-commutative algebra. Much material, for example, Sch{\"u}tzenberger's theorem on polynomially bounded rational series, appears here for the first time in book form. This is an excellent resource and reference for all those working in algebra, theoretical computer science and their areas of overlap.},
  language = {en},
  publisher = {{Cambridge University Press}},
  author = {Berstel, Jean and Reutenauer, Christophe},
  year = {2011},
  keywords = {Mathematics / Algebra / General},
  file = {/Users/doisinkidney/Zotero/storage/6S5B8QJH/Berstel and Reutenauer - 2011 - Noncommutative Rational Series with Applications.pdf},
  googlebooks = {LL8Nhn72I\_8C}
}

@book{drosteHandbookWeightedAutomata2009,
  edition = {1st},
  title = {Handbook of {{Weighted Automata}}},
  isbn = {978-3-642-01491-8},
  abstract = {Weighted finite automata are classical nondeterministic finite automata in which the transitions carry weights. These weights may model, for example, the cost involved when executing a transition, the resources or time needed for this, or the probability or reliability of its successful execution. Weights can also be added to classical automata with infinite state sets like pushdown automata, and this extension constitutes the general concept of weighted automata. Since their introduction in the 1960s they have stimulated research in related areas of theoretical computer science, including formal language theory, algebra, logic, and discrete structures. Moreover, weighted automata and weighted context-free grammars have found application in natural-language processing, speech recognition, and digital image compression. This book covers all the main aspects of weighted automata and formal power series methods, ranging from theory to applications. The contributors are the leading experts in their respective areas, and each chapter presents a detailed survey of the state of the art and pointers to future research. The chapters in Part I cover the foundations of the theory of weighted automata, specifically addressing semirings, power series, and fixed point theory. Part II investigates different concepts of weighted recognizability. Part III examines alternative types of weighted automata and various discrete structures other than words. Finally, Part IV deals with applications of weighted automata, including digital image compression, fuzzy languages, model checking, and natural-language processing. Computer scientists and mathematicians will find this book an excellent survey and reference volume, and it will also be a valuable resource for students exploring this exciting research area.},
  publisher = {{Springer Publishing Company, Incorporated}},
  author = {Droste, Manfred and Kuich, Werner and Vogler, Heiko},
  year = {2009},
  file = {/Users/doisinkidney/Zotero/storage/46S6EW2I/Droste et al. - 2009 - Handbook of Weighted Automata.pdf}
}

@article{julesAlgebraicNotionsTermination2011,
  title = {Algebraic {{Notions}} of {{Termination}}},
  volume = {7},
  issn = {18605974},
  abstract = {Five algebraic notions of termination are formalised, analysed and compared: wellfoundedness or Noetherity, L\textasciidieresis{}ob's formula, absence of infinite iteration, absence of divergence and normalisation. The study is based on modal semirings, which are additively idempotent semirings with forward and backward modal operators. To model infinite behaviours, idempotent semirings are extended to divergence semirings, divergence Kleene algebras and omega algebras. The resulting notions and techniques are used in calculational proofs of classical theorems of rewriting theory. These applications show that modal semirings are powerful tools for reasoning algebraically about the finite and infinite dynamics of programs and transition systems.},
  language = {en},
  number = {1},
  journal = {Logical Methods in Computer Science},
  doi = {10.2168/LMCS-7(1:1)2011},
  author = {Jules, Desharnais and Moeller, Bernhard and Georg, Struth},
  editor = {Kozen, Dexter},
  month = feb,
  year = {2011},
  pages = {1},
  file = {/Users/doisinkidney/Zotero/storage/6MRTJLFJ/Jules et al. - 2011 - Algebraic Notions of Termination.pdf}
}

@inproceedings{ruttenRegularExpressionsRevisited2000,
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Regular {{Expressions Revisited}}: {{A Coinductive Approach}} to {{Streams}}, {{Automata}}, and {{Power Series}}},
  isbn = {978-3-540-45025-2},
  shorttitle = {Regular {{Expressions Revisited}}},
  abstract = {Regular expressions are a standard means for denoting formal languages that are recognizable by finite automata. Much less familiar is the use of syntactic expressions for (formal) power series. Power series generalize languages by assigning to words multiplicities in any semiring (such as the reals) rather than just Booleans, and include as a special case the set of streams (infinite sequences). Here we shall define an extended set of regular expressions with multiplicities in an arbitrary semiring. The semantics of such expressions will be defined coinductively, allowing for the use of a syntactic coinductive proof principle. To each expression will be assigned a nondeterministic automaton with multiplicities, which usually is a rather efficient representation of the power series denoted by the expression. Much of the above will be illustrated for the special case of streams of real numbers; other examples include automata and languages (sets of words), and task-resource systems (using the max-plus semiring). The coinductive definitions mentioned above take the shape of what we have called behavioural differential equations, on the basis of which we develop, as a motivating example, a theory of streams in a calculus-like fashion.},
  language = {en},
  booktitle = {Mathematics of {{Program Construction}}},
  publisher = {{Springer Berlin Heidelberg}},
  author = {Rutten, J. J. M. M.},
  editor = {Backhouse, Roland and Oliveira, Jos{\'e} Nuno},
  year = {2000},
  pages = {100-101},
  file = {/Users/doisinkidney/Zotero/storage/IJ2EJGYF/Rutten - 2000 - Regular Expressions Revisited A Coinductive Appro.pdf}
}

@inproceedings{tranCompositionalDeepLearning2019,
  address = {{Berlin, Germany}},
  title = {Compositional Deep Learning in {{Futhark}}},
  isbn = {978-1-4503-6814-8},
  abstract = {We present a design pattern for composing deep learning networks in a typed, higher-order fashion. The exposed library functions are generically typed and the composition structure allows for networks to be trained (using backpropagation) and for trained networks to be used for predicting new results (using forward-propagation). Individual layers in a network can take different forms ranging over dense sigmoid layers to convolutional layers. The paper discusses different typing techniques aimed at enforcing proper use and composition of networks. The approach is implemented in Futhark, a data-parallel functional language and compiler targeting GPU architectures, and we demonstrate that Futhark's elimination of higher-order functions and modules leads to efficient generated code.},
  language = {en},
  booktitle = {Proceedings of the 8th {{ACM SIGPLAN International Workshop}} on {{Functional High}}-{{Performance}} and {{Numerical Computing}}  - {{FHPNC}} 2019},
  publisher = {{ACM Press}},
  doi = {10.1145/3331553.3342617},
  author = {Tran, Duc Minh and Henriksen, Troels and Elsman, Martin},
  year = {2019},
  pages = {47-59},
  file = {/Users/doisinkidney/Zotero/storage/B8JBCQ8R/Tran et al. - 2019 - Compositional deep learning in Futhark.pdf}
}

@techreport{UniverseLevelsAgda,
  title = {Universe {{Levels}} \textemdash{} {{Agda}} 2.6.1 Documentation},
  file = {/Users/doisinkidney/Zotero/storage/22QRSK6N/universe-levels.html}
}

@techreport{CubicalAgdaDocumentation2019,
  title = {Cubical \textemdash{} {{Agda}} 2.6.0.1 Documentation},
  year = {2019},
  file = {/Users/doisinkidney/Zotero/storage/7GY47SHC/cubical.html}
}

@article{brownInterleaveTAbstractionAlternative2011,
  title = {The {{InterleaveT Abstraction}}: {{Alternative}} with {{Flexible Ordering}}},
  volume = {17},
  abstract = {The Alternative type class in Haskell supports the notion of choice between items such as parser actions or channel communications. If, instead of making a one- o{$\carriagereturn$} choice between items, you need to choose several in an unknown order (e.g. parsing di{$\carriagereturn$}erent sections in a file which can be in arbitrary order), the resulting code spelling out all the orderings can become quite intricate. This article explains InterleaveT, a simple combinator abstraction on top of Alternative and Monad which captures the flexibly-ordered interleaving of several streams of behaviour at a high level, without resorting to writing in a state machine-like style.},
  language = {en},
  number = {17},
  journal = {The Monad.Reader},
  author = {Brown, Neil},
  month = jan,
  year = {2011},
  pages = {21},
  file = {/Users/doisinkidney/Zotero/storage/Y6A3P5LV/Brown - The InterleaveT Abstraction Alternative with Flex.pdf}
}

@article{licata2DimensionalDirectedType2011,
  title = {2-{{Dimensional Directed Type Theory}}},
  volume = {276},
  issn = {15710661},
  language = {en},
  journal = {Electronic Notes in Theoretical Computer Science},
  doi = {10.1016/j.entcs.2011.09.026},
  author = {Licata, Daniel R. and Harper, Robert},
  month = sep,
  year = {2011},
  pages = {263-289},
  file = {/Users/doisinkidney/Zotero/storage/5KS3SS5A/Licata and Harper - 2011 - 2-Dimensional Directed Type Theory.pdf}
}

@inproceedings{firsovDependentlyTypedProgramming2015,
  address = {{Vancouver, BC, Canada}},
  title = {Dependently Typed Programming with Finite Sets},
  isbn = {978-1-4503-3810-3},
  abstract = {Definitions of many mathematical structures used in computer science are parametrized by finite sets. To work with such structures in proof assistants, we need to be able to explain what a finite set is. In constructive mathematics, a widely used definition is listability: a set is considered to be finite, if its elements can be listed completely. In this paper, we formalize different variations of this definition in the Agda programming language. We develop a toolbox for boilerplate-free programming with finite sets that arise as subsets of some base set with decidable equality. Among other things we implement combinators for defining functions from finite sets and a prover for quantified formulas over decidable properties on finite sets.},
  language = {en},
  booktitle = {Proceedings of the 11th {{ACM SIGPLAN Workshop}} on {{Generic Programming}} - {{WGP}} 2015},
  publisher = {{ACM Press}},
  doi = {10.1145/2808098.2808102},
  author = {Firsov, Denis and Uustalu, Tarmo},
  year = {2015},
  pages = {33-44},
  file = {/Users/doisinkidney/Zotero/storage/4MGFKKTP/Firsov and Uustalu - 2015 - Dependently typed programming with finite sets.pdf}
}

@article{spiwackConstructivelyFinite2010,
  title = {Constructively {{Finite}}?},
  abstract = {This articles plays with several properties of Bishop sets which would be equivalent in ZFC to being finite. One of which is new. This is an occasion to analyse finely the different properties of finite sets and how they (constructively) relate to one another. We close this article by presenting a few well-known algorithms on finite structures, and describe which kind of finiteness they require.},
  language = {en},
  author = {Spiwack, Arnaud and Coquand, Thierry},
  year = {2010},
  file = {/Users/doisinkidney/Zotero/storage/4A49ZUBX/Spiwack and Coquand - 2010 - Constructively Finite.pdf;/Users/doisinkidney/Zotero/storage/YY82SENZ/inria-00503917.html}
}

@inproceedings{parmannInvestigatingStreamlessSets2015,
  address = {{Dagstuhl, Germany}},
  series = {Leibniz {{International Proceedings}} in {{Informatics}} ({{LIPIcs}})},
  title = {Investigating {{Streamless Sets}}},
  volume = {39},
  isbn = {978-3-939897-88-0},
  booktitle = {20th {{International Conference}} on {{Types}} for {{Proofs}} and {{Programs}} ({{TYPES}} 2014)},
  publisher = {{Schloss Dagstuhl\textendash{}Leibniz-Zentrum fuer Informatik}},
  doi = {10.4230/LIPIcs.TYPES.2014.187},
  author = {Parmann, Erik},
  editor = {Herbelin, Hugo and Letouzey, Pierre and Sozeau, Matthieu},
  year = {2015},
  keywords = {Constructive Logic,Finite Sets,Type theory},
  pages = {187--201},
  file = {/Users/doisinkidney/Zotero/storage/9I9NE9JP/Parmann - 2015 - Investigating Streamless Sets.pdf;/Users/doisinkidney/Zotero/storage/TYQSY7X3/5497.html}
}

@article{al-hassyLanguageFeatureUnbundle2019,
  title = {A {{Language Feature}} to {{Unbundle Data}} at {{Will}}},
  abstract = {Programming languages with sufficiently expressive type systems provide users with different means of data `bundling'. Specifically, in dependently-typed languages such as Agda, Coq, Lean and Idris, one can choose to encode information in a record either as a parameter or a field. For example, we can speak of graphs over a particular vertex set, or speak of arbitrary graphs where the vertex set is a component. These create isomorphic types, but differ with respect to intended use. Traditionally, a library designer would make this choice (between parameters and fields); if a user wants a different variant, they are forced to build conversion utilities, as well as duplicate functionality. For a graph data type, if a library only provides a Haskell-like typeclass view of graphs over a vertex set, yet a user wishes to work with the category of graphs, they must now package a vertex set as a component in a record along with a graph over that set.},
  language = {en},
  author = {{Al-hassy}, Musa and Carette, Jacques and Kahl, Wolfram},
  year = {2019},
  pages = {6},
  file = {/Users/doisinkidney/Zotero/storage/4WVZX78U/Al-hassy et al. - 2019 - A Language Feature to Unbundle Data at Will(Short .pdf}
}

@article{bezemStreamsThatAre2012,
  archivePrefix = {arXiv},
  eprint = {1210.1200},
  title = {On Streams That Are Finitely Red},
  volume = {8},
  issn = {18605974},
  abstract = {Mixing induction and coinduction, we study alternative definitions of streams being finitely red. We organize our definitions into a hierarchy including also some well-known alternatives in intuitionistic analysis. The hierarchy collapses classically, but is intuitionistically of strictly decreasing strength. We characterize the differences in strength in a precise way by weak instances of the Law of Excluded Middle.},
  number = {4},
  journal = {Logical Methods in Computer Science},
  doi = {10.2168/LMCS-8(4:4)2012},
  author = {Bezem, Marc and Nakata, Keiko and Uustalu, Tarmo},
  month = oct,
  year = {2012},
  keywords = {Computer Science - Logic in Computer Science,F.4.1},
  pages = {4},
  file = {/Users/doisinkidney/Zotero/storage/2BIKLWMP/Bezem et al. - 2012 - On streams that are finitely red.pdf;/Users/doisinkidney/Zotero/storage/FMAICEAV/1210.html}
}

@article{rijkeSetsHomotopyType2015,
  title = {Sets in Homotopy Type Theory},
  volume = {25},
  issn = {0960-1295, 1469-8072},
  abstract = {Homotopy Type Theory may be seen as an internal language for the {$\infty$}-category of weak {$\infty$}-groupoids. Moreover, weak {$\infty$}-groupoids model the univalence axiom. Voevodsky proposes this (language for) weak {$\infty$}groupoids as a new foundation for mathematics called the univalent foundations. It includes the sets as weak {$\infty$}-groupoids with contractible connected components, and thereby it includes (much of) the traditional set theoretical foundations as a special case. We thus wonder whether those `discrete' groupoids do in fact form a (predicative) topos. More generally, homotopy type theory is conjectured to be the internal language of `elementary' of {$\infty$}-toposes. We prove that sets in homotopy type theory form a {$\Pi$}W-pretopos. This is similar to the fact that the 0-truncation of an {$\infty$}topos is a topos. We show that both a subobject classifier and a 0-object classifier are available for the type theoretical universe of sets. However, both of these are large and moreover the 0-object classifier for sets is a function between 1-types (i.e. groupoids) rather than between sets. Assuming an impredicative propositional resizing rule we may render the subobject classifier small and then we actually obtain a topos of sets.},
  language = {en},
  number = {5},
  journal = {Mathematical Structures in Computer Science},
  doi = {10.1017/S0960129514000553},
  author = {Rijke, Egbert and Spitters, Bas},
  month = jun,
  year = {2015},
  pages = {1172-1202},
  file = {/Users/doisinkidney/Zotero/storage/F4X85CSL/Rijke and Spitters - 2015 - Sets in homotopy type theory.pdf;/Users/doisinkidney/Zotero/storage/HBVEAFDW/Rijke and Spitters - 2015 - Sets in homotopy type theory †.pdf;/Users/doisinkidney/Zotero/storage/7K52IRMW/12923C0993730DE101029B542D66F736.html},
  ids = {rijkeSetsHomotopyType2015a}
}

@inproceedings{pickeringMultistageProgramsContext2019,
  address = {{New York, NY, USA}},
  series = {Haskell 2019},
  title = {Multi-Stage {{Programs}} in {{Context}}},
  isbn = {978-1-4503-6813-1},
  abstract = {Cross-stage persistence is an essential aspect of multi-stage programming that allows a value defined in one stage to be available in another. However, difficulty arises when implicit information held in types, type classes and implicit parameters needs to be persisted. Without a careful treatment of such implicit information---which are pervasive in Haskell---subtle yet avoidable bugs lurk beneath the surface.   This paper demonstrates that in multi-stage programming care must be taken when representing quoted terms so that important implicit information is kept in context and not discarded. The approach is formalised with a type-system, and an implementation in GHC is presented that fixes problems of the previous incarnation.},
  booktitle = {Proceedings of the 12th {{ACM SIGPLAN International Symposium}} on {{Haskell}}},
  publisher = {{ACM}},
  doi = {10.1145/3331545.3342597},
  author = {Pickering, Matthew and Wu, Nicolas and Kiss, Csongor},
  year = {2019},
  keywords = {implicits,metaprogramming,staging},
  pages = {71--84},
  file = {/Users/doisinkidney/Zotero/storage/TY7LWAQZ/Pickering et al. - 2019 - Multi-stage Programs in Context.pdf},
  ids = {pickeringMultistageProgramsContext2019a}
}

@article{solovevCategoryFiniteSets1983,
  title = {The Category of Finite Sets and {{Cartesian}} Closed Categories},
  volume = {22},
  issn = {1573-8795},
  abstract = {Applying methods of the proof theory, it is shown that two canonical morphisms are equal in all Cartesian closed categories if and only if some of their realizations in the category of finite sets are equal. All realizations of formal combinations of objects using the functors x and hom are isomorphic in all Cartesian closed categories if and only if some of their realizations in the category of finite sets are isomorphic. On the base of these results, a purely syntactic decision algorithm for (extensional) isomorphism of formal combinations of objects and a new decision algorithm for equality of canonical morphisms are obtained.},
  language = {en},
  number = {3},
  journal = {Journal of Soviet Mathematics},
  doi = {10.1007/BF01084396},
  author = {Solov'ev, S. V.},
  month = jun,
  year = {1983},
  keywords = {Canonical Morphism,Closed Category,Decision Algorithm,Formal Combination,Proof Theory},
  pages = {1387-1400},
  file = {/Users/doisinkidney/Zotero/storage/N88ADXYU/Solov'ev - 1983 - The category of finite sets and Cartesian closed c.pdf}
}

@inproceedings{fioreRemarksIsomorphismsTyped2002,
  title = {Remarks on Isomorphisms in Typed Lambda Calculi with Empty and Sum Types},
  abstract = {Tarski asked whether the arithmetic identities taught in high school are complete for showing all arithmetic equations valid for the natural numbers. The answer to this question for the language of arithmetic expressions using a constant for the number one and the operations of product and exponentiation is affirmative, and the complete equational theory also characterises isomorphism in the typed lambda calculus, where the constant for one and the operations of product and exponentiation respectively correspond to the unit type and the product and arrow type constructors. This paper studies isomorphisms in typed lambda calculi with empty and sum types from this viewpoint. We close an open problem by establishing that the theory of type isomorphisms in the presence of product, arrow, and sum types (with or without the unit type) is not finitely axiomatisable. Further, we observe that for type theories with arrow, empty and sum types the correspondence between isomorphism and arithmetic equality generally breaks down, but that it still holds in some particular cases including that of type isomorphism with the empty type and equality with zero.},
  booktitle = {Proceedings 17th {{Annual IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  doi = {10.1109/LICS.2002.1029824},
  author = {Fiore, M. and Di Cosmo, R. and Balat, V.},
  month = jul,
  year = {2002},
  keywords = {Algebra,Functional programming,Libraries,Laboratories,Educational institutions,Logic programming,type theory,arithmetic equations,arithmetic identities,Calculus,complete equational theory,Computer languages,Digital arithmetic,empty types,Equations,isomorphisms,lambda calculus,sum types,typed lambda calculi,typed lambda calculus},
  pages = {147-156},
  file = {/Users/doisinkidney/Zotero/storage/YJYFDZD2/Fiore et al. - 2002 - Remarks on isomorphisms in typed lambda calculi wi.pdf;/Users/doisinkidney/Zotero/storage/QPMXDITK/1029824.html;/Users/doisinkidney/Zotero/storage/YXBTVRAP/1029824.html},
  ids = {fioreRemarksIsomorphismsTyped2002a},
  issn = {1043-6871}
}

@incollection{hermidaAlgebraicViewStructural1995,
  address = {{Berlin, Heidelberg}},
  title = {An Algebraic View of Structural Induction},
  volume = {933},
  isbn = {978-3-540-60017-6 978-3-540-49404-1},
  language = {en},
  booktitle = {Computer {{Science Logic}}},
  publisher = {{Springer Berlin Heidelberg}},
  doi = {10.1007/BFb0022272},
  author = {Hermida, Claudio and Jacobs, Bart},
  editor = {Goos, Gerhard and Hartmanis, Juris and {van Leeuwen}, Jan and Pacholski, Leszek and Tiuryn, Jerzy},
  year = {1995},
  pages = {412-426},
  file = {/Users/doisinkidney/Zotero/storage/22TZZZ9F/Hermida and Jacobs - 1995 - An algebraic view of structural induction.pdf}
}

@article{rtbergCUBICALMETHODSHOTT,
  title = {{{CUBICAL METHODS IN HOTT}}/{{UF}}},
  abstract = {These are notes for a course given at the 2019 Homotopy Type Theory Summer School at Carnegie Mellon University in Pittsburgh, USA. The course covers the basics of cubical type theory and its semantics in cubical sets. These new type theories provide computational justifications to homotopy type theory and univalent foundations, in particular, Voevodsky's univalence axiom is provable and hence has computational content. This can therefore be seen as a constructive foundation for homotopy type theory and univalent foundations, suitable for computer implementation.},
  language = {en},
  author = {Rtberg, Anders Mo},
  pages = {11},
  file = {/Users/doisinkidney/Zotero/storage/H2EWP9TS/Rtberg - CUBICAL METHODS IN HOTTUF.pdf}
}

@inproceedings{allaisGenericLevelPolymorphic2019,
  address = {{Berlin, Germany}},
  title = {Generic Level Polymorphic N-Ary Functions},
  isbn = {978-1-4503-6815-5},
  abstract = {Agda's standard library struggles in various places with nary functions and relations. It introduces congruence and substitution operators for functions of arities one and two, and provides users with convenient combinators for manipulating indexed families of arity exactly one.},
  language = {en},
  booktitle = {Proceedings of the 4th {{ACM SIGPLAN International Workshop}} on {{Type}}-{{Driven Development}}  - {{TyDe}} 2019},
  publisher = {{ACM Press}},
  doi = {10.1145/3331554.3342604},
  author = {Allais, Guillaume},
  year = {2019},
  pages = {14-26},
  file = {/Users/doisinkidney/Zotero/storage/37UB3Z5C/Allais - 2019 - Generic level polymorphic n-ary functions.pdf}
}

@article{abbottContainersConstructingStrictly2005,
  series = {Applied {{Semantics}}: {{Selected Topics}}},
  title = {Containers: {{Constructing}} Strictly Positive Types},
  volume = {342},
  issn = {0304-3975},
  shorttitle = {Containers},
  abstract = {We introduce the notion of a Martin-L{\"o}f category\textemdash{}a locally cartesian closed category with disjoint coproducts and initial algebras of container functors (the categorical analogue of W-types)\textemdash{}and then establish that nested strictly positive inductive and coinductive types, which we call strictly positive types, exist in any Martin-L{\"o}f category. Central to our development are the notions of containers and container functors. These provide a new conceptual analysis of data structures and polymorphic functions by exploiting dependent type theory as a convenient way to define constructions in Martin-L{\"o}f categories. We also show that morphisms between containers can be full and faithfully interpreted as polymorphic functions (i.e.natural transformations) and that, in the presence of W-types, all strictly positive types (including nested inductive and coinductive types) give rise to containers.},
  language = {en},
  number = {1},
  journal = {Theoretical Computer Science},
  doi = {10.1016/j.tcs.2005.06.002},
  author = {Abbott, Michael and Altenkirch, Thorsten and Ghani, Neil},
  month = sep,
  year = {2005},
  keywords = {Category theory,Coinduction,Container functors,Final coalgebras,Induction,Initial algebras,Type theory,W-Types},
  pages = {3-27},
  file = {/Users/doisinkidney/Zotero/storage/TJP8YKNL/Abbott et al. - 2005 - Containers Constructing strictly positive types.pdf;/Users/doisinkidney/Zotero/storage/6P7GRA5Q/S0304397505003373.html;/Users/doisinkidney/Zotero/storage/H7GZ8KBM/S0304397505003373.html},
  ids = {abbottContainersConstructingStrictly2005a}
}

@article{GenericEnumeratorsExtended,
  title = {Generic {{Enumerators}} ({{Extended Abstract}})},
  language = {en},
  pages = {3},
  file = {/Users/doisinkidney/Zotero/storage/QHY9CXNP/Generic Enumerators (Extended Abstract).pdf}
}

@article{gustafssonCountingTypeIsomorphisms,
  title = {Counting on {{Type Isomorphisms}}},
  abstract = {Big operators, such as x{$\in$}A f (x), x{$\in$}A f (x) are the iterated versions of the binary operators + and {$\wedge$}. They are common in mathematics and we propose tools to reason about them within a Type Theory such as Agda. Using a polymorphic encoding of binary trees one can lift any binary operator to the corresponding big operator. Thanks to the parametricity of this encoding one can easily lift properties of the binary operator to the corresponding big operator. In particular big operators such as sums and products can be put in correspondence with the cardinality of {$\Sigma$}-types and {$\Pi$}-types which enforces a correct implementation. Moreover these correspondences enable the use of type isomorphisms as a powerful reasoning tool. For instance using a standard isomorphism on {$\Sigma$}-types yields a constructive proof that adequate summation functions are invariant under permutations.},
  language = {en},
  author = {Gustafsson, Daniel and Pouillard, Nicolas},
  pages = {20},
  file = {/Users/doisinkidney/Zotero/storage/FKJ9BZDL/Gustafsson and Pouillard - Counting on Type Isomorphisms.pdf}
}

@inproceedings{yorgeySpeciesFunctorsTypes2010,
  address = {{New York, NY, USA}},
  series = {Haskell '10},
  title = {Species and {{Functors}} and {{Types}}, {{Oh My}}!},
  volume = {45},
  isbn = {978-1-4503-0252-4},
  abstract = {The theory of combinatorial species, although invented as a purely mathematical formalism to unify much of combinatorics, can also serve as a powerful and expressive language for talking about data types. With potential applications to automatic test generation, generic programming, and language design, the theory deserves to be much better known in the functional programming community. This paper aims to teach the basic theory of combinatorial species using motivation and examples from the world of functional programming. It also introduces the species library, available on Hackage, which is used to illustrate the concepts introduced and can serve as a platform for continued study and research.},
  booktitle = {Proceedings of the {{Third ACM Haskell Symposium}} on {{Haskell}}},
  publisher = {{ACM}},
  doi = {10.1145/1863523.1863542},
  author = {Yorgey, Brent A.},
  year = {2010},
  keywords = {algebraic data types,combinatorial species},
  pages = {147--158},
  file = {/Users/doisinkidney/Zotero/storage/6V84B4GG/Yorgey - 2010 - Species and Functors and Types, Oh My!.pdf;/Users/doisinkidney/Zotero/storage/6WJG5T4W/Yorgey - 2010 - Species and Functors and Types, Oh My!.pdf;/Users/doisinkidney/Zotero/storage/HUD7R6BZ/Yorgey - 2010 - Species and Functors and Types, Oh My!.pdf;/Users/doisinkidney/Zotero/storage/IEMY9FDS/Yorgey - 2010 - Species and Functors and Types, Oh My!.pdf;/Users/doisinkidney/Zotero/storage/MHKPNAFM/Yorgey - 2010 - Species and Functors and Types, Oh My!.pdf;/Users/doisinkidney/Zotero/storage/MNDK8W46/Yorgey - 2010 - Species and Functors and Types, Oh My!.pdf;/Users/doisinkidney/Zotero/storage/2FHAZ9ZT/761.html;/Users/doisinkidney/Zotero/storage/3M6G64NF/761.html;/Users/doisinkidney/Zotero/storage/3QZXR5EB/cat.inist.fr.html;/Users/doisinkidney/Zotero/storage/BANBH7HQ/citation.html;/Users/doisinkidney/Zotero/storage/SCZG3S6P/summary.html},
  ids = {yorgey\_species\_2010}
}

@phdthesis{yorgeyCombinatorialSpeciesLabelled2014,
  address = {{Pennsylvania}},
  title = {Combinatorial Species and Labelled Structures},
  language = {en},
  school = {University of Pennsylvania},
  author = {Yorgey, Brent Abraham},
  month = jan,
  year = {2014},
  file = {/Users/doisinkidney/Zotero/storage/HKVID4C5/Yorgey - Combinatorial Species and Labelled Structures.pdf;/Users/doisinkidney/Zotero/storage/N3EFPDGI/AAI3668177.html},
  ids = {yorgeyCombinatorialSpeciesLabelled}
}

@article{gustafssonFoldableContainersDependent,
  title = {Foldable Containers and Dependent Types},
  abstract = {Functional programs using foldable containers need reasoning tools as they are not equipped with laws. Moreover we want to allow any finite type to be foldable as well.},
  language = {en},
  author = {Gustafsson, Daniel and Pouillard, Nicolas},
  pages = {13},
  file = {/Users/doisinkidney/Zotero/storage/MEX9XNRN/Gustafsson and Pouillard - Foldable containers and dependent types.pdf}
}

@incollection{gonthierModularFormalisationFinite2007,
  address = {{Berlin, Heidelberg}},
  title = {A {{Modular Formalisation}} of {{Finite Group Theory}}},
  volume = {4732},
  isbn = {978-3-540-74590-7 978-3-540-74591-4},
  abstract = {In this paper, we present a formalisation of elementary group theory done in Coq. This work is the first milestone of a long-term effort to formalise Feit-Thompson theorem. As our further developments will heavily rely on this initial base, we took special care to articulate it in the most compositional way.},
  language = {en},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  publisher = {{Springer Berlin Heidelberg}},
  doi = {10.1007/978-3-540-74591-4_8},
  author = {Gonthier, Georges and Mahboubi, Assia and Rideau, Laurence and Tassi, Enrico and Th{\'e}ry, Laurent},
  editor = {Schneider, Klaus and Brandt, Jens},
  year = {2007},
  pages = {86-101},
  file = {/Users/doisinkidney/Zotero/storage/KVDFLLEJ/Gonthier et al. - 2007 - A Modular Formalisation of Finite Group Theory.pdf}
}

@inproceedings{abbottConstructingPolymorphicPrograms2004,
  address = {{Berlin, Heidelberg}},
  title = {Constructing {{Polymorphic Programs}} with {{Quotient Types}}},
  volume = {3125},
  isbn = {978-3-540-22380-1 978-3-540-27764-4},
  abstract = {The efficient representation and manipulation of data is one of the fundamental tasks in the construction of large software systems. Parametric polymorphism has been one of the most successful approaches to date but, as of yet, has not been applicable to programming with quotient datatypes such as unordered pairs, cyclic lists, bags etc. This paper provides the basis for writing polymorphic programs over quotient datatypes by extending our recently developed theory of containers.},
  language = {en},
  booktitle = {Mathematics of {{Program Construction}}},
  publisher = {{Springer Berlin Heidelberg}},
  doi = {10.1007/978-3-540-27764-4_2},
  author = {Abbott, Michael and Altenkirch, Thorsten and Ghani, Neil and McBride, Conor},
  editor = {Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Kozen, Dexter},
  year = {2004},
  pages = {2-15},
  file = {/Users/doisinkidney/Zotero/storage/NLIJD4CU/Abbott et al. - 2004 - Constructing Polymorphic Programs with Quotient Ty.pdf},
  ids = {abbott\_constructing\_2004}
}

@inproceedings{gambinoWellfoundedTreesDependent2004,
  address = {{Berlin, Heidelberg}},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Wellfounded {{Trees}} and {{Dependent Polynomial Functors}}},
  isbn = {978-3-540-24849-1},
  abstract = {We set out to study the consequences of the assumption of types of wellfounded trees in dependent type theories. We do so by investigating the categorical notion of wellfounded tree introduced in [16]. Our main result shows that wellfounded trees allow us to define initial algebras for a wide class of endofunctors on locally cartesian closed categories.},
  language = {en},
  booktitle = {Types for {{Proofs}} and {{Programs}}},
  publisher = {{Springer}},
  doi = {10.1007/978-3-540-24849-1_14},
  author = {Gambino, Nicola and Hyland, Martin},
  editor = {Berardi, Stefano and Coppo, Mario and Damiani, Ferruccio},
  year = {2004},
  keywords = {Type Theory,Monoidal Category,Natural Transformation,Left Adjoint,Forgetful Functor},
  pages = {210-225},
  file = {/Users/doisinkidney/Zotero/storage/XC33JZKE/Gambino and Hyland - 2004 - Wellfounded Trees and Dependent Polynomial Functor.pdf}
}

@inproceedings{abbottDerivativesContainers2003,
  address = {{Berlin, Heidelberg}},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Derivatives of {{Containers}}},
  volume = {2701},
  isbn = {978-3-540-44904-1},
  abstract = {We are investigating McBride's idea that the type of one-hole contexts are the formal derivative of a functor from a categorical perspective. Exploiting our recent work on containers we are able to characterise derivatives by a universal property and show that the laws of calculus including a rule for initial algebras as presented by McBride hold \textemdash{} hence the differentiable containers include those generated by polynomials and least fixpoints. Finally, we discuss abstract containers (i.e. quotients of containers) \textemdash{} this includes a container which plays the role of e x in calculus by being its own derivative.},
  language = {en},
  booktitle = {Typed {{Lambda Calculi}} and {{Applications}}},
  publisher = {{Springer}},
  doi = {10.1007/3-540-44904-3_2},
  author = {Abbott, Michael and Altenkirch, Thorsten and Ghani, Neil and McBride, Conor},
  editor = {Hofmann, Martin},
  year = {2003},
  keywords = {Cartesian Diagram,Decidable Object,Initial Algebra,Natural Transformation,Universal Property},
  pages = {16-30},
  file = {/Users/doisinkidney/Zotero/storage/HRMYS3WY/Abbott et al. - 2003 - Derivatives of Containers.pdf},
  ids = {abbott\_derivatives\_2003}
}

@inproceedings{jayShapelyTypesShape1994,
  address = {{Berlin, Heidelberg}},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Shapely Types and Shape Polymorphism},
  isbn = {978-3-540-48376-2},
  abstract = {Shapely types separate data, represented by lists, from shape, or structure. This separation supports shape polymorphism, where operations are defined for arbitrary shapes, and shapely operations, for which the shape of the result is determined by that of the input, permitting static shape checking. They include both arrays and the usual algebraic types (of trees, graphs, etc.), and are closed under the formation of initial algebras.},
  language = {en},
  booktitle = {Programming {{Languages}} and {{Systems}} \textemdash{} {{ESOP}} '94},
  publisher = {{Springer}},
  doi = {10.1007/3-540-57880-3_20},
  author = {Jay, C. Barry and Cockett, J. R. B.},
  editor = {Sannella, Donald},
  year = {1994},
  keywords = {Natural Transformation,Distributive Category,Shapely Type,Unique Algebra,Unique Morphism},
  pages = {302-316},
  file = {/Users/doisinkidney/Zotero/storage/QTUEIAGG/Jay and Cockett - 1994 - Shapely types and shape polymorphism.pdf}
}

@article{hasegawaTwoApplicationsAnalytic2002,
  series = {Theories of {{Types}} and {{Proofs}} 1997},
  title = {Two Applications of Analytic Functors},
  volume = {272},
  issn = {0304-3975},
  abstract = {We apply the theory of analytic functors to two topics related to theoretical computer science. One is a mathematical foundation of certain syntactic well-quasi-orders and well-orders appearing in graph theory, the theory of term rewriting systems, and proof theory. The other is a new verification of the Lagrange\textendash{}Good inversion formula using several ideas appearing in semantics of lambda calculi, especially the relation between categorical traces and fixpoint operators.},
  language = {en},
  number = {1},
  journal = {Theoretical Computer Science},
  doi = {10.1016/S0304-3975(00)00349-2},
  author = {Hasegawa, Ryu},
  month = feb,
  year = {2002},
  keywords = {Analytic functor,Lagrange–Good inversion formula,Recursive path ordering},
  pages = {113-175},
  file = {/Users/doisinkidney/Zotero/storage/M2GUT7E9/Hasegawa - 2002 - Two applications of analytic functors.pdf;/Users/doisinkidney/Zotero/storage/M4CJDIUJ/S0304397500003492.html}
}

@inproceedings{bertotCanonicalBigOperators2008a,
  address = {{Berlin, Heidelberg}},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  title = {Canonical {{Big Operators}}},
  volume = {5170},
  isbn = {978-3-540-71065-3 978-3-540-71067-7},
  abstract = {In this paper, we present an approach to describe uniformly iterated ``big'' operations, like {$\sum\mathsl{n}\mathsl{i}$}=0{$\mathsl{f}$}({$\mathsl{i}$}){$\sum$}i=0nf(i)\textbackslash{}sum\_\{i=0\}\^n f(i) or max i {$\in$} I f(i) and to provide lemmas that encapsulate all the commonly used reasoning steps on these constructs.We show that these iterated operations can be handled generically using the syntactic notation and canonical structure facilities provided by the Coq system. We then show how these canonical big operations played a crucial enabling role in the study of various parts of linear algebra and multi-dimensional real analysis, as illustrated by the formal proofs of the properties of determinants, of the Cayley-Hamilton theorem and of Kantorovitch's theorem.},
  language = {en},
  booktitle = {Theorem {{Proving}} in {{Higher Order Logics}}},
  publisher = {{Springer Berlin Heidelberg}},
  doi = {10.1007/978-3-540-71067-7_11},
  author = {Bertot, Yves and Gonthier, Georges and Ould Biha, Sidi and Pasca, Ioana},
  editor = {Mohamed, Otmane Ait and Mu{\~n}oz, C{\'e}sar and Tahar, Sofi{\`e}ne},
  year = {2008},
  keywords = {Neutral Element,Abelian Monoid,Canonical Structure,Functional Graph,Iterate Operation},
  pages = {86-101},
  file = {/Users/doisinkidney/Zotero/storage/UW6ZDWM9/Bertot et al. - 2008 - Canonical Big Operators.pdf},
  ids = {bertotCanonicalBigOperators2008}
}

@article{baezFiniteSetsFeynman2000,
  archivePrefix = {arXiv},
  eprint = {math/0004133},
  title = {From {{Finite Sets}} to {{Feynman Diagrams}}},
  abstract = {`Categorification' is the process of replacing equations by isomorphisms. We describe some of the ways a thoroughgoing emphasis on categorification can simplify and unify mathematics. We begin with elementary arithmetic, where the category of finite sets serves as a categorified version of the set of natural numbers, with disjoint union and Cartesian product playing the role of addition and multiplication. We sketch how categorifying the integers leads naturally to the infinite loop space Omega\^infinity S\^infinity, and how categorifying the positive rationals leads naturally to a notion of the `homotopy cardinality' of a tame space. Then we show how categorifying formal power series leads to Joyal's `especes des structures', or `structure types'. We also describe a useful generalization of structure types called `stuff types'. There is an inner product of stuff types that makes the category of stuff types into a categorified version of the Hilbert space of the quantized harmonic oscillator. We conclude by sketching how this idea gives a nice explanation of the combinatorics of Feynman diagrams.},
  journal = {arXiv:math/0004133},
  author = {Baez, John C. and Dolan, James},
  month = apr,
  year = {2000},
  keywords = {Mathematics - Category Theory,Mathematics - Quantum Algebra,Mathematics - Combinatorics,Mathematics - History and Overview},
  file = {/Users/doisinkidney/Zotero/storage/Q27EI2JR/Baez and Dolan - 2000 - From Finite Sets to Feynman Diagrams.pdf;/Users/doisinkidney/Zotero/storage/6DYEJ4YQ/0004133.html}
}

@article{flajoletAutomaticAveragecaseAnalysis1991,
  series = {2001},
  title = {Automatic Average-Case Analysis of Algorithms},
  volume = {79},
  issn = {0304-3975},
  abstract = {Many probabilistic properties of elementary discrete combinatorial structures of interest for the average-case analysis of algorithms prove to be decidable. This paper presents a general framework in which such decision procedures can be developed. It is based on a combination of generating function techniques for counting, and complex analysis techniques for asymptotic estimations. We expose here the theory of exact analysis in terms of generating functions for four different domains: the iterative/recursive and unlabelled/labelled data type domains. We then present some major components of the associated asymptotic theory and exhibit a class of naturally arising functions that can be automatically analyzed. A fair fragment of this theory is also incorporated into a system called Lambda-Upsilon-Omega. In this way, using computer algebra, one can produce automatically non-trivial average-case analyses of algorithms operating over a variety of ``decomposable'' combinatorial structures. At a fundamental level, this paper is part of a global attempt at understanding why so many elementary combinatorial problems tend to have elementary asymptotic solutions. In several cases, it proves possible to relate entire classes of elementary combinatorial problems whose structure is well defined with classes of elementary ``special'' functions and classes of asymptotic forms relative to counting, probabilities, or average-case complexity.},
  language = {en},
  number = {1},
  journal = {Theoretical Computer Science},
  doi = {10.1016/0304-3975(91)90145-R},
  author = {Flajolet, Philippe and Salvy, Bruno and Zimmermann, Paul},
  month = feb,
  year = {1991},
  pages = {37-109},
  file = {/Users/doisinkidney/Zotero/storage/B6GA3FW9/Flajolet et al. - 1991 - Automatic average-case analysis of algorithms.pdf;/Users/doisinkidney/Zotero/storage/X53TH5F3/030439759190145R.html}
}

@article{krausGeneralUniversalProperty2015,
  archivePrefix = {arXiv},
  eprint = {1411.2682},
  primaryClass = {math},
  title = {The {{General Universal Property}} of the {{Propositional Truncation}}},
  abstract = {In a type-theoretic fibration category in the sense of Shulman (representing a dependent type theory with at least 1, Sigma, Pi, and identity types), we define the type of constant functions from A to B. This involves an infinite tower of coherence conditions, and we therefore need the category to have Reedy limits of diagrams over omega. Our main result is that, if the category further has propositional truncations and satisfies function extensionality, the type of constant function is equivalent to the type ||A|| -{$>$} B. If B is an n-type for a given finite n, the tower of coherence conditions becomes finite and the requirement of nontrivial Reedy limits vanishes. The whole construction can then be carried out in Homotopy Type Theory and generalises the universal property of the truncation. This provides a way to define functions ||A|| -{$>$} B if B is not known to be propositional, and it streamlines the common approach of finding a proposition Q with A -{$>$} Q and Q -{$>$} B.},
  language = {en},
  journal = {arXiv:1411.2682 [math]},
  doi = {10.4230/LIPIcs.TYPES.2014.111},
  author = {Kraus, Nicolai},
  month = sep,
  year = {2015},
  keywords = {F.4.1,Mathematics - Logic},
  pages = {35 pages},
  file = {/Users/doisinkidney/Zotero/storage/8UUJD3GI/Kraus - 2015 - The General Universal Property of the Propositiona.pdf;/Users/doisinkidney/Zotero/storage/UT7FWEVL/Kraus - 2015 - The General Universal Property of the Propositiona.pdf},
  ids = {krausGeneralUniversalProperty2015a}
}

@article{flajoletCalculusRandomGeneration1994,
  title = {A {{Calculus}} for the {{Random Generation}} of {{Labelled Combinatorial Structures}}},
  volume = {132},
  issn = {0304-3975},
  abstract = {A systematic approach to the random generation of labelled combinatorial objects is presented. It applies to structures that are decomposable, i.e., formally specifiable by grammars involving set, sequence, and cycle constructions. A general strategy is developed for solving the random generation problem with two closely related types of methods: for structures of size n, the boustrophedonic algorithms exhibit a worst-case behaviour of the form O(n log n); the sequential algorithms have worst case O(n2), while offering good potential for optimizations in the average case. The complexity model is in terms of arithmetic operations and both methods appeal to precomputed numerical table of linear size that can be computed in time O(n2).A companion calculus permits systematically to compute the average case cost of the sequential generation algorithm associated to a given specification. Using optimizations dictated by the cost calculus, several random generation algorithms of the sequential type are developed; most of them have expected complexity 1/2n log n, and are thus only slightly superlinear. The approach is exemplified by the random generation of a number of classical combinatorial structures including Cayley trees, hierarchies, the cycle decomposition of permutations, binary trees, functional graphs, surjections, and set partitions.},
  number = {1},
  journal = {Theor. Comput. Sci.},
  doi = {10.1016/0304-3975(94)90226-7},
  author = {Flajolet, Philippe and Zimmermann, Paul and Van Cutsem, Bernard},
  month = sep,
  year = {1994},
  pages = {1--35},
  file = {/Users/doisinkidney/Zotero/storage/NPGKZ2QQ/Flajolet et al. - 1994 - A Calculus for the Random Generation of Labelled C.pdf}
}

@book{blellochPrefixSumsTheir,
  title = {Prefix {{Sums}} and {{Their Applications}}},
  abstract = {Experienced algorithm designers rely heavily on a set of building blocks and on the tools needed to put the blocks together into an algorithm. The understanding of these basic blocks and tools is therefore critical to the understanding of algorithms. Many of the blocks and tools needed for parallel},
  author = {Blelloch, Guy E.},
  file = {/Users/doisinkidney/Zotero/storage/Q2ABTBLY/Blelloch - Prefix Sums and Their Applications.pdf;/Users/doisinkidney/Zotero/storage/AYDMZE85/summary.html}
}

@article{uszkaySpeciesMakingAnalytic2008,
  title = {Species: Making Analytic Functors Practical for Functional Programming},
  abstract = {Inspired by Joyals theory of species, we show how to add new type constructors and constructor combinators to the tool set of functional languages. We show that all the important properties of inductive types lift to this new setting. Species are analytic functors, representing a broader range of structures than regular functors. This includes structures such as bags, cycles and graphs. The theory is greatly inspired by combinatorics rather than type theory: this adds interesting new tools to bear, but also requires more work on our part to show that species form a good foundations for a theory of type constructors. The combinatorial tools provide a calculus for these structures which has strong links with classical analysis, via a functorial interpretation of generating series. Furthermore, we show how generic programming idioms also generalise to this richer setting. Once the theory is understood, various methods of implementation are relatively straightforward.},
  language = {en},
  author = {Uszkay, Jacques Carette Gordon},
  year = {2008},
  pages = {24},
  file = {/Users/doisinkidney/Zotero/storage/KEERIL44/Uszkay - Species making analytic functors practical for fu.pdf}
}

@article{henryToposesGeneratedCardinal2018,
  title = {On Toposes Generated by Cardinal Finite Objects},
  volume = {165},
  issn = {0305-0041, 1469-8064},
  abstract = {We give a characterisations of toposes which admit a generating set of objects which are internally cardinal finite (i.e. Kuratowski finite and decidable) in terms of ``topological'' conditions. The central result is that, constructively, a hyperconnected separated locally decidable topos admit a generating set of cardinal finite objects. The main theorem is then a generalisation obtained as an application of this result internally in the localic reflection of an arbitrary topos: a topos is generated by cardinal finite objects if and only if it is separated, locally decidable, and its localic reflection is zero dimensional.},
  language = {en},
  number = {2},
  journal = {Mathematical Proceedings of the Cambridge Philosophical Society},
  doi = {10.1017/S0305004117000408},
  author = {Henry, Simon},
  month = sep,
  year = {2018},
  pages = {209-223},
  file = {/Users/doisinkidney/Zotero/storage/SNII6JF9/Henry - 2018 - On toposes generated by cardinal finite objects.pdf;/Users/doisinkidney/Zotero/storage/BE5S9KGH/98A60656FC9E5E3B4A746EA6C3F0ADF0.html}
}

@article{henryMeasureTheoryBoolean2017,
  archivePrefix = {arXiv},
  eprint = {1411.1605},
  title = {Measure Theory over Boolean Toposes},
  volume = {163},
  issn = {0305-0041, 1469-8064},
  abstract = {In this paper we develop a notion of measure theory over boolean toposes which is analogous to noncommutative measure theory, i.e. to the theory of von Neumann algebras. This is part of a larger project to study relations between topos theory and noncommutative geometry. The main result is a topos theoretic version of the modular time evolution of von Neumann algebra which take the form of a canonical R+*-principal bundle over any integrable locally separated boolean topos.},
  number = {1},
  journal = {Mathematical Proceedings of the Cambridge Philosophical Society},
  doi = {10.1017/S0305004116000700},
  author = {Henry, Simon},
  month = jul,
  year = {2017},
  keywords = {Mathematics - Category Theory,18B25; 03G30; 46L10; 46L51,Mathematics - Operator Algebras},
  pages = {1-21},
  file = {/Users/doisinkidney/Zotero/storage/QS8CV9H7/Henry - 2017 - Measure theory over boolean toposes.pdf;/Users/doisinkidney/Zotero/storage/KMVMB5YS/1411.html}
}

@book{johnstoneSketchesElephantTopos2002,
  title = {Sketches of an {{Elephant}}: {{A Topos Theory Compendium}}},
  isbn = {978-0-19-851598-2},
  shorttitle = {Sketches of an {{Elephant}}},
  abstract = {Topos Theory is a subject that stands at the junction of geometry, mathematical logic and theoretical computer science, and it derives much of its power from the interplay of ideas drawn from these different areas. Because of this, an account of topos theory which approaches the subject from one particular direction can only hope to give a partial picture; the aim of this compendium is to present as comprehensive an account as possible of all the main approaches and thereby to demonstrate the overall unity of the subject. The material is organized in such a way that readers interested in following a particular line of approach may do so by starting at an appropriate point in the text.},
  language = {en},
  publisher = {{Clarendon Press}},
  author = {Johnstone, Peter T. and Johnstone, Reader in the Foundations of Mathematics P. T.},
  month = sep,
  year = {2002},
  keywords = {Mathematics / History \& Philosophy,Mathematics / Logic,Mathematics / Geometry / Algebraic},
  file = {/Users/doisinkidney/Zotero/storage/RU6G6J3E/Johnstone and Johnstone - 2002 - Sketches of an Elephant A Topos Theory Compendium.pdf},
  googlebooks = {TLHfQPHNs0QC}
}

@article{bellCategoriesToposesSets1982,
  title = {Categories, {{Toposes}} and {{Sets}}},
  volume = {51},
  issn = {0039-7857},
  number = {3},
  journal = {Synthese},
  author = {Bell, J. L.},
  year = {1982},
  pages = {293-337},
  file = {/Users/doisinkidney/Zotero/storage/AY4JFIGV/Bell - 1982 - Categories, toposes and sets.pdf},
  ids = {bellCategoriesToposesSets1982a}
}

@article{escardoExhaustibleSetsHighertype2008,
  title = {Exhaustible Sets in Higher-Type Computation},
  volume = {Volume 4, Issue 3},
  abstract = {We say that a set is exhaustible if it admits algorithmic universal quantification for continuous predicates in finite time, and searchable if there is an algorithm that, given any continuous predicate, either selects an element for which the predicate holds or else tells there is no example. The Cantor space of infinite sequences of binary digits is known to be searchable. Searchable sets are exhaustible, and we show that the converse also holds for sets of hereditarily total elements in the hierarchy of continuous functionals; moreover, a selection functional can be constructed uniformly from a quantification functional. We prove that searchable sets are closed under intersections with decidable sets, and under the formation of computable images and of finite and countably infinite products. This is related to the fact, established here, that exhaustible sets are topologically compact. We obtain a complete description of exhaustible total sets by developing a computational version of a topological Arzela--Ascoli type characterization of compact subsets of function spaces. We also show that, in the non-empty case, they are precisely the computable images of the Cantor space. The emphasis of this paper is on the theory of exhaustible and searchable sets, but we also briefly sketch applications.},
  language = {en},
  journal = {Logical Methods in Computer Science},
  author = {Escardo, Martin},
  month = aug,
  year = {2008},
  file = {/Users/doisinkidney/Zotero/storage/WT9N23T4/Escardo - 2008 - Exhaustible sets in higher-type computation.pdf;/Users/doisinkidney/Zotero/storage/EEEDUK3G/693.html}
}

@book{stumpVerifiedFunctionalProgramming2016,
  address = {{New York, NY, USA}},
  title = {Verified {{Functional Programming}} in {{Agda}}},
  isbn = {978-1-970001-27-3},
  abstract = {Agda is an advanced programming language based on Type Theory. Agda's type system is expressive enough to support full functional verification of programs, in two styles. In external verification, we write pure functional programs and then write proofs of properties about them. The proofs are separate external artifacts, typically using structural induction. In internal verification, we specify properties of programs through rich types for the programs themselves. This often necessitates including proofs inside code, to show the type checker that the specified properties hold. The power to prove properties of programs in these two styles is a profound addition to the practice of programming, giving programmers the power to guarantee the absence of bugs, and thus improve the quality of software more than previously possible. Verified Functional Programming in Agda is the first book to provide a systematic exposition of external and internal verification in Agda, suitable for undergraduate students of Computer Science. No familiarity with functional programming or computer-checked proofs is presupposed.  The book begins with an introduction to functional programming through familiar examples like booleans, natural numbers, and lists, and techniques for external verification. Internal verification is considered through the examples of vectors, binary search trees, and Braun trees. More advanced material on type-level computation, explicit reasoning about termination, and normalization by evaluation is also included. The book also includes a medium-sized case study on Huffman encoding and decoding.},
  publisher = {{Association for Computing Machinery and Morgan \& Claypool}},
  author = {Stump, Aaron},
  year = {2016}
}

@article{myhillErrettBishopFoundations1972,
  title = {Errett {{Bishop}}. {{Foundations}} of Constructive Analysis. {{McGraw}}-{{Hill Book Company}}, {{New York}}, {{San Francisco}}, {{St}}. {{Louis}}, {{Toronto}}, {{London}}, and {{Sydney}}, 1967, Xiii + 370 Pp. - {{Errett Bishop}}. {{Mathematics}} as a Numerical Language. {{Intuitionism}} and Proof Theory, {{Proceedings}} of the Summer Conference at {{Buffalo N}}.{{Y}}. 1968, Edited by {{A}}. {{Kino}}, {{J}}. {{Myhill}}, and {{R}}. {{E}}. {{Vesley}}, {{Studies}} in Logic and the Foundations of Mathematics, {{North}}-{{Holland Publishing Company}}, {{Amsterdam}} and {{London1970}}, Pp. 53\textendash{}71.},
  volume = {37},
  issn = {0022-4812, 1943-5886},
  abstract = {//static.cambridge.org/content/id/urn\%3Acambridge.org\%3Aid\%3Aarticle\%3AS0022481200078567/resource/name/firstPage-S0022481200078567a.jpg},
  language = {en},
  number = {4},
  journal = {The Journal of Symbolic Logic},
  doi = {10.2307/2272421},
  author = {Myhill, John},
  month = dec,
  year = {1972},
  pages = {744-747},
  file = {/Users/doisinkidney/Zotero/storage/RRVVUADX/EF44236150564905AFAFD0496BFBF39A.html}
}

@article{hedbergCoherenceTheoremMartinLof1998,
  title = {A Coherence Theorem for {{Martin}}-{{L{\"o}f}}'s Type Theory},
  volume = {8},
  issn = {0956-7968, 1469-7653},
  abstract = {In type theory a proposition is represented by a type, the type of its proofs. As a consequence, the equality relation on a certain type is represented by a binary family of types. Equality on a type may be conventional or inductive. Conventional equality means that one particular equivalence relation is singled out as the equality, while inductive equality \textendash{} which we also call identity \textendash{} is inductively defined as the `smallest reflexive relation'. It is sometimes convenient to know that the type representing a proposition is collapsed, in the sense that all its inhabitants are identical. Although uniqueness of identity proofs for an arbitrary type is not derivable inside type theory, there is a large class of types for which it may be proved. Our main result is a proof that any type with decidable identity has unique identity proofs. This result is convenient for proving that the class of types with decidable identities is closed under indexed sum. Our proof of the main result is completely formalized within a kernel fragment of Martin-Lo\textasciidieresis{}f's type theory and mechanized using ALF. Proofs of auxiliary lemmas are explained in terms of the category theoretical properties of identity. These suggest two coherence theorems as the result of rephrasing the main result in a context of conventional equality, where the inductive equality has been replaced by, in the former, an initial category structure and, in the latter, a smallest reflexive relation.},
  language = {en},
  number = {4},
  journal = {Journal of Functional Programming},
  doi = {10.1017/S0956796898003153},
  author = {Hedberg, Michael},
  month = jul,
  year = {1998},
  pages = {413-436},
  file = {/Users/doisinkidney/Zotero/storage/HPIG33ZY/Hedberg - 1998 - A coherence theorem for Martin-Löf's type theory.pdf}
}

@article{kornerupAlgorithmRedundantBinary1990,
  title = {An Algorithm for Redundant Binary Bit-Pipelined Rational Arithmetic},
  volume = {39},
  issn = {00189340},
  language = {en},
  number = {8},
  journal = {IEEE Transactions on Computers},
  doi = {10.1109/12.57048},
  author = {Kornerup, P. and Matula, D.W.},
  year = {Aug./1990},
  pages = {1106-1115},
  file = {/Users/doisinkidney/Zotero/storage/IUUPER6Y/Kornerup and Matula - 1990 - An algorithm for redundant binary bit-pipelined ra.pdf}
}

@inproceedings{licataCalculatingFundamentalGroup2013,
  title = {Calculating the {{Fundamental Group}} of the {{Circle}} in {{Homotopy Type Theory}}},
  abstract = {Recent work on homotopy type theory exploits an exciting new correspondence between Martin-Lof's dependent type theory and the mathematical disciplines of category theory and homotopy theory. The mathematics suggests new principles to add to type theory, while the type theory can be used in novel ways to do computer-checked proofs in a proof assistant. In this paper, we formalize a basic result in algebraic topology, that the fundamental group of the circle is the integers. Our proof illustrates the new features of homotopy type theory, such as higher inductive types and Voevodsky's univalence axiom. It also introduces a new method for calculating the path space of a type, which has proved useful in many other examples.},
  booktitle = {2013 28th {{Annual ACM}}/{{IEEE Symposium}} on {{Logic}} in {{Computer Science}}},
  doi = {10.1109/LICS.2013.28},
  author = {Licata, Daniel R. and Shulman, Michael},
  month = jun,
  year = {2013},
  keywords = {Decoding,theorem proving,type theory,category theory,homotopy type theory,algebraic topology,Clocks,computer-checked proofs,Frequency modulation,fundamental group,Generators,Geometry,homotopy theory,inductive types,Martin-Lof's dependent type theory,mathematical disciplines,proof assistant,topology,Topology,Voevodsky's univalence axiom},
  pages = {223-232},
  file = {/Users/doisinkidney/Zotero/storage/46DPXGQ8/Licata and Shulman - 2013 - Calculating the Fundamental Group of the Circle in.pdf;/Users/doisinkidney/Zotero/storage/V5X8GHTM/6571554.html},
  issn = {1043-6871}
}

@article{jacobsProbabilityMonadsCommutative2018,
  title = {From Probability Monads to Commutative Effectuses},
  volume = {94},
  issn = {2352-2208},
  abstract = {Effectuses have recently been introduced as categorical models for quantum computation, with probabilistic and Boolean (classical) computation as special cases. These `probabilistic' models are called commutative effectuses, and are the focus of attention here. The paper describes the main known `probability' monads: the monad of discrete probability measures, the Giry monad, the expectation monad, the probabilistic power domain monad, the Radon monad, and the Kantorovich monad. It also introduces successive properties that a monad should satisfy so that its Kleisli category is a commutative effectus. The main properties are: partial additivity, strong affineness, and commutativity. It is shown that the resulting commutative effectus provides a categorical model of probability theory, including a logic using effect modules with parallel and sequential conjunction, predicate- and state-transformers, normalisation and conditioning of states.},
  language = {en},
  journal = {Journal of Logical and Algebraic Methods in Programming},
  doi = {10.1016/j.jlamp.2016.11.006},
  author = {Jacobs, Bart},
  month = jan,
  year = {2018},
  pages = {200-237},
  file = {/Users/doisinkidney/Zotero/storage/9CHSY6MJ/Jacobs - 2018 - From probability monads to commutative effectuses.pdf;/Users/doisinkidney/Zotero/storage/NYSKLK38/Jacobs - 2018 - From probability monads to commutative effectuses.pdf;/Users/doisinkidney/Zotero/storage/NMYLR6FA/S2352220816301122.html},
  ids = {jacobs\_probability\_2018}
}

@article{fritzConvexSpacesDefinition2015,
  archivePrefix = {arXiv},
  eprint = {0903.5522},
  primaryClass = {math},
  title = {Convex {{Spaces I}}: {{Definition}} and {{Examples}}},
  shorttitle = {Convex {{Spaces I}}},
  abstract = {We propose an abstract definition of convex spaces as sets where one can take convex combinations in a consistent way. A priori, a convex space is an algebra over a finitary version of the Giry monad. We identify the corresponding Lawvere theory as the category from arXiv:0902.2554 and use the results obtained there to extract a concrete definition of convex space in terms of a family of binary operations satisfying certain compatibility conditions. After giving an extensive list of examples of convex sets as they appear throughout mathematics and theoretical physics, we find that there also exist convex spaces that cannot be embedded into a vector space: semilattices are a class of examples of purely combinatorial type. In an information-theoretic interpretation, convex subsets of vector spaces are probabilistic, while semilattices are possibilistic. Convex spaces unify these two concepts.},
  journal = {arXiv:0903.5522 [math]},
  author = {Fritz, Tobias},
  month = oct,
  year = {2015},
  keywords = {52A01,Mathematics - Metric Geometry},
  file = {/Users/doisinkidney/Zotero/storage/CZRTVJ38/Fritz - 2015 - Convex Spaces I Definition and Examples.pdf;/Users/doisinkidney/Zotero/storage/YKN3TWNL/0903.html}
}

@article{spittersCubicalSetsTopological2016,
  archivePrefix = {arXiv},
  eprint = {1610.05270},
  primaryClass = {cs, math},
  title = {Cubical Sets and the Topological Topos},
  abstract = {Coquand's cubical set model for homotopy type theory provides the basis for a computational interpretation of the univalence axiom and some higher inductive types, as implemented in the cubical proof assistant. This paper contributes to the understanding of this model. We make three contributions: 1. Johnstone's topological topos was created to present the geometric realization of simplicial sets as a geometric morphism between toposes. Johnstone shows that simplicial sets classify strict linear orders with disjoint endpoints and that (classically) the unit interval is such an order. Here we show that it can also be a target for cubical realization by showing that Coquand's cubical sets classify the geometric theory of flat distributive lattices. As a side result, we obtain a simplicial realization of a cubical set. 2. Using the internal `interval' in the topos of cubical sets, we construct a Moore path model of identity types. 3. We construct a premodel structure internally in the cubical type theory and hence on the fibrant objects in cubical sets.},
  journal = {arXiv:1610.05270 [cs, math]},
  author = {Spitters, Bas},
  month = oct,
  year = {2016},
  keywords = {Computer Science - Logic in Computer Science,Mathematics - Category Theory,F.4.1,Mathematics - Logic,03B70 (logic in computer science); 03B15 (higher-order logic and type theory); 55U35 (abstract and axiomatic homotopy theory)},
  file = {/Users/doisinkidney/Zotero/storage/R2K3HW4Y/Spitters - 2016 - Cubical sets and the topological topos.pdf;/Users/doisinkidney/Zotero/storage/F8GA7YC8/1610.html}
}

@inproceedings{johnstoneAlgebraicTheoriesToposes1978,
  address = {{Berlin, Heidelberg}},
  series = {Lecture {{Notes}} in {{Mathematics}}},
  title = {Algebraic Theories in Toposes},
  isbn = {978-3-540-35762-9},
  language = {en},
  booktitle = {Indexed {{Categories}} and {{Their Applications}}},
  publisher = {{Springer}},
  doi = {10.1007/BFb0061363},
  author = {Johnstone, Peter T. and Wraith, Gavin C.},
  editor = {Johnstone, Peter T. and Par{\'e}, Robert and Rosebrugh, R. D. and Schumacher, D. and Wood, R. J. and Wraith, G. C.},
  year = {1978},
  keywords = {Algebraic Theory,Forgetful Functor,Inclusion Functor,Monoid Structure,Monoidal Category},
  pages = {141-242}
}

@inproceedings{spittersCubicalSetsClassifying2015,
  title = {Cubical {{Sets}} as a {{Classifying Topos}} {${_\ast}$} {{Bas Spitters}}},
  abstract = {Coquand's cubical set model for homotopy type theory provides the basis for a computational interpretation of the univalence axiom and some higher inductive types, as implemented in the cubical proof assistant. We show that the underlying cube category is the opposite of the Lawvere theory of De Morgan algebras. The topos of cubical sets itself classifies the theory of `free De Morgan algebras'. This provides us with a topos with an internal `interval'. Using this interval we construct a model of type theory following van den Berg and Garner. We are currently investigating the precise relation with Coquand's. We do not exclude that the interval can also be used to construct other models. The topos of cubical sets Simplicial sets from a standard framework for homotopy theory. The topos of simplicial sets is the classifying topos of the theory of strict linear orders with endpoints. Cubical sets turn out to be more amenable to a constructive treatment of homotopy type theory. Grandis and Mauri [4] describe the classifying theories for several cubical sets without diagonals. We consider the most recent cubical set model [2]. This consists of symmetric cubical sets with connections ({$\wedge$},{$\vee$}), reversions ({$\lnot$}) and diagonals. Let F be the category of finite sets with all maps. Consider the monad DM on F which assigns to each finite set F the finite free DM-algebra (=De Morganalgebra) on F . That this set is finite can be seen using the disjunctive normal form. The cube category in [2] is the Kleisli category for the monad DM . Lawvere theory Recall that for each algebraic (=finite product) theory T , the Lawvere theory Cfp[T ] is the opposite of the category of free finitely generated models. This is the classifying category for T : models of T in any finite product category category E correspond to product-preserving functors Cfp[T ] \textrightarrow{} E. The Kleisli category KLDM is precisely the opposite of the Lawvere theory for DM-algebras: maps I \textrightarrow{} DM(J) are equivalent to DMmaps DM(I)\textrightarrow{} DM(J) since each such DM-map is completely determined by its behavior on the atoms, as DM(I) is free. Classifying topos To obtain the classifying topos for an algebraic theory, we first need to complete with finite limits, i.e. to consider the category Cfl as the opposite of finitely presented DM-algebras. Then C fl \textrightarrow{} Set, i.e. functors on finitely presented T -algebras, is the classifying topos. This topos contains a generic T -algebra M . T -algebras in any topos F correspond to left exact left adjoint functors from the classifying topos to F . Let FG be the category of free finitely generated DM-algebras and let FP the category of finitely presented ones. We have a fully faithful functor f : FG\textrightarrow{} FP . This gives a geometric morphism {$\varphi$} between the functor toposes. Since f is fully faithful, {$\varphi$} is an embedding. {${_\ast}$}I gratefully acknowledge the support of the Air Force Office of Scientific Research through MURI grant FA9550-15-1-0053. Any opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of the AFOSR.},
  author = {Spitters, Bas},
  year = {2015},
  keywords = {Classification,Linear algebra,Monad (functional programming),Lawvere theory,Proof assistant,Berg connector,Computation,De Morgan's laws,Dextromethorphan Hydrobromide 2 MG/ML / Guaifenesin 20 MG/ML Oral Solution,Disjunctive normal form,Double Minutes,Embedding,F-algebra,Flumazenil,Homotopy type theory,Job control (Unix),Map,protein tyrosine phosphatase BL,Thierry Coquand}
}

@article{spittersCubicalSetsClassifying,
  title = {Cubical {{Sets}} as a {{Classifying Topos}}},
  abstract = {Coquand's cubical set model for homotopy type theory provides the basis for a computational interpretation of the univalence axiom and some higher inductive types, as implemented in the cubical proof assistant. We show that the underlying cube category is the opposite of the Lawvere theory of De Morgan algebras. The topos of cubical sets itself classifies the theory of `free De Morgan algebras'. This provides us with a topos with an internal `interval'. Using this interval we construct a model of type theory following van den Berg and Garner. We are currently investigating the precise relation with Coquand's. We do not exclude that the interval can also be used to construct other models.},
  language = {en},
  author = {Spitters, Bas},
  pages = {2},
  file = {/Users/doisinkidney/Zotero/storage/YM3Y3W5M/Spitters - Cubical Sets as a Classifying Topos.pdf}
}

@article{abelPOPLMarkReloadedMechanizing2019,
  title = {{{POPLMark}} Reloaded: {{Mechanizing}} Proofs by Logical Relations},
  volume = {29},
  issn = {0956-7968, 1469-7653},
  shorttitle = {{{POPLMark}} Reloaded},
  abstract = {We propose a new collection of benchmark problems in mechanizing the metatheory of programming languages, in order to compare and push the state of the art of proof assistants. In particular, we focus on proofs using logical relations (LRs) and propose establishing strong normalization of a simply typed calculus with a proof by Kripke-style LRs as a benchmark. We give a modern view of this well-understood problem by formulating our LR on well-typed terms. Using this case study, we share some of the lessons learned tackling this problem in different dependently typed proof environments. In particular, we consider the mechanization in Beluga, a proof environment that supports higher-order abstract syntax encodings and contrast it to the development and strategies used in general-purpose proof assistants such as Coq and Agda. The goal of this paper is to engage the community in discussions on what support in proof environments is needed to truly bring mechanized metatheory to the masses and engage said community in the crafting of future benchmarks.},
  language = {en},
  journal = {Journal of Functional Programming},
  doi = {10.1017/S0956796819000170},
  author = {Abel, Andreas and Allais, Guillaume and Hameer, Aliya and Pientka, Brigitte and Momigliano, Alberto and Sch{\"a}fer, Steven and Stark, Kathrin},
  year = {2019/ed},
  file = {/Users/doisinkidney/Zotero/storage/IY3A6R2R/Abel et al. - 2019 - POPLMark reloaded Mechanizing proofs by logical r.pdf;/Users/doisinkidney/Zotero/storage/S234E9NP/BA79B0865D855971F54D69A159905A62.html},
  ids = {abelPOPLMarkReloadedMechanizing2019a}
}

@article{caretteReversibleProgramsUnivalent2018,
  archivePrefix = {arXiv},
  eprint = {1708.02710},
  title = {From {{Reversible Programs}} to {{Univalent Universes}} and {{Back}}},
  volume = {336},
  issn = {15710661},
  abstract = {We establish a close connection between a reversible programming language based on type isomorphisms and a formally presented univalent universe. The correspondence relates combinators witnessing type isomorphisms in the programming language to paths in the univalent universe; and combinator optimizations in the programming language to 2-paths in the univalent universe. The result suggests a simple computational interpretation of paths and of univalence in terms of familiar programming constructs whenever the universe in question is computable.},
  journal = {Electronic Notes in Theoretical Computer Science},
  doi = {10.1016/j.entcs.2018.03.013},
  author = {Carette, Jacques and Chen, Chao-Hong and Choudhury, Vikraman and Sabry, Amr},
  month = apr,
  year = {2018},
  keywords = {Computer Science - Programming Languages,F.3.2,Computer Science - Logic in Computer Science,D.3.2},
  pages = {5-25},
  file = {/Users/doisinkidney/Zotero/storage/JS9ANMU6/Carette et al. - 2018 - From Reversible Programs to Univalent Universes an.pdf;/Users/doisinkidney/Zotero/storage/B797TJS5/1708.html}
}

@article{szudzikRosenbergStrongPairingFunction2019,
  archivePrefix = {arXiv},
  eprint = {1706.04129},
  primaryClass = {cs},
  title = {The {{Rosenberg}}-{{Strong Pairing Function}}},
  abstract = {This article surveys the known results (and not very well-known results) associated with Cantor's pairing function and the Rosenberg-Strong pairing function, including their inverses, their generalizations to higher dimensions, and a discussion of a few of the advantages of the Rosenberg-Strong pairing function over Cantor's pairing function in practical applications. In particular, an application to the problem of enumerating full binary trees is discussed.},
  journal = {arXiv:1706.04129 [cs]},
  author = {Szudzik, Matthew P.},
  month = jan,
  year = {2019},
  keywords = {05A15 (Primary) 03D20; 05C05; 68P30 (Secondary),Computer Science - Discrete Mathematics},
  file = {/Users/doisinkidney/Zotero/storage/E8JKMCJU/Szudzik - 2019 - The Rosenberg-Strong Pairing Function.pdf;/Users/doisinkidney/Zotero/storage/2EDDY4NG/1706.html}
}

@article{forsbergThreeEquivalentOrdinal2020,
  title = {Three {{Equivalent Ordinal Notation Systems}}  in {{Cubical Agda}}},
  abstract = {We present three ordinal notation systems representing ordinals below {$\epsilon$}0 in type theory, using recent type-theoretical innovations such as mutual inductive-inductive definitions and higher inductive types. We show how ordinal arithmetic can be developed for these systems, and how they admit a transfinite induction principle. We prove that all three notation systems are equivalent, so that we can transport results between them using the univalence principle. All our constructions have been implemented in cubical Agda.},
  language = {en},
  author = {Forsberg, Fredrik Nordvall and Xu, Chuangjie and Ghani, Neil},
  year = {2020},
  pages = {14},
  file = {/Users/doisinkidney/Zotero/storage/RM8INYDP/Forsberg et al. - 2020 - Three Equivalent Ordinal Notation Systems  in Cubi.pdf}
}

@article{swensonConstructiveProofCountability1987,
  title = {A Constructive Proof of the Countability of {{$\Sigma$}} {\textsuperscript{*}}},
  volume = {18},
  issn = {01635700},
  language = {en},
  number = {4},
  journal = {ACM SIGACT News},
  doi = {10.1145/36068.36069},
  author = {Swenson, James M.},
  month = jul,
  year = {1987},
  pages = {48-50},
  file = {/Users/doisinkidney/Zotero/storage/KHUU622H/Swenson - 1987 - A constructive proof of the countability of Σ sup.pdf}
}

@article{devrieseBrightSideType2011,
  title = {On the Bright Side of Type Classes: Instance Arguments in {{Agda}}},
  volume = {46},
  issn = {03621340},
  shorttitle = {On the Bright Side of Type Classes},
  abstract = {We present instance arguments: an alternative to type classes and related features in the dependently typed, purely functional programming language/proof assistant Agda. They are a new, general type of function arguments, resolved from call-site scope in a typedirected way. The mechanism is inspired by both Scala's implicits and Agda's existing implicit arguments, but differs from both in important ways. Our mechanism is designed and implemented for Agda, but our design choices can be applied to other programming languages as well.},
  language = {en},
  number = {9},
  journal = {ACM SIGPLAN Notices},
  doi = {10.1145/2034574.2034796},
  author = {Devriese, Dominique and Piessens, Frank},
  month = sep,
  year = {2011},
  pages = {143},
  file = {/Users/doisinkidney/Zotero/storage/XZW44SIH/Devriese and Piessens - 2011 - On the bright side of type classes instance argum.pdf;/Users/doisinkidney/Zotero/storage/CPZVL9B2/2034574.html},
  ids = {devriesedominiqueBrightSideType2011}
}

@book{backhouseMathematicsProgramConstruction2000,
  address = {{New York}},
  series = {Lecture Notes in Computer Science},
  title = {Mathematics of Program Construction: 5th International Conference, {{MPC}} 2000, {{Ponte}} de {{Lima}}, {{Portugal}}, {{July}} 2000: Proceedings},
  isbn = {978-3-540-67727-7},
  lccn = {QA76.6 .I5535 2000},
  shorttitle = {Mathematics of Program Construction},
  language = {en},
  number = {1837},
  publisher = {{Springer}},
  editor = {Backhouse, Roland C. and Oliveira, Jos{\'e} N.},
  year = {2000},
  keywords = {Computer programming,Computer science,Congresses,Mathematics},
  file = {/Users/doisinkidney/Zotero/storage/SMEWMIJV/Backhouse and Oliveira - 2000 - Mathematics of program construction 5th internati.pdf}
}


