\section{Introduction}
\subsection{Foreword}
Proofs in constructive mathematics are often more substantial than their
classical counterparts.
``Substantial'' here doesn't mean the literal length of the proofs (although the
double meaning is not lost on anyone who has had to struggle with a modern
constructive proof assistant), but rather refers to their \emph{content}: a
constructive proof contains more \emph{stuff} than a classical one.

If we were to prove that a set was finite in classical mathematics, we might
show that it is in bijection with another finite set, say a finite prefix of the
natural numbers.
In semi-formal notation, to say that a set \(A\) is finite we would show the
following:
\begin{equation} \label{example-finite}
  \mathbf{Finite}(A) \coloneqq \exists (n : \mathbb{N}) . \; A \Leftrightarrow \left\{ m \mid m < n\right\}
\end{equation}
Where \(A~\Leftrightarrow~B\) means ``a bijection between \(A\) and \(B\)''.

Classically, a proof of equation~\ref{example-finite} is nothing more than
\emph{evidence} for the proposition of equation~\ref{example-finite}.
A constructive proof of \ref{example-finite}, however, is a mathematical object
in its own right, containing:
\begin{enumerate}
  \item A number \(n\) representing the cardinality of \(A\).
  \item A function from \(A\) to \(\left\{ m \mid m < n \right\}\).
  \item A function from \(\left\{ m \mid m < n \right\}\) to \(A\).
\end{enumerate}
In other words, it makes sense (in constructive mathematics) to talk about a
function of type \(\mathbf{Finite}(A)~\rightarrow~\mathbb{N}\), which takes a
\emph{proof} of the finiteness of \(A\) and returns \(A\)'s cardinality.

Such functions are perhaps even more concrete than this description suggests:
many constructive proofs are in fact computer programs in disguise (and
vice-versa \cite{wadlerPropositionsTypes2015}).
All ``proofs'' in this paper correspond to honest-to-goodness proofs in a
programming language (Cubical Agda \cite{vezzosiCubicalAgdaDependently2019} in
our case) which can be run on a computer to produce real output.

We have now hopefully established, albeit informally, what it means for
constructive proofs to be ``substantial''.
Clearly this extra information carried by proofs can add richness to their
study: we will see, for instance, no fewer than five finiteness predicates in
this paper which would collapse to one in a classical setting.
The extra information also presents a challenge, however: occasionally we will
see that we have revealed \emph{too much} information while proving some
property.

Consider the category of finite sets.
We will explore this category in much more detail later, but for now we just
need to know that the objects of this category are---shockingly---finite sets.
Constructively, the objects of this category can be thought of as \emph{pairs},
where the first element is a set (like \(\left\{ \text{True}, \text{False}
\right\}\), the two-element set of the booleans) and the second is a proof that
that set is finite.
If we take those proofs to be the kind given in equation~\ref{example-finite},
we should see that they contain a bijection from the booleans to the set
\(\left\{ 0, 1 \right\}\): however \emph{two} such bijections exist!
\begin{figure}[h]
  \centering
  \begin{subfigure}[b]{.45\textwidth}
    \centering
    \begin{tikzcd}
      \text{True}  \ar[rr, leftrightarrow] & & 0 \\
      \text{False} \ar[rr, leftrightarrow] & & 1
    \end{tikzcd}
  \end{subfigure}
  \begin{subfigure}[b]{.45\textwidth}
    \centering
    \begin{tikzcd}
      \text{True}  \ar[rrd, leftrightarrow, start anchor=south east, end anchor=north west] & & 0 \\
      \text{False} \ar[rru, leftrightarrow, start anchor=north east, end anchor=south west, crossing over] & & 1
    \end{tikzcd}
  \end{subfigure}
  \caption{The Two Bijections Between the Booleans and \(\left\{ 0, 1 \right\}\)}
\end{figure}
This means that where we wanted one object to correspond to the finite set
\(\left\{ \text{True}, \text{False} \right\}\), we instead have two.
In fact, for any finite set of cardinality \(n\) we will have \(n!\) finiteness
proofs, and therefore \(n!\) objects.
We have constructed, in other words, entirely the wrong category.

Being able to hide the extra information in a constructive proof when we need to
is clearly important.
HoTT (and CuTT by extension) facilitate this hiding: how exactly it is
accomplished will be explored in the subsequent sections.

Finally, for all of its benefits, constructive mathematics (especially
dependently-typed constructive mathematics on a computer) still suffers from
many painful drawbacks.
As already hinted at, proofs in a constructive setting can tend to be verbose,
especially when the arbiter of correctness is as strict as a computer, which
neither understands nor trusts the time-honoured technique of ``the other cases
are obviously true''.
While the goal of using a computer to automate the boring parts of a proof still
seems attainable, too often getting a computer involved in a proof means adding
thousands of lines of tedium to satisfy its lack of intuition.

Simple proof search over a finite domain is a simple, if effective, way to
relieve some of the tedium.
Many libraries in Agda, Coq, and other languages make use of this fact.
While the idea for finite proof search is simple, we found that implementing one
revealed a number of interesting theoretical considerations:
\begin{description}
  \item[How should we construct search spaces?]
    We found that a \(Pi\)-pretopos provided the appropriate ``generator
    language'' for constructing search spaces for finite types.
  \item[How do we deal with functions?]
    We of course would like to be able to search over functions: \todo{?}
  \item[How do we talk about ``searchability''?]
    \todo{Omniscience}
\end{description}
Finiteness is a prime example of a phenomenon which happens quite frequently in
dependently-typed constructive mathematics: through building a practical program
we unearth theoretically interesting results.
\todo{rephrase}
\subsection{Contributions}
We are interested in constructive notions of finiteness.
In contrast to classical finiteness, in a constructive setting there is a wide
variety of predicates which all have some claim to being the formal
interpretation of ``finiteness''.
Broadly, they vary along two axes: informativeness (i.e. how many properties
of the underlying type we can derive from a proof that it is finite), and
restrictiveness (i.e. how many types conform to its particular variety of
finiteness).
We will explore five of these predicates, proving formally their relations and
implications.

We will then focus on one of the predicates: decidable Kuratowski finiteness.
We will construct a category of decidable Kuratowski-finite types, and show that
it forms a \(\Pi\)-pretopos.

We will then take a brief detour into predicates for countably infinite types,
and compare its landscape to that of the finite predicates.

Finally, we will present a case-study in a practical application of the
predicates for finiteness we have constructed: a library for total proof search.
We will show how our earlier work gives a good theoretical foundation for this
library, and allows for a simple and principled API, and we will demonstrate how
some of the more complex theoretical results allow for a more powerful library
with capabilities not seen in comparable proof search libraries.

\input{figures/finite-classification}

\subsubsection{Finiteness Predicates}
Our first contribution is a cataloguing and characterisation of five finiteness
predicates, shown in figure~\ref{finite-classification}.

While our focus is decidable Kuratowski finiteness, in order to prove the
closure properties that we are interested in we will need to work with the
intermediate predicates as well (though they are also interesting in their own
right).

Since we have a proof-search library in mind, we will have to consider how to
present a good API for constructing proofs of finiteness.
In this vein we will show that some simple base types are finite
(\(\mathbf{Bool}\), \(\top\), \(\bot\), etc), and we will provide functions to
combine finiteness proofs together into more complex types (i.e. \(\times\),
\(\uplus\), \(\Sigma\), \(\Pi\), etc).
As we will see this choice of toolbox for building finiteness proofs actually
has a deep categorical justification, but at this point it makes sense to look
at it as just a suitably general and powerful API.



Our focus in this work is decidable Kuratowski finiteness.
We will characterise it, its strength, and its uses, and in particular we will
show that it forms a \(\Pi\)-pretopos.
Our proofs follow the structure of \cite[Chapters 9, 10]{hottbook} and
\cite{rijkeSetsHomotopyType2015}.
We will explore this concept in more detail later, but crucially we will need to
provide proofs of closure under \(\times\), \(\rightarrow\), etc.

In order to prove these closure properties, we will define and use some
intermediate finiteness predicates, classified in
figure~\ref{finite-classification}.
These predicates are also interesting in their own right, though!

The arrows in figure~\ref{finite-classification} are implication functions
between each predicate.
In section~\ref{relations} we will provide a function which inhabits each arrow.
Each unlabelled arrow is an unconditional implication: every manifest Bishop
finite set is cardinal finite (lemma~\ref{manifest-bishop-to-cardinal}), for
instance.
The labelled arrows are strengthening proofs: every manifest enumerable set
\emph{with decidable equality} is split enumerable
(lemma~\ref{manifest-enum-to-split-enum}).
Our most significant result here is the proof that a cardinal finite set with a
decidable total order is manifestly Bishop finite.

\subsubsection{Countability Predicates}
After the finite predicates, we will briefly look at the infinite countable
types, and classify them in a parallel way to the finite predicates
(section~\ref{infinite}).
\subsubsection{Search}
All of our work is formalised in Cubical Agda
\cite{vezzosiCubicalAgdaDependently2019}.
We will make mention of the few occasions where the formalisation of some proof
is of interest, but the main place where we will discuss the code is in
section~\ref{search}, where we implement a library for proof search, based on
omniscience and exhaustibility.
This library relies directly on the computational content of univalence, which
allows us to (for instance) have \(\Pi\) types in the domain of the search
space.
The language of a \(\Pi\)-pretopos turns out to be exactly the right language
for constructing ``generator''-like expressions.

The full code of the formalisation is available at
\url{https://github.com/oisdk/finiteness-in-cubical-type-theory}.
\subsection{Notation and Background}
\subsubsection{Notation}
We work in Cubical Type Theory \cite{cohenCubicalTypeTheory2016}.
For the various type formers we use the following notation:
\begin{description}
  \item[Type] We use \(\mathbf{Type}\) to denote the universe of (small) types.
    ``Type families'' are functions into \(\mathbf{Type}\).
  \item[0 , 1 , 2] We call the \(\mathbf{0}\), \(\mathbf{1}\), and
    \(\mathbf{2}\) types \(\bot\), \(\top\), and \(\mathbf{Bool}\) respectively.
    The single inhabitant of \(\top\) is tt, and the two inhabitants of
    \(\mathbf{Bool}\) are false and true.
    The ``negation'' of a type, written \(\neg A\), means \(A \rightarrow
    \bot\).
  \item[Dependent Sum and Product] We use \(\Sigma\) and \(\Pi\) for the
    dependent sum and product, respectively.
    The two projections from \(\Sigma\) are called fst and snd.
    In the non-dependent case, \(\Sigma\) can be written as \(\times\), and
    \(\Pi\) as \(\rightarrow\).
  \item[Disjoint Union] We define disjoint union as an inductive type.
    \begin{equation}
      \begin{alignedat}{3}
        A \uplus B \coloneqq & \;
        \text{inl} &: A \rightarrow A \uplus B ; \\
        | & \;  \text{inr} &: B \rightarrow A \uplus B ;
      \end{alignedat}
    \end{equation}
    It is also expressible with only \(\Sigma\):
    \(A \uplus B \simeq \Sigma(x : \mathbf{Bool}) , \text{if } x \text{ then
    } A \text{ else } B \).
  \item[Equalities, equivalences, and paths] We use the symbol \(\coloneqq\)
    for definitions.
    \(\simeq\) will be used for equivalences, and \(\equiv\) for equalities.
    Of course, we know that \((A \simeq B) \simeq (A \equiv B)\) by univalence,
    so the distinction isn't terribly important in usage: we will only use one
    or the other as a suggestion of how we constructed it or how it is to be
    used.
  \item[Lambdas] \todo{Figure out how to describe lambdas}
\end{description}
\subsubsection{Cubical Type Theory}
Cubical Type Theory \cite{cohenCubicalTypeTheory2016} is a constructive type
theory with an implementation in Cubical Agda
\cite{vezzosiCubicalAgdaDependently2019}.
It allows us to do much of the same theory as in HoTT, but crucially the
univalence ``axiom'' is a \emph{theorem}, giving it computational content.
\begin{definition}[Path Types] \label{path-types}
  The equality type (which we denote with \(\equiv\)) in CuTT is the type of
  Paths\footnotemark.
  The internal structure of paths is largely irrelevant to us here, as we will
  generally treat \(\equiv\) as a black-box equivalence relation with
  substitution and congruence.
\end{definition}

\footnotetext{
  Actually, CuTT does have an identity type with similar semantics to the
  identity type in MLTT.
  We do not use this type anywhere in our work, however, so we will not consider
  it here.
}
\begin{definition}[Homotopy Levels] \label{homotopy-types}
  Types in HoTT and CuTT are not necessarily sets, as they are in MLTT.
  Some have higher homotopies (paths which aren't unique).
  We actually have a hierarchy of complexity of structure of path spaces in
  types, starting with the contractions \cite[definition 3.11.1]{hottbook}, then
  the mere propositions \cite[definition 3.3.1]{hottbook}, and the sets
  \cite[definition 3.1.1]{hottbook}.
  \begin{alignat}{2}
    &\text{isContr}(A)    &&\coloneqq \Sigma(x : A) , \Pi(y : A) , (x \equiv y) \\
    &\text{isProp}(A)     &&\coloneqq \Pi(x, y : A) , (x \equiv y) \\
    &\text{isSet}(A)      &&\coloneqq \Pi(x, y : A) , \text{isProp}(x \equiv y)
  \end{alignat}
\end{definition}
\begin{definition}[Fibres] \label{fibres}
  A fibre \cite[definition 4.2.4]{hottbook} is defined over some function \(f :
  A \rightarrow B\).
  \begin{equation}
    \text{fib}_f(y) \coloneqq \Sigma(x : A) , (f (x) \equiv y)
  \end{equation}
\end{definition}
\begin{definition}[Equivalences] \label{equivalences}
  We will take contractible maps \cite[definition 4.4.1]{hottbook} as our
  ``default'' definition of equivalences.
  \begin{alignat}{2}
    &\text{isEquiv}(f) &&\coloneqq \Pi(y : B) , \text{isContr}(\text{fib}_f(y)) \label{is-equiv-def} \\
    &A \simeq B        &&\coloneqq \Sigma(f : A \rightarrow B) , \text{isEquiv}(f) \label{equiv-def}
  \end{alignat}
\end{definition}
\begin{definition}[Decidable Types]
  \begin{equation}
    \mathbf{Dec}(A) \coloneqq A \uplus \neg A
  \end{equation}
\end{definition}
\begin{definition}[Discrete Types]
  A discrete type is one with decidable equality.
  \begin{equation}
    \text{Discrete}(A) \coloneqq \Pi(x, y : A) , \mathbf{Dec}(x \equiv y)
  \end{equation}
  By Hedberg's theorem \cite{hedbergCoherenceTheoremMartinLof1998} any discrete
  type is a set.
\end{definition}
\begin{definition}[Higher Inductive Types] \label{HITs}
  Normal inductive types have \emph{point} constructors: constructors which
  construct values of the type.
  Higher Inductive Types (HITs) also have \emph{path} constructors: ways to
  construct paths in the type.
\end{definition}
\begin{definition}[Propositional Truncation] \label{prop-trunc}
  The type \(\lVert A \rVert\) on some type \(A\) is a propositionally truncated
  proof of \(A\) \cite[3.7]{hottbook}.
  In other words, it is a proof that some \(A\) exists, but it does not tell you
  \emph{which} \(A\).

  It is defined as a Higher Inductive Type:
  \begin{equation} {
    \begin{alignedat}{3}
      \lVert A \rVert \coloneqq & \; \lvert \wc \rvert &:& \; A \rightarrow \lVert A \rVert ; \\
                              | & \; \text{squash}     &:& \; \Pi {(x, y : \lVert A \rVert)} , x \equiv y  ; 
    \end{alignedat} }
  \end{equation}
  We will use two eliminators from \(\lVert A \rVert\) in this paper.
  \begin{enumerate}
  \item \label{elim-prop-prop} For any function \(A \rightarrow B\), where
    \(\text{isProp}(B)\), we have a function \(\lVert A \rVert \rightarrow B\).
  \item \label{elim-prop-coh} We can eliminate from \(\lVert A \rVert\) with a
    function \(f : A \rightarrow B\) iff \(f\) ``doesn't care'' about the
    choice of \(A\):
    \[\Pi {(x , y : A)} , f(x) \equiv f(y) \]
    Formally speaking, \(f\) needs to be ``coherently constant''
    \cite{krausGeneralUniversalProperty2015}, and \(B\) needs to be an
    \(n\)-type for some finite \(n\).
  \end{enumerate}
\end{definition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: