\chapter{Introduction}
\section{Foreword}
\todo[inline]{Foreword}
\section{Contributions}
We are interested in constructive notions of finiteness, formalised in Cubical
Type Theory \cite{cohenCubicalTypeTheory2016}.
In this paper we will explore five such notions of finiteness, including their
categorical interpretation, and use them to build a simple proof-search library
facilitated in a fundamental way by univalence.
Along the way we will use the Countdown problem
\cite{huttonCountdownProblem2002} as an example, and provide a program which
produces verified solutions to the puzzle.
We will also briefly examine countability, and demonstrate its parallels and
differences with finiteness.
\subsection{The Varieties of Finiteness}
In Section~\ref{finiteness-predicates} we will explore a number of different
predicates for finiteness.
In contrast to classical finiteness, in a constructive setting there is a wide
variety of predicates which all have some claim to being the formal
interpretation of ``finiteness'' \cite{coquandConstructivelyFinite2010}.
The particular predicates we are interested in are organised in
Figure~\ref{finite-classification}: each arrow in the diagram represents a proof
that one predicate can be derived from another.

\input{figures/finite-classification}

These finiteness predicates differ along two main axes: informativeness, and
restrictiveness.
More ``informative'' predicates have proofs which contain extraneous information
other than the finiteness of the underlying type: a proof of split enumerability
(Section~\ref{split-enumerability}), for instance, comes with a strict total
order on the underlying type.
We will prove that a more informative finiteness predicate can be
derived from a less informative one by providing the missing information
(Theorem~\ref{cardinal-to-manifest-bishop}).

The ``restrictiveness'' of a predicate refers to how many types it admits into
its notion of ``finite''.
There are strictly more Kuratowski finite (Section~\ref{kuratowski}) types than
there are Cardinally finite (Section~\ref{cardinal-finiteness}).
We will prove that we can always derive the less restrictive predicate from the
more restrictive one, and that we can go in the other direction by satisfying
the missing requirement (decidable equality in all of these cases).

Proofs coming with extra information is a common theme in constructive
mathematics: often this extra information is in the form of an algorithm which
can do something useful related to the proof itself.
Indeed, our proofs of finiteness here will provide an algorithm to solve the
countdown puzzle.
Occasionally, however, the extra information is undesirable: we may want to
assert the existence of some value \(x : A\) which satisfies a predicate \(P\)
without revealing \emph{which} \(A\) we're referring to.
More concretely, we will need in this paper to prove that two types are in
bijection without specifying a particular bijection.
This facility is provided by Homotopy Type Theory \cite{hottbook} in the form of
propositional truncation, and it is what allows us to prove the bulk of
propositions in this paper.

For each predicate we will also prove its closure properties (i.e. that the
product of two finite sets is finite).
The most significant of these closure proofs is that of closure under \(\Pi\)
(dependent functions) (Theorem~\ref{split-enum-pi}).
\subsection{Toposes and Finite Sets}
In Section~\ref{topos}, we will explore the categorical interpretation of
decidable Kuratowski finite sets.
The motivation here is partially a practical one: by the end of this work we
will have provided a library for proof search over finite types, and the
``language'' of a topos is a reasonable choice for a principled language for
constructing proofs of finiteness in the style of QuickCheck
\cite{claessenQuickCheckLightweightTool2011} generators.

Theoretically speaking, showing that sets in Homotopy Type Theory form a topos
(with some caveats) is an important step in characterising the categorical
implications of Homotopy Type Theory, first proven in
\cite{rijkeSetsHomotopyType2015}.
Our work is a formalisation of this result (and the first such formalisation
that we are aware of).
The proof that decidable Kuratowski finite sets form a \(\Pi\)-pretopos is
additional to that.
\subsection{Countability Predicates}
After the finite predicates, we will briefly look at the infinite countable
types, and classify them in a parallel way to the finite predicates
(Section~\ref{infinite}).
We will see that we lose closure under function arrows, but we gain it under the
Kleene star (Theorem~\ref{split-countability-sigma}).
\subsection{Search}
All of our work is formalised in Cubical Agda
\cite{vezzosiCubicalAgdaDependently2019}: as a result, the constructive
interpretation of each proof is actually a program which can be run on a
computer.
In finiteness in particular, these programs are particularly useful for
exhaustive search.

We will use the countdown problem as a running example throughout the paper: we
will show how to prove that any given puzzle has a finite number of solutions,
and from that we will show how to enumerate those solutions, thereby solving the
puzzle in a verified way.

In Section~\ref{search} we will package up the ``search'' aspect of finiteness
into a library for proof search: similar libraries have been built in
\cite{fruminFiniteSetsHomotopy2018} and
\cite{firsovDependentlyTypedProgramming2015}.
Our library differs from those in three important ways: firstly, it is strictly
more powerful, as it allows for search over function types.
Secondly, finiteness proofs also provide equivalence proofs to any other finite
type: this allows transport of proofs between types of the same cardinality.
Finally, through generic programming we provide a simple syntax for stating
properties which mimics that of QuickCheck.
We also ground the library in the theoretical notions of omniscience.
\section{Countdown}
Countdown is a well-known functional programming puzzle (later turned into a TV
show in the UK), first popularised as a puzzle in which to demonstrate
functional algorithms in \cite{huttonCountdownProblem2002}.
As a running example in this paper, we will produce a verified program which
lists all solutions to a given countdown puzzle: here we will briefly explain
the game and our strategy for solving it.

The idea behind countdown is simple: given a list of numbers, contestants must
construct an arithmetic expression (using a small set of functions) using some
or all of the numbers, to reach some target.
Here's an example puzzle:
\begin{gather*}
  \boxed{1} \boxed{3} \boxed{7} \boxed{10} \boxed{25} \boxed{50} \\
  \boxed{765} \tag{Target}
\end{gather*}
We'll allow the use of \(\times\), \(+\), and \(-\).
The answer is at the bottom of this page\footnotemark.

\footnotetext{\rotatebox[origin=c]{180}{Answer: \(3 \times (7 \times (50 - 10) - 25)\)}}

Our strategy for finding solutions to a given puzzle is to describe precisely
the type of solutions to a puzzle, and then show that that type is finite.
So what is a ``solution'' to a countdown puzzle?
Broadly, it has two parts:
\begin{description}
  \item[A Transformation] from a list of numbers to an expression.
  \item[A Predicate] showing that the expression is valid and evaluates to the
    target.
\end{description}
The first part is described in Figure~\ref{countdown-transform}.

\input{figures/countdown-transformation}

This transformation has four steps.
First (Fig.~\ref{countdown-selection}) we have to pick which numbers we include
in our solution.
The representation of this transformation should be fairly simple: to pick from
\(n\) objects we can have an \(n\)-tuple of booleans.

Secondly (Fig.~\ref{countdown-permutation}) we have to permute the chosen
numbers.
The representation for a permutation is a little trickier to envision: proving
that it's finite is trickier still.
We will need to rely on some of the more involved lemmas later on for this
problem.

The third step (Fig.~\ref{countdown-operators}) is quite like the first: it's
just another \(n\)-tuple of finite objects (in this case operators chosen from
\(+\), \(\times\), \(-\), and \(\div\)).
Although it is complicated slightly by the fact that the \(n\) in this
\(n\)-tuple is dependent on the number of trues in the previously chosen tuple
of booleans (in terms of types, that means we'll need a \(\Sigma\) rather than a
\(\times\), explanations of which are forthcoming).

Finally (Fig.~\ref{countdown-parens}), we have to parenthesise the expression in
a certain way.
This can be encapsulated by a binary tree with a certain number of leaves:
proving that that is finite is tricky again.

Once we have proven that there are finitely many transformations for a list of
numbers, we will then have to filter them down to those transformations which
are valid, and evaluate to the target.
This amounts to proving that the decidable subset of a finite set is also
finite.

Finally, we will also want to optimise our solutions and solver: for this we
will remove equivalent expressions, which can be accomplished with quotients.
\section{Notation and Background}
We work in Cubical Type Theory \cite{cohenCubicalTypeTheory2016}, specifically
Cubical Agda \cite{vezzosiCubicalAgdaDependently2019}.
Cubical Agda is a dependently-typed functional programming language, based on
Martin-LÃ¶f Intuitionistic Type Theory, with a Haskell-like syntax.

Being a dependently-typed language, we'll have to be clear about what we mean
when we say ``type'' in Agda.
\begin{definition}[Type]
  We use \(\AgdaDatatype{Type}\) to denote the universe of (small) types.
  The universe level is denoted with a subscript number, starting at 0.
  ``Type families'' are functions into \(\AgdaDatatype{Type}\).
\end{definition}

The are two broad ways to define types in Agda: as an inductive
\(\AgdaKeyword{data}\) type, similar to data type definitions in Haskell, or as
a \(\AgdaKeyword{record}\).
Here we'll define the basic type formers used in MLTT.
\begin{definition}[Basic Types]
  The three basic types---often called 0, 1, and 2 in MLTT---here will be
  denoted with their more common names: \(\bot\), \(\top\), and
  \(\mathbf{Bool}\), respectively.
  \begin{multicols}{3} \centering
    \begin{agdalisting}
      \ExecuteMetaData[agda/Snippets/Introduction.tex]{bot}
    \end{agdalisting}

    \begin{agdalisting}
      \ExecuteMetaData[agda/Snippets/Introduction.tex]{top}
    \end{agdalisting}

    \begin{agdalisting}
      \ExecuteMetaData[agda/Snippets/Introduction.tex]{bool}
    \end{agdalisting}
  \end{multicols}
\end{definition}
\begin{definition}[The Dependent Sum]
  Dependent sums are denoted with the usual \(\Sigma\) symbol, and has the
  following definition in Agda:

  \begin{center}
    \begin{agdalisting}
      \ExecuteMetaData[agda/Snippets/Introduction.tex]{sigma}
    \end{agdalisting}
  \end{center}
  We will use different notations to refer to this type depending on the
  setting.
  The following four expressions all denote the same type:

  \begin{multicols}{4} \centering
    \begin{agdalisting}
      \ExecuteMetaData[agda/Snippets/Introduction.tex]{sigma-syntax-1}
    \end{agdalisting}

    \begin{agdalisting}
      \ExecuteMetaData[agda/Snippets/Introduction.tex]{sigma-syntax-2}
    \end{agdalisting}

    \begin{agdalisting}
      \ExecuteMetaData[agda/Snippets/Introduction.tex]{sigma-syntax-3}
    \end{agdalisting}

    \begin{agdalisting}
      \ExecuteMetaData[agda/Snippets/Introduction.tex]{sigma-syntax-4}
    \end{agdalisting}
  \end{multicols}

  The non-dependent product is a special instance of the dependent.
  We indicate a simple pair of types \(A\) and \(B\) as \(A \times B\).
\end{definition}
\begin{definition}[Dependent Product]
  Dependent products (dependent functions) use the \(\Pi\) symbol.

  The three following expressions all denote the same type:

  \begin{multicols}{3}
    \begin{agdalisting}
      \ExecuteMetaData[agda/Snippets/Introduction.tex]{pi-syntax-1}
    \end{agdalisting}

    \begin{agdalisting}
      \ExecuteMetaData[agda/Snippets/Introduction.tex]{pi-syntax-2}
    \end{agdalisting}

    \begin{agdalisting}
      \ExecuteMetaData[agda/Snippets/Introduction.tex]{pi-syntax-3}
    \end{agdalisting}
  \end{multicols}

  Again, the non-dependent case is a special case of the dependent case.
  Non-dependent functions are denoted with the arrow (\(\rightarrow\)).
\end{definition}

\begin{definition}[Disjoint Union]
  We define disjoint union as an inductive type.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Introduction.tex]{disj-union}
  \end{agdalisting}
  It is also expressible with only \(\Sigma\):
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Introduction.tex]{sigma-disj-union}
  \end{agdalisting}
\end{definition}
\begin{definition}[Equalities, equivalences, and paths] We use the symbol \(\coloneqq\)
  for definitions.
  \(\simeq\) will be used for equivalences, and \(\equiv\) for equalities.
  Of course, we know that \((A \simeq B) \simeq (A \equiv B)\) by univalence,
  so the distinction isn't terribly important in usage: we will only use one
  or the other as a suggestion of how we constructed it or how it is to be
  used.
\end{definition}

\begin{definition}[Path Types] \label{path-types}
  The equality type (which we denote with \(\equiv\)) in CuTT is the type of
  Paths\footnotemark.
  The internal structure of paths is largely irrelevant to us here, as we will
  generally treat \(\equiv\) as a black-box equivalence relation with
  substitution and congruence.
\end{definition}

\footnotetext{
  Actually, CuTT does have an identity type with similar semantics to the
  identity type in MLTT.
  We do not use this type anywhere in our work, however, so we will not consider
  it here.
}
\begin{definition}[Homotopy Levels] \label{homotopy-types}
  Types in HoTT and CuTT are not necessarily sets, as they are in MLTT.
  Some have higher homotopies (paths which aren't unique).
  We actually have a hierarchy of complexity of structure of path spaces in
  types, starting with the contractions \cite[definition 3.11.1]{hottbook}, then
  the mere propositions \cite[definition 3.3.1]{hottbook}, and the sets
  \cite[definition 3.1.1]{hottbook}.
  \begin{alignat}{2}
    &\text{isContr}(A)    &&\coloneqq \Sigma(x : A) , \Pi(y : A) , (x \equiv y) \\
    &\text{isProp}(A)     &&\coloneqq \Pi(x, y : A) , (x \equiv y) \\
    &\text{isSet}(A)      &&\coloneqq \Pi(x, y : A) , \text{isProp}(x \equiv y)
  \end{alignat}
\end{definition}
\begin{definition}[Fibres] \label{fibres}
  A fibre \cite[definition 4.2.4]{hottbook} is defined over some function \(f :
  A \rightarrow B\).
  \begin{equation}
    \text{fib}_f(y) \coloneqq \Sigma(x : A) , (f (x) \equiv y)
  \end{equation}
\end{definition}
\begin{definition}[Equivalences] \label{equivalences}
  We will take contractible maps \cite[definition 4.4.1]{hottbook} as our
  ``default'' definition of equivalences.
  \begin{alignat}{2}
    &\text{isEquiv}(f) &&\coloneqq \Pi(y : B) , \text{isContr}(\text{fib}_f(y)) \label{is-equiv-def} \\
    &A \simeq B        &&\coloneqq \Sigma(f : A \rightarrow B) , \text{isEquiv}(f) \label{equiv-def}
  \end{alignat}
\end{definition}
\begin{definition}[Decidable Types]
  \begin{equation}
    \mathbf{Dec}(A) \coloneqq A \uplus \neg A
  \end{equation}
\end{definition}
\begin{definition}[Discrete Types]
  A discrete type is one with decidable equality.
  \begin{equation}
    \text{Discrete}(A) \coloneqq \Pi(x, y : A) , \mathbf{Dec}(x \equiv y)
  \end{equation}
  By Hedberg's theorem \cite{hedbergCoherenceTheoremMartinLof1998} any discrete
  type is a set.
\end{definition}
\begin{definition}[Higher Inductive Types] \label{HITs}
  Normal inductive types have \emph{point} constructors: constructors which
  construct values of the type.
  Higher Inductive Types (HITs) also have \emph{path} constructors: ways to
  construct paths in the type.
\end{definition}
\begin{definition}[Propositional Truncation] \label{prop-trunc}
  The type \(\lVert A \rVert\) on some type \(A\) is a propositionally truncated
  proof of \(A\) \cite[3.7]{hottbook}.
  In other words, it is a proof that some \(A\) exists, but it does not tell you
  \emph{which} \(A\).

  It is defined as a Higher Inductive Type:
  \begin{equation} {
    \begin{alignedat}{3}
      \lVert A \rVert \coloneqq & \; \lvert \wc \rvert &:& \; A \rightarrow \lVert A \rVert ; \\
                              | & \; \text{squash}     &:& \; \Pi {(x, y : \lVert A \rVert)} , x \equiv y  ; 
    \end{alignedat} }
  \end{equation}
  We will use two eliminators from \(\lVert A \rVert\) in this paper.
  \begin{enumerate}
  \item \label{elim-prop-prop} For any function \(A \rightarrow B\), where
    \(\text{isProp}(B)\), we have a function \(\lVert A \rVert \rightarrow B\).
  \item \label{elim-prop-coh} We can eliminate from \(\lVert A \rVert\) with a
    function \(f : A \rightarrow B\) iff \(f\) ``doesn't care'' about the
    choice of \(A\):
    \[\Pi {(x , y : A)} , f(x) \equiv f(y) \]
    Formally speaking, \(f\) needs to be ``coherently constant''
    \cite{krausGeneralUniversalProperty2015}, and \(B\) needs to be an
    \(n\)-type for some finite \(n\).
  \end{enumerate}
\end{definition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: