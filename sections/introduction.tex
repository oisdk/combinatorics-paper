\chapter{Introduction}
\section{Foreword}
\todo[inline]{Foreword}
\section{Contributions}
We are interested in constructive notions of finiteness, formalised in Cubical
Type Theory.
In contrast to classical finiteness, in a constructive setting there is a wide
variety of predicates which all have some claim to being the formal
interpretation of ``finiteness''.
Broadly, they vary along two axes: informativeness (i.e. how many properties
of the underlying type we can derive from a proof that it is finite), and
restrictiveness (i.e. how many types conform to its particular variety of
finiteness).
We will explore five of these predicates, proving formally their relations and
implications.

\input{figures/finite-classification}

We will then focus on one of the predicates: decidable Kuratowski finiteness.
We will construct a category of decidable Kuratowski-finite types, and show that
it forms a \(\Pi\)-pretopos.

We will then take a brief detour into predicates for countably infinite types,
and compare its landscape to that of the finite predicates.

Finally, we will present a case-study in a practical application of the
predicates for finiteness we have constructed: a library for total proof search.
We will show how our earlier work gives a good theoretical foundation for this
library, and allows for a simple and principled API, and we will demonstrate how
some of the more complex theoretical results allow for a more powerful library
with capabilities not seen in comparable proof search libraries.


\subsection{Finiteness Predicates}
Our first contribution is a cataloguing and characterisation of five finiteness
predicates, shown in figure~\ref{finite-classification}.

While our focus is decidable Kuratowski finiteness, in order to prove the
closure properties that we are interested in we will need to work with the
intermediate predicates as well (though they are also interesting in their own
right).

Since we have a proof-search library in mind, we will have to consider how to
present a good API for constructing proofs of finiteness.
In this vein we will show that some simple base types are finite
(\(\mathbf{Bool}\), \(\top\), \(\bot\), etc), and we will provide functions to
combine finiteness proofs together into more complex types (i.e. \(\times\),
\(\uplus\), \(\Sigma\), \(\Pi\), etc).
As we will see this choice of toolbox for building finiteness proofs actually
has a deep categorical justification, but at this point it makes sense to look
at it as just a suitably general and powerful API.



Our focus in this work is decidable Kuratowski finiteness.
We will characterise it, its strength, and its uses, and in particular we will
show that it forms a \(\Pi\)-pretopos.
Our proofs follow the structure of \cite[Chapters 9, 10]{hottbook} and
\cite{rijkeSetsHomotopyType2015}.
We will explore this concept in more detail later, but crucially we will need to
provide proofs of closure under \(\times\), \(\rightarrow\), etc.

In order to prove these closure properties, we will define and use some
intermediate finiteness predicates, classified in
figure~\ref{finite-classification}.
These predicates are also interesting in their own right, though!

The arrows in figure~\ref{finite-classification} are implication functions
between each predicate.
We will provide a function which inhabits each arrow.
Each unlabelled arrow is an unconditional implication: every manifest Bishop
finite set is cardinal finite (lemma~\ref{manifest-bishop-to-cardinal}), for
instance.
The labelled arrows are strengthening proofs: every manifest enumerable set
\emph{with decidable equality} is split enumerable
(lemma~\ref{manifest-enum-to-split-enum}).
Our most significant result here is the proof that a cardinal finite set with a
decidable total order is manifestly Bishop finite.

\subsection{Countability Predicates}
After the finite predicates, we will briefly look at the infinite countable
types, and classify them in a parallel way to the finite predicates
(section~\ref{infinite}).
\subsection{Search}
All of our work is formalised in Cubical Agda
\cite{vezzosiCubicalAgdaDependently2019}.
We will make mention of the few occasions where the formalisation of some proof
is of interest, but the main place where we will discuss the code is in
section~\ref{search}, where we implement a library for proof search, based on
omniscience and exhaustibility.
This library relies directly on the computational content of univalence, which
allows us to (for instance) have \(\Pi\) types in the domain of the search
space.
The language of a \(\Pi\)-pretopos turns out to be exactly the right language
for constructing ``generator''-like expressions.

The full code of the formalisation is available at
\url{https://github.com/oisdk/finiteness-in-cubical-type-theory}.
\section{Notation and Background}
\subsection{Notation}
We work in Cubical Type Theory \cite{cohenCubicalTypeTheory2016}.
For the various type formers we use the following notation:
\begin{description}
  \item[Type] We use \(\mathbf{Type}\) to denote the universe of (small) types.
    ``Type families'' are functions into \(\mathbf{Type}\).
  \item[0 , 1 , 2] We call the \(\mathbf{0}\), \(\mathbf{1}\), and
    \(\mathbf{2}\) types \(\bot\), \(\top\), and \(\mathbf{Bool}\) respectively.
    The single inhabitant of \(\top\) is tt, and the two inhabitants of
    \(\mathbf{Bool}\) are false and true.
    The ``negation'' of a type, written \(\neg A\), means \(A \rightarrow
    \bot\).
  \item[Dependent Sum and Product] We use \(\Sigma\) and \(\Pi\) for the
    dependent sum and product, respectively.
    The two projections from \(\Sigma\) are called fst and snd.
    In the non-dependent case, \(\Sigma\) can be written as \(\times\), and
    \(\Pi\) as \(\rightarrow\).
  \item[Disjoint Union] We define disjoint union as an inductive type.
    \begin{equation}
      \begin{alignedat}{3}
        A \uplus B \coloneqq & \;
        \text{inl} &: A \rightarrow A \uplus B ; \\
        | & \;  \text{inr} &: B \rightarrow A \uplus B ;
      \end{alignedat}
    \end{equation}
    It is also expressible with only \(\Sigma\):
    \(A \uplus B \simeq \Sigma(x : \mathbf{Bool}) , \text{if } x \text{ then
    } A \text{ else } B \).
  \item[Equalities, equivalences, and paths] We use the symbol \(\coloneqq\)
    for definitions.
    \(\simeq\) will be used for equivalences, and \(\equiv\) for equalities.
    Of course, we know that \((A \simeq B) \simeq (A \equiv B)\) by univalence,
    so the distinction isn't terribly important in usage: we will only use one
    or the other as a suggestion of how we constructed it or how it is to be
    used.
  \item[Lambdas] \todo{Figure out how to describe lambdas}
\end{description}
\subsection{Cubical Type Theory}
Cubical Type Theory \cite{cohenCubicalTypeTheory2016} is a constructive type
theory with an implementation in Cubical Agda
\cite{vezzosiCubicalAgdaDependently2019}.
It allows us to do much of the same theory as in HoTT, but crucially the
univalence ``axiom'' is a \emph{theorem}, giving it computational content.
\begin{definition}[Path Types] \label{path-types}
  The equality type (which we denote with \(\equiv\)) in CuTT is the type of
  Paths\footnotemark.
  The internal structure of paths is largely irrelevant to us here, as we will
  generally treat \(\equiv\) as a black-box equivalence relation with
  substitution and congruence.
\end{definition}

\footnotetext{
  Actually, CuTT does have an identity type with similar semantics to the
  identity type in MLTT.
  We do not use this type anywhere in our work, however, so we will not consider
  it here.
}
\begin{definition}[Homotopy Levels] \label{homotopy-types}
  Types in HoTT and CuTT are not necessarily sets, as they are in MLTT.
  Some have higher homotopies (paths which aren't unique).
  We actually have a hierarchy of complexity of structure of path spaces in
  types, starting with the contractions \cite[definition 3.11.1]{hottbook}, then
  the mere propositions \cite[definition 3.3.1]{hottbook}, and the sets
  \cite[definition 3.1.1]{hottbook}.
  \begin{alignat}{2}
    &\text{isContr}(A)    &&\coloneqq \Sigma(x : A) , \Pi(y : A) , (x \equiv y) \\
    &\text{isProp}(A)     &&\coloneqq \Pi(x, y : A) , (x \equiv y) \\
    &\text{isSet}(A)      &&\coloneqq \Pi(x, y : A) , \text{isProp}(x \equiv y)
  \end{alignat}
\end{definition}
\begin{definition}[Fibres] \label{fibres}
  A fibre \cite[definition 4.2.4]{hottbook} is defined over some function \(f :
  A \rightarrow B\).
  \begin{equation}
    \text{fib}_f(y) \coloneqq \Sigma(x : A) , (f (x) \equiv y)
  \end{equation}
\end{definition}
\begin{definition}[Equivalences] \label{equivalences}
  We will take contractible maps \cite[definition 4.4.1]{hottbook} as our
  ``default'' definition of equivalences.
  \begin{alignat}{2}
    &\text{isEquiv}(f) &&\coloneqq \Pi(y : B) , \text{isContr}(\text{fib}_f(y)) \label{is-equiv-def} \\
    &A \simeq B        &&\coloneqq \Sigma(f : A \rightarrow B) , \text{isEquiv}(f) \label{equiv-def}
  \end{alignat}
\end{definition}
\begin{definition}[Decidable Types]
  \begin{equation}
    \mathbf{Dec}(A) \coloneqq A \uplus \neg A
  \end{equation}
\end{definition}
\begin{definition}[Discrete Types]
  A discrete type is one with decidable equality.
  \begin{equation}
    \text{Discrete}(A) \coloneqq \Pi(x, y : A) , \mathbf{Dec}(x \equiv y)
  \end{equation}
  By Hedberg's theorem \cite{hedbergCoherenceTheoremMartinLof1998} any discrete
  type is a set.
\end{definition}
\begin{definition}[Higher Inductive Types] \label{HITs}
  Normal inductive types have \emph{point} constructors: constructors which
  construct values of the type.
  Higher Inductive Types (HITs) also have \emph{path} constructors: ways to
  construct paths in the type.
\end{definition}
\begin{definition}[Propositional Truncation] \label{prop-trunc}
  The type \(\lVert A \rVert\) on some type \(A\) is a propositionally truncated
  proof of \(A\) \cite[3.7]{hottbook}.
  In other words, it is a proof that some \(A\) exists, but it does not tell you
  \emph{which} \(A\).

  It is defined as a Higher Inductive Type:
  \begin{equation} {
    \begin{alignedat}{3}
      \lVert A \rVert \coloneqq & \; \lvert \wc \rvert &:& \; A \rightarrow \lVert A \rVert ; \\
                              | & \; \text{squash}     &:& \; \Pi {(x, y : \lVert A \rVert)} , x \equiv y  ; 
    \end{alignedat} }
  \end{equation}
  We will use two eliminators from \(\lVert A \rVert\) in this paper.
  \begin{enumerate}
  \item \label{elim-prop-prop} For any function \(A \rightarrow B\), where
    \(\text{isProp}(B)\), we have a function \(\lVert A \rVert \rightarrow B\).
  \item \label{elim-prop-coh} We can eliminate from \(\lVert A \rVert\) with a
    function \(f : A \rightarrow B\) iff \(f\) ``doesn't care'' about the
    choice of \(A\):
    \[\Pi {(x , y : A)} , f(x) \equiv f(y) \]
    Formally speaking, \(f\) needs to be ``coherently constant''
    \cite{krausGeneralUniversalProperty2015}, and \(B\) needs to be an
    \(n\)-type for some finite \(n\).
  \end{enumerate}
\end{definition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: