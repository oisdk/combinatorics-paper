\chapter{Finiteness Predicates} \label{finiteness-predicates}
In this section, we will define and briefly describe each of the five predicates
in Figure~\ref{finite-classification}.
We will also explain \emph{why} there are five separate predicates: how can it
be the case that so many different things describe ``finiteness''?
As we will see, some predicates are too informative (they
tell us more about the underlying type other than it just being finite), or too
restrictive (they don't allow certain finite types to be classified as finite).
These diversions won't be dead-ends, however: the final predicate we will land
on as the ``correct'' (or, more accurately, most useful) notion of finiteness
will be built out of all of the others.
\section{Split Enumerability} \label{split-enumerability}
We will start with a simple notion of finiteness, called split enumerability.
This predicate is perhaps the first definition of ``finite'' that someone might
come up with (it's certainly the most common in dependently-typed programming):
put simply, a split enumerable type is a type for which all of its elements can
be listed.
\begin{definition}[Split Enumerable Set] \label{split-enum-def}
  To say that some type \(A\) is split enumerable is to say that there is a list
  \(\mathit{support} : \AgdaDatatype{List}(A)\) such that any value \(x : A\) is in
  \(\mathit{support}\).
  \begin{agdalisting} \label{split-enum-def-eqn}
    \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable/Container.tex]{split-enum-def}
  \end{agdalisting}
  We call the first component of this pair the ``support'' list, and the second
  component the ``cover'' proof.
  An equivalent version of this predicate was called \verb+Listable+ in
  \cite{firsovDependentlyTypedProgramming2015}.
\end{definition}

This predicate is simple and useful, but we will see later on how it is perhaps
a little imprecise.
Before we dive in to exploring the predicate itself, though, we will need to
explain some of the terms we used in its definition.
\subsection{What is a List?}
We have referred to \(\AgdaDatatype{List}\) in the definition of split
enumerability.
In this paper, the type of lists is defined like so:
\begin{agdalisting} \label{list-def}
  \ExecuteMetaData[agda/Container/List.tex]{list-def}
\end{agdalisting}
This is the definition for a \emph{container} (Definition~\ref{container-def}):
effectively, the above definition says that ``Lists are a datatype whose shape
is given by the natural numbers, and which can be indexed by numbers smaller
than its shape''.

If that seems needlessly complex, don't worry: this definition is precisely
equivalent to the usual inductive one. \todo{This reads a little too informal I think}
\begin{agdalisting}
  \ExecuteMetaData[agda/Data/List/Base.tex]{list-def}
\end{agdalisting}
And this isn't some kind of hand-waving equivalence, either: since we working in
HoTT, we can (and do) prove that the two types are equal, allowing us to use one
or the other depending on whichever is more convenient, and
\(\AgdaFunction{subst}\) in the other representation without loss of generality.
That said, defining lists as containers will reveal several interesting
connections and proofs about split enumerability and the other predicates, 
so for the remainder of the paper whenever we say \AgdaDatatype{List} we will
mean Equation~\ref{list-def}.

Before we get to those interesting proofs, though, there are some other things
that need defining.
\AgdaDatatype{Fin}, for instance: \(\AgdaDatatype{Fin}\;n\) is the type of
natural numbers smaller than \(n\).
Its definition relies on a type for disjoint union,
\(\AgdaDatatype{\ensuremath{\uplus}}\).
\begin{multicols}{2}
  \begin{agdalisting}
    \ExecuteMetaData[agda/Data/Fin/Base.tex]{fin-def}
  \end{agdalisting} \columnbreak
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Introduction.tex]{disj-union}
  \end{agdalisting}%
  % It is also expressible with only \(\Sigma\):
  % \begin{agdalisting}
  %   \ExecuteMetaData[agda/Snippets/Introduction.tex]{sigma-disj-union}
  % \end{agdalisting}
  % Although the inductive type definition is slightly more ergonomic.
\end{multicols} \noindent
And containers themselves, of course.
Containers are a well-studied topic in dependent type theory, with a rich
theory: we won't dive in to that here.
\begin{definition}[Containers] \label{container-def}
  A container \cite{abbottContainersConstructingStrictly2005} is a pair
  \(S , P\) where \(S\) is a type, the elements of which are called
  the \emph{shapes} of the container, and \(P\) is a type family on \(S\), where
  the elements of \(P(s)\) are called the \emph{positions} of a container.
  We ``interpret'' a container into a functor defined like so:
  \begin{agdalisting} \label{container-interp}
    \ExecuteMetaData[agda/Container.tex]{container-interp}
  \end{agdalisting}
\end{definition}

The definition of container is a little abstract: it is instructive to think of
it more concretely for the case of lists.
The container representing finite lists is a pair of a natural number \(n\)
representing the length (or ``shape'') of the list, and a function
\(\AgdaDatatype{Fin}\;n\to A\), representing the indexing function into the
list.

One of the nice things about containers is it gives us a generic way to define
``membership'':
\begin{multicols}{2}
  \begin{agdalisting} 
    \ExecuteMetaData[agda/Container/Membership.tex]{membership-def}
  \end{agdalisting} \columnbreak
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Introduction.tex]{fiber}
  \end{agdalisting}
\end{multicols} \noindent 
Here we're using the homotopy-theory notion of a \AgdaDatatype{fiber} to define
membership: a fiber for some function \(f\) and some point \(y\) in its codomain
is a value \(x\) and a proof that \(f \; x \;\AgdaDatatype{â‰¡}\;y\).
Membership also makes more sense when described concretely in terms of lists:
\(x\;\AgdaDatatype{\ensuremath{\in}}\;\mathit{xs}\) means ``there is an index
into \(\mathit{xs}\) such that the index points at an item equal to \(x\)''.
\subsection{Split Surjections}
We will now look at how this predicate relates to more traditional, classical
notions of finiteness.
In a classical setting we likely wouldn't mention ``lists'' or the like, and
would instead define finiteness based on the existence of some injection or
surjection.
As it turns out, our definition of finiteness here is precisely the same as the
surjection-based one, in quite a deep way!

First, we will need to define our terms: in HoTT, surjections are a little more
complex than what you'd find in either MLTT or classical mathematics.
\begin{definition}[Split Surjections] \label{split-surjections}
  We define \emph{split} surjections here \cite[definition
  4.6.1]{hottbook}.
  \begin{agdalisting} \label{sp-surj-eqn}
    \ExecuteMetaData[agda/Function/Surjective/Base.tex]{split-surjective}
  \end{agdalisting} \vspace{-1.5\baselineskip}
  \begin{agdalisting} \label{sp-surj-arrow-eqn}
    \ExecuteMetaData[agda/Function/Surjective/Base.tex]{split-surjection}
  \end{agdalisting}
\end{definition}
Over sets, the surjections and split surjections are the same thing, but there
is a difference one we involve non-set types like the circle.

We will now see that split enumerability is in fact a split surjection in
another form:
\begin{lemma} \label{split-enum-is-split-surj}%
  A proof of split enumerability is equivalent to a split surjection from a
  finite prefix of the natural numbers.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{is-split-inj-type}
  \end{agdalisting}
\end{lemma}
\begin{proof} \let\qed\relax \vspace{-1\baselineskip}
  \begin{minipage}[t]{.7\textwidth}\vspace{-\baselineskip}
    \begin{agdalisting*}
      \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{is-split-inj}
    \end{agdalisting*}
  \end{minipage}
  \begin{minipage}[t]{.19\textwidth} \setstretch{1.1}

      Def.~\ref{split-enum-def} (\AgdaDatatype{\ensuremath{\mathcal{E}!}}) \\
      Eqn.~\ref{container-membership} (\AgdaDatatype{\ensuremath{\in}}) \\
      Eqn.~\ref{sp-surj-eqn}  \\
      Def.~\ref{List} (\(\AgdaDatatype{List}\)) \\
      Eqn.~\ref{container-interp}  \\
      Reassociation \\
      Eqn.~\ref{sp-surj-arrow-eqn}
  \end{minipage}
\end{proof}
In the above proof syntax the
\(\AgdaDatatype{\ensuremath{\equiv \langle{} \rangle{} }}\) connects lines which
are definitionally equal, i.e. they are ``obviously'' equal from the type
checker's perspective.
Clearly, only one line isn't a definitional equality: 
\begin{agdalisting}
  \ExecuteMetaData[agda/Data/Sigma/Properties.tex]{reassoc}
\end{agdalisting}
(The simplicity of this proof, by the way, is why we preferred the
container-based definition of lists over the traditional one.)
\subsection{Instances} \todo{More intro to this}
We will now provide some example proofs of types which are split enumerable.
\begin{lemma}
  \(\bot\), \(\top\), and \(\AgdaDatatype{Bool}\) are split enumerable.
\end{lemma}
\begin{proof}
  These three types are quite obviously finite: we will show only the proof of
  finiteness for \(\AgdaDatatype{Bool}\) here for brevity's sake.
  \begin{agdalisting} \label{bool-is-split-enumerable}
    \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{bool-inst}
  \end{agdalisting}
\end{proof}

As a slightly more complex example, consider the \(\AgdaDatatype{Fin}\) type
we've been using.
Remember that split enumerability is in fact the same as a split surjection from
\(\AgdaDatatype{Fin}\) (Lemma~\ref{split-enum-is-split-surj}): to show that
\(\AgdaDatatype{Fin}\) is split enumerable, then, we need only show that it has
a split surjection from itself.
We'll prove the following slightly more general statement:
\begin{lemma}
  Every type has a split surjection into itself: the identity function.
\end{lemma}
\begin{proof}
  We provide the simple proof here in Agda:
  \begin{agdalisting}
    \ExecuteMetaData[agda/Function/Surjective/Properties.tex]{split-surj-ident}
  \end{agdalisting}
\end{proof}
\subsection{Decidable Equality}
One thing that characterises all split enumerable types is that they are all
\emph{discrete}.
We will see later that this has implications for the space of types we're
dealing with, but for now it simply provides a useful function on split
enumerable types.
\begin{definition}[Discrete Types]
  A discrete type is one with decidable equality.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Relation/Nullary/Discrete/Base.tex]{discrete-def}
  \end{agdalisting}
\end{definition}
Of course we also will need to explain what we mean by ``decidable''.
\begin{definition}[Decidable Types]
  If some proposition is decidable it means that it is proven true or false.
  We can encapsulate this with a data type\footnotemark:
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Dec.tex]{dec-def}
  \end{agdalisting}
  A proof of type \(\AgdaDatatype{Dec}\;A\) is a proof that \(A\) is either true
  or false.
\end{definition}
\footnotetext{This is not, as it happens, the definition of
  \(\AgdaDatatype{Dec}\) you will find in Agda's standard library.
The version of the type that exists there is a good deal more complicated (for
computational reasons),
although its interface behaves}

So now we have our task in focus: we need to prove that split enumerability
implies decidable equality.
We will do that by first describing split enumerability in terms of injections.
\todo{This proof could be presented a lot better, I think}
\begin{definition}[Injections]
  Injective functions are more straightforward to define constructively than
  surjective ones:
  \begin{agdalisting}
    \ExecuteMetaData[agda/Function/Injective/Base.tex]{injective}
  \end{agdalisting} \vspace{-1.5\baselineskip}
  \begin{agdalisting}
    \ExecuteMetaData[agda/Function/Injective/Base.tex]{injection}
  \end{agdalisting}
\end{definition}
\begin{lemma} \label{split-surj-to-inj}
  A split-surjection from \(A\) to \(B\) implies an injection from \(B\) to
  \(A\).
  \begin{agdalisting}
    \ExecuteMetaData[agda/Function/Surjective/Properties.tex]{surj-to-inj}
  \end{agdalisting}
\end{lemma}
\begin{proof} \let\qed\relax

  \begin{minipage}[t]{.9\textwidth}\vspace{-\baselineskip}
    \begin{agdalisting*}
      \ExecuteMetaData[agda/Function/Surjective/Properties.tex]{surj-to-inj-proof}
    \end{agdalisting*}
  \end{minipage}
\end{proof}
\begin{lemma} \label{inj-discrete}
  For any type \(A\) which injects into a discrete type \(B\), \(A\) is
  discrete.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Function/Injective/Properties.tex]{inj-discrete}
  \end{agdalisting}
\end{lemma}

\begin{lemma} \label{discrete-surj}
  If a discrete type \(A\) has a split surjection into some type \(B\), \(B\) is
  discrete.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Function/Surjective/Properties.tex]{discrete-surj}
  \end{agdalisting}
\end{lemma}
\begin{proof}
  This proof is can be straightforwardly derived from lemmas
  \ref{split-surj-to-inj} and \ref{inj-discrete}.
\end{proof}

\begin{lemma} \label{split-enum-discrete}
  Every split enumerable type is discrete.
\end{lemma}
\begin{proof}
  Let \(A\) be a split enumerable type.
  By lemma~\ref{split-enum-is-split-surj}, there is a surjection from
  \(\AgdaDatatype{Fin}\;n\) for some \(n\).
  Also, we know that \(\AgdaDatatype{Fin}\;n\) is discrete (proven in our
  formalisation).
  Therefore, by lemma~\ref{discrete-surj}, \(A\) is discrete.
\end{proof}
\section{Manifest Bishop Finiteness} \label{manifest-bishop-finiteness}
We mentioned in the introduction that occasionally in constructive mathematics
proofs will contain ``too much'' information.
With split enumerability we can see an instance of this.
Consider the following proof of the finiteness of bool:
\begin{agdalisting} \label{op-slop}
  \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{bool-slop}
\end{agdalisting}
There is an extra \AgdaInductiveConstructor{false} at the end of the support
list.
There's nothing terribly wrong with that: it is still a valid proof of
finiteness, after all, but it does mean that this proof has some extra
information which we didn't necessarily intend to encode.

There is ``slop'' in the type of split enumerability: there are more distinct
values than there are \emph{usefully} distinct values.
To reconcile this, we will disallow duplicates in the support list.

This is where manifest Bishop finiteness comes in: this is a definition of
finiteness quite similar to split enumerability in other regards, except that it
does not allows for duplicates in the support list.

How exactly to prohibit duplicates is the next question.
One approach might be to change the definition of \(\AgdaDatatype{List}\), or
introduce a new type \(\AgdaDatatype{NoDupeList}\), and use it in the predicate
instead.
However, this would mean we lose access to the functions we have defined on
lists, and we have to change the definition of
\(\AgdaFunction{\ensuremath{\in}}\) as well.

There is a much simpler and more elegant solution: we insist that every
\emph{membership proof} must be unique.
This would disallow a definition of \(\AgdaDatatype{\ensuremath{\mathcal{E}!}}\;
\AgdaDatatype{Bool}\) with
duplicates, as there are multiple values which inhabit the type
\(\AgdaInductiveConstructor{false}\;\AgdaFunction{\ensuremath{\in}}\;
\AgdaInductiveConstructor{\ensuremath{\left[ \text{false}, \text{true},
      \text{false} \right]}}\).
It also allows us to keep most of the split enumerability definition unchanged,
just adding a condition to the returned membership proof in the cover proof.

To specify that a value must exist uniquely in HoTT we can use the concept of a
\emph{contraction}.

\begin{definition}[Contractions, Propositions and Sets] \label{homotopy-types}
  Types in HoTT and CuTT are not necessarily sets, as they are in MLTT.
  Some have higher homotopies (paths which aren't unique).
  We actually have a hierarchy of complexity of structure of path spaces in
  types, starting with the contractions \cite[definition 3.11.1]{hottbook}, then
  the mere propositions \cite[definition 3.3.1]{hottbook}, and the sets
  \cite[definition 3.1.1]{hottbook}.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Introduction.tex]{hlevels}
  \end{agdalisting}
  First we have the contractions: those types equivalent to
  \AgdaDatatype{\ensuremath{\top}}.
  Then the propositions: those types for which every value is equal to every
  other.
  Finally the sets: those types for which every \emph{equality} is equal to
  every other.

  Often these types are defined inductively: going from contractions upwards,
  every new level has paths in the level before (i.e. the paths of a proposition
  are all contractions).
  We can also proceed further upwards, into non-set types.
\end{definition}
\begin{definition}[Unique Membership] \label{uniq-memb-def}
  Unique list membership is defined in terms of list membership: it is a
  contraction of it.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Container/Membership.tex]{uniq-memb-def}
  \end{agdalisting}
\end{definition}

With this we can define manifest Bishop finiteness:
\begin{definition}[Manifest Bishop Finiteness]  \label{bish-def}
  A type is manifest Bishop finite if there exists a list which contains each
  value in the type once.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Cardinality/Finite/ManifestBishop/Container.tex]{bish-def}
  \end{agdalisting}
\end{definition}
The only difference between manifest Bishop finiteness and split enumerability
is the membership term: here we require unique membership (\(\inunique\)),
rather than simple membership (\(\in\)).

We use the word ``manifest'' here to distinguish from another common
interpretation of Bishop finiteness, which we have called cardinal finiteness in
this paper.
The ``manifest'' refers to the fact that we have a concrete, non-truncated list
of the elements in the proof.

\subsection{The Relationship Between Manifest Bishop Finiteness and Split
  Enumerability}
While manifest Bishop finiteness might seem stronger than split enumerability,
it turns out this is not the case.
Both predicates imply the other.
\begin{lemma} \label{manifest-bishop-to-split-enum}
  Any manifest Bishop finite type is split enumerable.
\end{lemma}
\begin{proof}
  To construct a proof of split enumerability from one of manifest Bishop
  finiteness, it suffices to convert a proof of \(x \inunique \mathit{xs}\) to
  one of \(x \in \mathit{xs}\), for all \(x\) and \(\mathit{xs}\).
  Since \(\inunique\) is defined as a contraction of \(\in\), such a conversion
  is simply the \(\text{fst}\) function.
\end{proof}

\begin{lemma} \label{split-enum-to-manifest-bishop}
  Any split enumerable set is manifest Bishop finite.
\end{lemma}
This proof takes significantly more work.
The ``unique membership'' condition in
\(\AgdaDatatype{\ensuremath{\mathcal{B}}}\) means that we are not permitted
duplicates in the support list.
The first step in the proof, then, is to filter those duplicates out from the
support list of the \(\AgdaDatatype{\ensuremath{\mathcal{E}!}}\) proof: we can do this using the decidable
equality provided by \(\AgdaDatatype{\ensuremath{\mathcal{E}!}}\) (lemma~\ref{split-enum-discrete}).
From there, we need to show that the membership proof carries over
appropriately.
\todo{Provide more info on this proof?}

We have now proved that every manifestly Bishop finite type is split enumerable,
and vice versa.
While the types are not \emph{equivalent} (there are more split enumerable
proofs than there are manifest Bishop finite proofs), they are of equal power.
\subsection{From Manifest Bishop Finiteness to Equivalence}
We have seen that split enumerability was in fact a split-surjection in
disguise.
We will now see that manifest Bishop finiteness is in fact an \emph{equivalence}
in disguise.

\begin{definition}[Equivalences] \label{equivalences}
  We will take contractible maps \cite[definition 4.4.1]{hottbook} as our
  ``default'' definition of equivalences.
  \begin{agdalisting} \label{is-equiv-def}
    \ExecuteMetaData[agda/Snippets/Equivalence.tex]{is-equiv-def}
  \end{agdalisting} \vspace{-.5\baselineskip}
  \begin{agdalisting} \label{equiv-def}
    \ExecuteMetaData[agda/Snippets/Equivalence.tex]{equiv-def}
  \end{agdalisting}
\end{definition}
\begin{lemma} \label{bishop-equiv}
  Manifest bishop finiteness is equivalent to an equivalence to a finite prefix
  of the natural numbers.
  \begin{equation}
  \end{equation}
\end{lemma}
\begin{proof} \todo{Convert to Agda}
  \begin{align*}
     \AgdaDatatype{\ensuremath{\mathcal{B}}}(A) &
    \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , x \inunique \mathit{xs}
    && \text{def.~\ref{bish-def} }(\AgdaDatatype{\ensuremath{\mathcal{B}}})
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \text{isContr}(x \in \mathit{xs})
    && \text{eqn.~\ref{uniq-memb-def} } (\inunique)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \text{isContr}(\text{fib}_{\text{snd}(\mathit{xs})}(x))
    && \text{eqn.~\ref{container-membership} } (\in)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \text{isEquiv}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{is-equiv-def} (isEquiv)}
    \\
    & \simeq \Sigma (\mathit{xs} : \llbracket \mathbb{N} , \AgdaDatatype{Fin} \rrbracket (A)) , \text{isEquiv}(\text{snd}(\mathit{xs}))
    && \text{def.~\ref{List} } (\AgdaDatatype{List})
    \\
    & \simeq \Sigma (\mathit{xs} : \Sigma (n : \mathbb{N}) , \Pi (i : \AgdaDatatype{Fin}\;n) , A) , \text{isEquiv}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{container-interp} } (\llbracket \wc \rrbracket)
    \\
    & \simeq \Sigma (n : \mathbb{N}) , \Sigma (f : \AgdaDatatype{Fin}\;n \rightarrow A) , \text{isEquiv}(f)
    && \text{Reassociation of } \Sigma
    \\
    & \simeq \Sigma (n : \mathbb{N}) , ( \AgdaDatatype{Fin}\;n \simeq A )
    && \text{eqn.~\ref{equiv-def} } (\simeq) \; \qedhere
  \end{align*}
\end{proof}
This proof is almost identical\footnotemark to the proof for
lemma~\ref{split-enum-is-split-surj}: it reveals that
enumeration-based finiteness predicates are simply another perspective on
relation-based ones.
\footnotetext{
  Unfortunately in our formalisation this proof cannot be a single line: for
  performance reasons \(\simeq\) is defined as a record type with eta-equality
  disabled, instead of the definition here which uses \(\Sigma\).
}

As we are working in CuTT, a proof of equivalence between two types gives us the
ability to \emph{transport} proofs from one type to the other.
This is extremely powerful, as we will see.
\section{Cardinal Finiteness} \label{cardinal-finiteness}
While we have removed some of the unnecessary information from our finiteness
predicates, one piece still remains.
The two following proofs are both valid proofs of the finiteness of
\(\AgdaDatatype{Bool}\), and both do not include any duplicates:

\begin{minipage}{\textwidth}
\begin{multicols}{2}
  \begin{agdalisting*}
    \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{bool-inst}
  \end{agdalisting*} \columnbreak
  \begin{agdalisting*}
    \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{bool-rev}
  \end{agdalisting*}
\end{multicols}
\end{minipage}
Clearly they're not the same though: the order of their support lists differs.
Each finiteness predicate so far has contained an \emph{ordering} of the
underlying type.
For our purposes, this is too much information: it means that when constructing
the ``category of finite sets'' later on, instead of each type having one
canonical representative, it will have \(n!\), where \(n\) is the cardinality of
the type\footnotemark.

\footnotetext{
  We actually do get a category (a groupoid, even) from manifest Bishop
  finiteness \cite{yorgeyCombinatorialSpeciesLabelled2014}: it's the groupoid of
  finite sets equipped with a linear order, whose morphisms are order-preserving
  bijections.
  We do not explore this particular construction in any detail.
}

To remedy the problem, we will use propositional truncation
(def.~\ref{prop-trunc}).

\begin{definition}[Higher Inductive Types] \label{HITs}
  Normal inductive types have \emph{point} constructors: constructors which
  construct values of the type.
  Higher Inductive Types (HITs) also have \emph{path} constructors: ways to
  construct paths in the type.
\end{definition}
\begin{definition}[Propositional Truncation] \label{prop-trunc}
  The type \(\lVert A \rVert\) on some type \(A\) is a propositionally truncated
  proof of \(A\) \cite[3.7]{hottbook}.
  In other words, it is a proof that some \(A\) exists, but it does not tell you
  \emph{which} \(A\).

  It is defined as a Higher Inductive Type:
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/PropTrunc.tex]{prop-trunc-def}
  \end{agdalisting}
  We will use two eliminators from \(\lVert A \rVert\) in this paper.
  \begin{enumerate}
  \item \label{elim-prop-prop} For any function \(A \rightarrow B\), where
    \(\text{isProp}(B)\), we have a function \(\lVert A \rVert \rightarrow B\).
  \item \label{elim-prop-coh} We can eliminate from \(\lVert A \rVert\) with a
    function \(f : A \rightarrow B\) iff \(f\) ``doesn't care'' about the
    choice of \(A\):
    \[\Pi {(x , y : A)} , f(x) \equiv f(y) \]
    Formally speaking, \(f\) needs to be ``coherently constant''
    \cite{krausGeneralUniversalProperty2015}, and \(B\) needs to be an
    \(n\)-type for some finite \(n\).
  \end{enumerate}
\end{definition}
\begin{definition}[Cardinal Finiteness]
  A type \(A\) is cardinally finite if there exists a propositionally truncated
  proof that \(A\) is manifest Bishop finite or equivalent to a finite prefix of
  the natural numbers.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Cardinality/Finite/Cardinal.tex]{cardinal-def}
  \end{agdalisting}
\end{definition}
At first glance, it might seem that we lose any useful properties we could
derive from \(\AgdaDatatype{\ensuremath{\mathcal{B}}}\).
Luckily, this is not the case: by eliminator \ref{elim-prop-coh} of
def.~\ref{prop-trunc}, we need only show that the output is uniquely determined.
\subsection{Deriving Uniquely-Determined Quantities}
The following two lemmas are proven in
\cite{yorgeyCombinatorialSpeciesLabelled2014} (Proposition 2.4.9 and 2.4.10,
respectively), in much the same way as we have done here.
Our contribution for this section is simply the formalisation.
\begin{lemma}
  Given a cardinally finite type, we can derive the type's cardinality, as well
  as a propositionally truncated proof of equivalence with \(\textbf{Fin}\)s of
  the same cardinality.
  \begin{equation}
    \mathcal{C}(A) \rightarrow \Sigma {(n : \mathbb{N})} , \lVert \textbf{Fin}(n) \simeq A \rVert
  \end{equation}
\end{lemma}
\begin{proof}
  Let \(A\) be a cardinally-finite type, with proof \(F : \mathcal{C}(A)\).
  Our task is to extract a natural number \(n : \mathbb{N}\) representing the
  cardinality of \(A\), and a propositionally-truncated proof that \(A\) is
  equivalent to \(\AgdaDatatype{Fin}\;n\).

  Extracting the second component of the pair is trivial, as it itself is
  truncated.
  We will now focus on extracting the cardinality.

  Without the propositional truncation, \(\text{fst}\) would suffice for this
  task.
  Given that the pair is hidden under the truncation, then, we need a way to
  convert a function \(f : A \rightarrow B\) to \(g : \lVert A \rVert
  \rightarrow B\).
  This is precisely what eliminator \ref{elim-prop-coh} gives us.
  For our case, we need to show the following:
  \begin{equation}
    \frac{(n : \mathbb{N}) \; \; \; (p : \AgdaDatatype{Fin}\;n \simeq A) \; \; \;
          (m : \mathbb{N}) \; \; \; (q : \AgdaDatatype{Fin}(m) \simeq A)
        }{
          n \equiv m
        }
  \end{equation}
  Immediately we can construct the following term:
  \begin{equation}
    \begin{alignedat}{3}
      \AgdaDatatype{Fin}\;n & \simeq A && (p) \\
                      & \simeq \AgdaDatatype{Fin}(m) && (q)
    \end{alignedat}
  \end{equation}
  Given univalence we have \(\AgdaDatatype{Fin}\;n \equiv \AgdaDatatype{Fin}(m)\),
  and the rest of our task is to prove:
  \begin{equation}
    \frac{\AgdaDatatype{Fin}\;n \equiv \AgdaDatatype{Fin}(m)}{n \equiv m}
  \end{equation}

  This is a well-known chestnut in dependently-typed programming, and one that
  has a surprisingly tricky and complex proof.
  We do not include it here, since it has already been explored elsewhere, but
  it is present in our formalisation.
\end{proof}

In order to prove that cardinal finiteness implies decidable equality, we will
need to show that decidable equality itself is a proposition.
In doing that we will use the following lemma:
\begin{lemma} \label{prop-refute}
  We can ``refute'' a propositionally-truncated proof of some proposition with a
  proof that the non-truncated proposition is false.
  \begin{equation}
    \frac{\neg A \; \; \; \lVert A \rVert}{\bot}
  \end{equation}
\end{lemma}
\begin{proof}
  We know we can eliminate from any value of type \(\lVert A \rVert\) into some
  \(B\) with a function \(A \to B\) if \(B\) is a proposition.
  That's precisely what we do in this case: \(\neg A\) is a function of type \(A
  \to \bot\), and we know that \(\bot\) is a proposition.
\end{proof}

\begin{lemma} \label{cardinal-finite-discrete}
  Any cardinal-finite set has decidable equality.
\end{lemma}
\begin{proof}
  Since we can already derive decidable equality from a proof of manifest Bishop
  finiteness, it suffices to show that decidable equality is itself a
  proposition.
  \begin{equation}
    \text{isProp}(\Pi(x, y : A) , \mathbf{Dec}(x \equiv y))
  \end{equation}
  First, it is clear that \(x \equiv y\) is a proposition: since the type \(A\)
  has decidable equality, by Hedburg's theorem it is a set,
  meaning precisely that \(x \equiv y\) is a proposition.

  Secondly, we know that any decision over a proposition is itself a
  proposition.
  For any two terms \(x, y: \mathbf{Dec}(A)\) we cannot have the case that one
  is a yes decision and the other is no: from that we could derive \(\bot\).
  If both are no then they are both equal since \(A \rightarrow \bot\) is a
  proposition through function extensionality.
  And finally if both are yes then we know they must be equal because the type
  decided over is itself a proposition.

  Finally, since we know that \(\mathbf{Dec}(x \equiv y)\) is a proposition, we
  can derive that \(\Pi(x, y : A) , \mathbf{Dec}(x \equiv y)\) is a proposition
  (through function extensionality), proving our goal.
\end{proof}
\subsection{Restrictiveness}
So far our explorations into finiteness predicates have pushed us in the
direction of ``less informative'': however, as mentioned in the introduction, we
can \emph{also} ask how \emph{restrictive} certain predicates are.
Since split enumerability and manifest Bishop finiteness imply each other we
know that there can be no type which satisfies one but not the other.
We also know that manifest Bishop finiteness implies cardinal finiteness, but we
do \emph{not} have a function in the other direction:
\begin{equation}
  \mathcal{C}(A) \rightarrow \AgdaDatatype{\ensuremath{\mathcal{B}}}(A)
\end{equation}
So the question arises naturally: is there a cardinally finite type which is
\emph{not} manifest Bishop finite?

It turns out the answer is no!
\begin{lemma}
  \begin{equation}
    \neg (\Sigma(A : \mathbf{Type}) , \mathcal{C}(A) \times \neg \AgdaDatatype{\ensuremath{\mathcal{B}}}(A))
  \end{equation}
\end{lemma}
\begin{proof}
  We will actually prove a slightly more general statement.
  For any type \(A\), the following holds:
  \begin{equation}
    \neg (\lVert A \rVert \times \neg A)
  \end{equation}
  The solution becomes more clear if we write out the definition of \(\neg\):
  \begin{equation}
    \frac{\lVert A \rVert \;\;\; A \rightarrow \bot }{\bot}
  \end{equation}
  We clearly need to apply a function of type \(A \rightarrow \bot\) to a value
  of type \(\lVert A \rVert\).
  Luckily, this is permissible, as \(\bot\) is a mere proposition.
\end{proof}


\subsection{Going from Cardinal Finiteness to Manifest Bishop Finiteness}
\begin{lemma} \label{manifest-bishop-to-cardinal}
  Any manifest Bishop finite type is cardinal finite.
\end{lemma}
\begin{theorem} \label{cardinal-to-manifest-bishop}
  Any cardinal finite type with a total order is Bishop finite.
\end{theorem}
The proof for this particular theorem is quite involved in the formalisation, so
we only give its sketch here.
First, note that we actually convert to manifest enumerability first: this can
be converted to split enumerability with decidable equality, which is provided
by cardinal finiteness.

Next, we define permutations.
\begin{definition}[List Permutations]
  Two lists are permutations of each other if their membership proofs are all
  equivalent\footnotemark \cite{danielssonBagEquivalenceProofRelevant2012}.
  \begin{equation}
    \mathit{xs} \leftrightsquigarrow \mathit{ys} = \Pi {(x : A)} , x \in \mathit{xs} \simeq x \in \mathit{ys}
  \end{equation}
\end{definition}

\footnotetext{
  The definition in \cite{danielssonBagEquivalenceProofRelevant2012} and our
  formalisation is slightly different: we say permutations are lists with
  \emph{isomorphic} membership proofs.
  The distinction, as it happens, does not affect our work here.
}

Next, we define a sort function which relies on the provided total order.
We further prove the following fact about this sort function:
\begin{equation}
  \Pi(\mathit{xs}, \mathit{ys} : \AgdaDatatype{List}(A)) , \mathit{xs} \leftrightsquigarrow \mathit{ys} \rightarrow \text{sort}(\mathit{xs}) \equiv \text{sort}(\mathit{ys})
\end{equation}

Next, notice that the support lists of any two proofs of manifest Bishop
finiteness must be permutations of each other.
This will allow us to sort the support list of a proof of cardinal finiteness in
a coherently constant (definition~\ref{prop-trunc},
eliminator~\ref{elim-prop-coh}) way, pulling the support list out from the
truncation.
The cover proof emerges naturally from the definition of the permutation.
\section{Manifest Enumerability} \label{manifest-enumerability}
We have now explored quite far in the direction of restricting information:
indeed, cardinal finiteness, a mere proposition, has the minimal amount of
information a predicate can have.
What we haven't seen, however, is a predicate with a different domain to the
others.
Since manifest Bishop finiteness and split enumerability have equal strength
\todo{ref here}, and since we've shown that there is no type which is cardinal
finite but not manifest Bishop finite, we haven't explored any of the
``restrictiveness'' axis from Figure~\ref{finite-classification}.

As an example type which may be considered finite in some circumstances, but
doesn't conform to any of the definitions we have seen so far, consider the
circle.
\begin{definition}[\(S^1\)] \label{circle-def}
  The circle, \(S^1\), can be represented in HoTT as a higher inductive type.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Circle.tex]{circle-def}
  \end{agdalisting}
  The presence of the \AgdaInductiveConstructor{loop} constructor is what
  precludes this type from being a set.
  In sets, all paths are equal: in this type, \AgdaInductiveConstructor{loop} is a
  path which is not equal to the usual identity path.
\end{definition}

We suggest that this type cannot be proven to conform to any of the finiteness
predicates we have seen so far (split enumerability, manifest Bishop finiteness,
or Cardinal finiteness).
To provide some better evidence for this fact (other than ``we tried quite hard
and couldn't manage it'') remember Hedberg's theorem
\cite{hedbergCoherenceTheoremMartinLof1998}:
\begin{theorem}[Hedberg's Theorem]
  Every discrete type is a set.
\end{theorem}
Since each finiteness predicate we have seen so far \emph{does} imply decidable
equality, we know that the cardinal finite types can \emph{only} be sets, ruling
out the circle.

So our tour through the finiteness predicates takes us next to one which allows
the circle to be called finite: manifest enumerability.
\begin{definition}[Manifest Enumerability]
  Manifest enumerability is an enumeration predicate like Bishop finiteness or
  split enumerability with the only difference being a propositionally truncated
  membership proof.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Cardinality/Finite/ManifestEnumerable/Container.tex]{manifest-enum-def}
  \end{agdalisting}
\end{definition}

It might not be immediately clear why this definition of enumerability allows
the circle to conform while the others do not.
The crux of the issue was that the cover proofs of the previous definitions
didn't just tell us that some element was in the support list, they told us
\emph{where} it was in the support list.
From the position we were able to derive decidable equality: that position is
precisely what's hidden in manifest enumerability.

And indeed this means that the circle is manifestly enumerable:
\begin{lemma}
  The circle \(S^1\) is manifestly enumerable.
\end{lemma}
\begin{proof}
  The support list firstly is a list containing the point constructor for the
  circle.
  Since the cover proof is truncated, we need only consider the point
  constructors of the circle: as such, the cover proof is essentially the same
  as the one for \(\AgdaDatatype{\ensuremath{\mathcal{E}!}}(\top)\).
\end{proof}
\subsection{Surjections}
We already say that split enumerability was the listed form of a split
surjection: manifest enumerability is the listed form of a proper surjection.
\begin{definition}[Surjections] \label{surjections}
  We define proper surjections (not split surjections) here \cite[definition
  4.6.1]{hottbook}.
  \begin{alignat}{3}
    &\text{surj}(f)             &&\coloneqq \Pi(y : B) , \lVert \text{fib}_f(y) \rVert \label{surj-eqn} \\
    &A \twoheadrightarrow B     &&\coloneqq \Sigma (f : A \rightarrow B) , \text{surj}(f) \label{surj-arrow-eqn}
  \end{alignat}
\end{definition}
\begin{lemma}
  Manifest enumerability is equivalent to a surjection from a finite prefix of
  the natural numbers.
  \begin{equation}
    \mathcal{E}(A) \simeq \Sigma(n : \mathbb{N}) , (\AgdaDatatype{Fin}\;n \twoheadrightarrow A)
  \end{equation}
\end{lemma}
\begin{proof}
  \begin{align*}
     \mathcal{E}(A) &
    \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \lVert x \in \mathit{xs} \rVert
    && \text{def.~\ref{split-enum-def} }(\mathcal{E})
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \lVert \text{fib}_{\text{snd}(\mathit{xs})}(x) \rVert
    && \text{eqn.~\ref{container-membership} } (\in)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \text{surj}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{surj-eqn} (surj)}
    \\
    & \simeq \Sigma (\mathit{xs} : \llbracket \mathbb{N} , \AgdaDatatype{Fin} \rrbracket (A)) , \text{surj}(\text{snd}(\mathit{xs}))
    && \text{def.~\ref{List} } (\AgdaDatatype{List})
    \\
    & \simeq \Sigma (\mathit{xs} : \Sigma (n : \mathbb{N}) , \Pi (i : \AgdaDatatype{Fin}\;n) , A) , \text{surj}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{container-interp} } (\llbracket \wc \rrbracket)
    \\
    & \simeq \Sigma (n : \mathbb{N}) , \Sigma (f : \AgdaDatatype{Fin}\;n \rightarrow A) , \text{surj}(f)
    && \text{Reassociation of } \Sigma
    \\
    & \simeq \Sigma (n : \mathbb{N}) , ( \AgdaDatatype{Fin}\;n \twoheadrightarrow A )
    && \text{eqn.~\ref{surj-arrow-eqn} } (\twoheadrightarrow) \; \qedhere
  \end{align*}
\end{proof}
\subsection{Relation To Split Enumerability}
It is trivially easy to construct a proof that any split enumerable type is
manifest enumerable: we simply truncate the membership proof.
Going the other was requires us to extract a non-truncated proof from a
truncated one.
This proof relies on the following lemma:
\begin{lemma}
  We can ``recompute'' a truncated proof given a decision over a proof of the
  same type.
  \begin{equation}
    \frac{\lVert A \rVert \; \; \; \mathbf{Dec}(A)}{A}
  \end{equation}
\end{lemma}
\begin{proof}
  We proceed by case-analysis over the decision over \(A\).
  In the case where \(A\) is proven, we are done.
  In the case where \(A\) is disproven, we use lemma~\ref{prop-refute} to
  derive impossibility.
\end{proof}

\begin{lemma} \label{manifest-enum-to-split-enum}
  A manifestly enumerable type with decidable equality is split enumerable.
\end{lemma}
\begin{proof}
  The only difference between manifest enumerability and split enumerability is
  the membership proof: therefor our goal for this proof is to construct a
  function of the following type:
  \begin{equation}
    \lVert x \in \mathit{xs} \rVert \rightarrow x \in \mathit{xs}
  \end{equation}
  Given decidable equality over the type of \(x\).

  We do this using the previous recompute lemma: that tells us that all we need
  to construct is a decision for \(x \in \mathit{xs}\), and it will be able to
  derive the proof itself.
  Such a decision procedure is not difficult to construct: for any value \(x\)
  and list \(\mathit{xs}\), we proceed through the list \(\mathit{xs}\), testing
  if \(x\) is equal to any of its contents.
  If it is, we return that we have proven the goal, and that \(x\) is indeed
  present in \(\mathit{xs}\).
  Otherwise, we know that \(x\) cannot be in \(\mathit{xs}\) (since we've tested
  every value), so we return that the goal has been disproven.
\end{proof}
\section{Kuratowski Finiteness} \label{kuratowski} \todo{better intro}
The one big missing definition of finiteness to cover is \emph{Kuratowski}
finiteness.
While it's quite important, it's also quite different from the definitions we've
seen so far.
It starts with an encoding of the free join semilattice.
\begin{definition}[Free Join Semilattice]
  \(\mathcal{K}(A)\) is the free join semilattice, or, alternatively, the type
  of Kuratowski-finite subsets of \(A\).
  \begin{agdalisting}
    \ExecuteMetaData[agda/Algebra/Construct/Free/Semilattice/Definition.tex]{kuratowski-def}
  \end{agdalisting}

  We define it as a HIT (definition~\ref{HITs}).
  The first two constructors are point constructors, giving ways to create
  values of type \(\mathcal{K}(A)\).
  They are also recognisable as the two constructors for finite lists, a type
  which represents the free monoid.

  The next two constructors add extra paths to the type: equations that usage of
  the type must obey.
  These extra paths turn the free monoid into the free \emph{commutative} (com)
  \emph{idempotent} (dup) monoid.

  The final constructor enforces that the type \(\mathcal{K}(A)\) must be a set.
\end{definition}
The Kuratowski finite subset is a free join semilattice (or, equivalently, a
free commutative idempotent monoid).
More prosaically, \(\mathcal{K}\) is the abstract data type for finite sets, as
defined in the Boom hierarchy \cite{boomFurtherThoughtsAbstracto1981,
  bunkenburgBoomHierarchy1994}.
However, rather than just being a specification, \(\mathcal{K}\) is fully usable
as a data type in its own right, thanks to HITs.

Other definitions of \(\mathcal{K}\) exist (such as the one in
\cite{fruminFiniteSetsHomotopy2018}) which make the fact that \(\mathcal{K}\) is
the free join semilattice more obvious.
We have included such a definition in our formalisation, and proven it
equivalent to the one above.

Next, we need a way to say that an entire type is Kuratowski finite.
For that, we will need to define membership of \(\mathcal{K}\).
\begin{definition}[Membership of \(\mathcal{K}\)]
  Membership is defined by pattern-matching on \(\mathcal{K}\).
  The two point constructors are handled like so: \todo{to agda}
  \begin{equation}
    \begin{alignedat}{2}
      x \in&& \; []                      &\coloneqq \bot ; \\
      x \in&& \; y \dblcolon \mathit{ys} &\coloneqq \lVert x \equiv y \uplus x \in \mathit{ys} \rVert ;
    \end{alignedat}
  \end{equation}
  The \(\text{com}\) and \(\text{dup}\) constructors are handled by proving that
  the truncated form of \(\uplus\) is itself commutative and idempotent.
  The type of propositions is itself a set, satisfying the \(\text{trunc}\)
  constructor.
\end{definition}
Finally, we have enough background to define Kuratowski finiteness.
\begin{definition}[Kuratowski Finiteness] \phantom{break}
  \begin{agdalisting}
    \ExecuteMetaData[agda/Cardinality/Finite/Kuratowski.tex]{kuratowski-finite-def}
  \end{agdalisting}
\end{definition}

We also have the following two lemmas, proven in both
\cite{fruminFiniteSetsHomotopy2018} and our formalisation.
\begin{lemma}
  \(\mathcal{K}^f\) is a mere proposition.
\end{lemma}
\begin{lemma}
  This circle \(S^1\) is Kuratowski finite.
\end{lemma}
\subsection{Relation to Cardinal Finiteness}
\begin{lemma} \label{cardinal-kuratowski}
  Cardinal finiteness is equivalent to Kuratowski finiteness over a discrete
  set.
  \begin{equation}
    \mathcal{C}(A) \simeq \mathcal{K}^f(A) \times \text{Discrete}(A)
  \end{equation}
\end{lemma}
This proof is constructed by providing a pair of functions: one from
\(\mathcal{C}(A)\) to \(\mathcal{K}^f(A) \times \text{Discrete}(A)\), and one the
other way.
This pair implies an equivalence, because both source and target are
propositions.
The actual functions themselves are proven in our formalisation, as well as in
\cite{fruminFiniteSetsHomotopy2018}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: