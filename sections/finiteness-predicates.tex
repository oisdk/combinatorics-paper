\chapter{Finiteness Predicates} \label{finiteness-predicates}
In this section, we will define and briefly describe each of the five predicates
in Figure~\ref{finite-classification}.
As we will see, each of these predicates has subtle differences from the others:
we will outline how some predicates are too informative, and how others aren't
powerful enough, for our needs, before settling on decidable Kuratowski
finiteness as our focus.

As we make our way through each predicate, we will be interested in two aspects:
how can we build proofs of this predicate (i.e. is the product of two finite
types finite?) and what do we \emph{get} once we do (i.e. does this predicate
tell us the number of elements in the finite set?).
\section{Split Enumerability} \label{split-enumerability}
We will start with a simple notion of finiteness, called \emph{split}
enumerability.

\begin{definition}[Split Enumerable Set] \label{split-enum-def}
  To say that some type \(A\) is split enumerable is to say that there is a list
  \(\mathit{support} : \mathbf{List}(A)\) such that any value \(x : A\) is in
  \(\mathit{support}\).
  \begin{equation} \label{split-enum-def-eqn}
    \mathcal{E}!(A) \coloneqq \Sigma {(\mathit{support} : \textbf{List}(A))} , \Pi {(x : A)} , x \in \mathit{support}
  \end{equation}
  We call the first component of this pair the ``support'' list, and the second
  component the ``cover'' proof.
  An equivalent version of this predicate was called \verb+Listable+ in
  \cite{firsovDependentlyTypedProgramming2015}.
\end{definition}
We used some extra types in the above definition, which we will define here:

\begin{definition}[\(\mathbf{List}\)] \label{List}
  In this paper we define lists as \emph{containers}:
  \begin{equation}
    \mathbf{List} \coloneqq \llbracket \mathbb{N} , \mathbf{Fin} \rrbracket
  \end{equation}
  This may seem quite foreign or complex in comparison to the usual definition
  of lists as an inductive data type:
  \begin{inductivetype}{\mathbf{List}(A)}
    \inductivetypeclause{\left[ \right]}{\mathbf{List}(A)}
    \inductivetypeclause{\wc \dblcolon \wc}{A \rightarrow \mathbf{List}(A) \rightarrow \mathbf{List}(A)}
  \end{inductivetype}
  But it turns out to be quite useful for later proofs.

  Moreover, the inductive type and the container-based type are equivalent, as
  is proven in our formalisation.
\end{definition}
\begin{definition}[Containers] \label{container-def}
  A container \cite{abbottContainersConstructingStrictly2005} is a pair
  \(S , P\) where \(S\) is a type, the elements of which are called
  the \emph{shapes} of the container, and \(P\) is a type family on \(S\), where
  the elements of \(P(s)\) are called the \emph{positions} of a container.
  We ``interpret'' a container into a functor defined like so:
  \begin{equation} \label{container-interp}
    \llbracket S , P \rrbracket(A) \coloneqq \Sigma {(s : S)} , \left( P(s) \rightarrow A \right)
  \end{equation}
  Membership of a container can be defined like so:
  \begin{equation} \label{container-membership}
    x \in \mathit{xs} \coloneqq \text{fib}_{\text{snd}(\mathit{xs})}(x)
  \end{equation}
\end{definition}
\begin{definition}[\(\mathbf{Fin}\)] \label{Fin}
  \(\mathbf{Fin}(n)\) is the type of natural numbers smaller than \(n\). We
  define it the standard way:
  \begin{equation}
    \begin{alignedat}{3}
      & \mathbf{Fin}(0)     && \coloneqq \bot ; \\
      & \mathbf{Fin}(n + 1) && \coloneqq \top \uplus \mathbf{Fin}(n) ;
    \end{alignedat}
  \end{equation} 
\end{definition}
\subsection{Instances}
Now that we have a suitable definition of finiteness, we will next prove that
some things are finite.
\begin{lemma}
  \(\bot\), \(\top\), and \(\mathbf{Bool}\) are split enumerable.
\end{lemma}
\begin{proof}
  These three types are represented by fairly simple finite sets:
  \begin{align}
    \bot &= \left\{  \right\} \\
    \top &= \left\{ \text{tt}  \right\} \\
    \mathbf{Bool} &= \left\{  \text{false}, \text{true} \right\}
  \end{align}
  Which leads to quite simple proofs of finiteness.

  The support list for is \(\left[  \right]\), \(\left[ \text{tt} \right]\), and
  \(\left[ \text{false}, \text{true} \right]\), respectively, and the cover
  proof is a function that returns the index of the supplied element.
\end{proof}
\begin{agdalisting}
  The code in our formalisation of these three proofs is quite simple.
  Just as an example, the proof that \(\mathbf{Bool}\) is split enumerable is as
  follows:
  \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{bool-inst}
\end{agdalisting}
With the most basic simple types out of the way, the obvious next choice is the
(non-dependent) sums and products: \(\uplus\) and \(\times\).
Both of these types can be constructed from the \emph{dependent} sum, however,
so that is the type we will prove finite.
From that we can derive a much wider array of finiteness proofs.


\begin{lemma} \label{split-enum-sigma}
  Split enumerability is closed under \(\Sigma\).
  \begin{equation}
    \frac{
      \mathcal{E}!(A) \; \; \; \Pi(x : A) , \mathcal{E}!(U(x))
    }{
      \mathcal{E}!(\Sigma(x : A) , U(x))
    }
  \end{equation}
\end{lemma}
\begin{proof}
  Let \(A\) be a type which is split enumerable, and \(U\) be a type family over
  \(A\) which is split enumerable at every point.
  Formally, we have the following proofs:
  \begin{align}
    \mathcal{E}!_A &: \mathcal{E}!(A) \\
    \mathcal{E}!_U &: \Pi(x : A) , \mathcal{E}!(U(x))
  \end{align}

  Our task is to construct a proof of type:
  \begin{equation}
    \mathcal{E}!(\Sigma(x : A) , U(x))
  \end{equation}
  This proof itself is composed of two components:
  \begin{align}
    \mathit{support} &: \mathbf{List}(\Sigma(x : A) , U(x)) \\
    \mathit{cover} &: \Pi(x : \Sigma(y : A) , U(y)) , x \in \mathit{support}
  \end{align}
  To construct the support list, we apply the function \(\mathcal{E}!_U\) to
  every element in the support list of \(\mathcal{E}!_A\), extract the support
  lists from the resulting finiteness proofs, and concatenate them.


  To prove that this support list does in fact cover the entirety of the type
  \(\Sigma \; A \; U\), we note that any element of type \(\Sigma \; A \; U\)
  must have a first component in the support list of \(\mathcal{E}!_A\), and its
  second component must be in the result of applying \(\mathcal{E}!_U\) to that
  first element (since that support list contains every element of type
  \(U(x)\)).
  Therefore, the pair itself must be in our constructed support list.
\end{proof}

\begin{agdalisting}
  This pattern of applying a function to each element in a list and
  concatenating the result is of course well-known in functional programming,
  and is in fact the pattern that makes lists a monad.
  While this insight isn't strictly relevant to our work here, it does mean
  the implementation of this function can use Agda's do notation, resulting
  in the following extremely clean implementation:
  \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{sup-sigma}
\end{agdalisting}

\subsection{Derivations}
We have a way to construct finiteness proofs, and a semiring-like toolbox to
combine them.
What we're now interested in is what we can \emph{derive} from them.

First, we will look at how this predicate relates to more traditional, classical
notions of finiteness.
in a classical setting we likely wouldn't mention ``lists'' or the like, and
would instead define finiteness based on the existence of some injection or
surjection.
As it turns out, our definition of finiteness here is precisely the same as the
surjection-based one, in quite a deep way!

First, we will need to define our terms: in HoTT, surjections are a little more
complex than what you'd find in either MLTT or classical mathematics.
\begin{definition}[Surjections] \label{surjections}
  We define both surjections and \emph{split} surjections here \cite[definition
  4.6.1]{hottbook}.
  \begin{alignat}{3}
    &\text{surj}(f)             &&\coloneqq \Pi(y : B) , \lVert \text{fib}_f(y) \rVert \label{surj-eqn} \\
    &A \twoheadrightarrow B     &&\coloneqq \Sigma (f : A \rightarrow B) , \text{surj}(f) \label{surj-arrow-eqn} \\
    &\text{sp-surj}(f)          &&\coloneqq \Pi(y : B) , \text{fib}_f(y) \label{sp-surj-eqn} \\
    &A \twoheadrightarrow! \; B &&\coloneqq \Sigma (f : A \rightarrow B) , \text{sp-surj}(f) \label{sp-surj-arrow-eqn}
  \end{alignat}
\end{definition}
Over sets, the surjections and split surjections are the same thing, but there
is a difference one we involve non-set types like the circle.

We will now see that split enumerability is in fact a split surjection in
another form:
\begin{lemma} \label{split-enum-is-split-surj}%
  A proof of split enumerability is equivalent to a split surjection from a
  finite prefix of the natural numbers.
  \begin{equation}%
    \mathcal{E}!(A) \simeq \Sigma (n : \mathbb{N}) , \left( \mathbf{Fin}(n) \twoheadrightarrow ! \; A \right)
  \end{equation}
\end{lemma}
\begin{proof}
  \begin{align*}
     \mathcal{E}!(A) &
    \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , x \in \mathit{xs}
    && \text{def.~\ref{split-enum-def} }(\mathcal{E}!)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \text{fib}_{\text{snd}(\mathit{xs})}(x)
    && \text{eqn.~\ref{container-membership} } (\in)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \text{sp-surj}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{sp-surj-eqn} (sp-surj)}
    \\
    & \simeq \Sigma (\mathit{xs} : \llbracket \mathbb{N} , \mathbf{Fin} \rrbracket (A)) , \text{sp-surj}(\text{snd}(\mathit{xs}))
    && \text{def.~\ref{List} } (\mathbf{List})
    \\
    & \simeq \Sigma (\mathit{xs} : \Sigma (n : \mathbb{N}) , \Pi (i : \mathbf{Fin}(n)) , A) , \text{sp-surj}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{container-interp} } (\llbracket \wc \rrbracket)
    \\
    & \simeq \Sigma (n : \mathbb{N}) , \Sigma (f : \mathbf{Fin}(n) \rightarrow A) , \text{sp-surj}(f)
    && \text{Reassociation of } \Sigma
    \\
    & \simeq \Sigma (n : \mathbb{N}) , ( \mathbf{Fin}(n) \twoheadrightarrow ! \; A )
    && \text{eqn.~\ref{sp-surj-arrow-eqn} } (\twoheadrightarrow!) \; \qedhere
  \end{align*}
\end{proof}
\begin{agdalisting}
In our formalisation, the proof is a single line:
\ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{is-split-inj}
The only step which isn't definitional equality is the reassociation of
\(\Sigma\).
\ExecuteMetaData[agda/Data/Sigma/Properties.tex]{reassoc}
\end{agdalisting}
(The simplicity of this proof, by the way, is why we preferred the
container-based definition of lists over the traditional one.)

Split enumerability implies decidable equality on the underlying type.
To prove this, we will make use of the following lemma, proven in the
formalisation:
\begin{definition}[Injections]
  Injective functions are more straightforward to define constructively than
  surjective ones:
  \begin{alignat}{3}
    & \text{injective}(f) &&\coloneqq \Pi (x, y : A) , f \; x \equiv f \; y \rightarrow x \equiv y \\
    & A \rightarrowtail B &&\coloneqq \Sigma(f : A \rightarrow B) , \text{injective}(f)
  \end{alignat}
\end{definition}
\begin{lemma} \label{split-surj-to-inj}
  A split-surjection from \(A\) to \(B\) implies an injection from \(B\) to
  \(A\).
  \begin{equation}
    (A \twoheadrightarrow! \; B) \rightarrow (B \rightarrowtail A)
  \end{equation}
\end{lemma}
\begin{lemma} \label{inj-discrete}
  For any type \(A\) which injects into a discrete type \(B\), \(A\) is
  discrete.
  \begin{equation}
    \frac{
      A \rightarrowtail B \; \; \; \text{Discrete}(B)
    }{
      \text{Discrete}(A)
    }
  \end{equation}
\end{lemma}

\begin{lemma} \label{discrete-surj}
  \begin{equation}
    \frac{
      A \twoheadrightarrow! \; B \; \; \; \text{Discrete}(A)
    }{
      \text{Discrete}(B) 
    }
  \end{equation}
\end{lemma}
\begin{proof}
  This proof is can be straightforwardly derived from lemmas
  \ref{split-surj-to-inj} and \ref{inj-discrete}.
\end{proof}

\begin{lemma} \label{split-enum-discrete}
  Every split enumerable type is discrete.
\end{lemma}
\begin{proof}
  Let \(A\) be a split enumerable type.
  By lemma~\ref{split-enum-is-split-surj}, there is a surjection from
  \(\mathbf{Fin}(n)\) for some \(n\).
  Also, we know that \(\mathbf{Fin}(n)\) is discrete (proven in our
  formalisation).
  Therefore, by lemma~\ref{discrete-surj}, \(A\) is discrete.
\end{proof}

\section{Manifest Bishop Finiteness} \label{manifest-bishop-finiteness}
We mentioned in the introduction that occasionally in constructive mathematics
proofs will contain ``too much'' information.
With split enumerability we can see an instance of this.

\begin{agdalisting} \label{bool-slop}
  Consider the following proof of the finiteness of Bool:
  \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{bool-slop}
  While it represents the ``same'' information as our previous proof, it is
  clearly not the same \emph{object}.
\end{agdalisting}

There is ``slop'' in the type of split enumerability: there are more distinct
values than there are \emph{usefully} distinct values.
As we can see in the example above, for instance, split enumerability allows
duplicate values in the support list.
To reconcile this, we will disallow duplicates in the support list.

How exactly we should do this is the next question.
One approach might be to change the definition of \(\mathbf{List}\), or
introduce a new type \(\mathbf{NoDupeList}\), and use it in the predicate
instead.
However, this would mean we lose access to the functions we have defined on
lists, and we have to change the definition of \(\in\) as well.

There is a much simpler and more elegant solution: we insist that every
\emph{membership proof} must be unique.
This would disallow a definition of \(\mathcal{E}!(\mathbf{Bool})\) with
duplicates, as there are multiple values which inhabit the type \(\text{false}
\in \left[ \text{false}, \text{true}, \text{false} \right]\).
It also allows us to keep most of the split enumerability definition unchanged,
just adding a condition to the returned membership proof in the cover proof.

To specify that a value must exist uniquely in HoTT we can use the concept of a
\emph{contraction}.
\begin{definition}[Unique Membership] \label{uniq-memb-def}
  Unique list membership is defined in terms of list membership: it is a
  contraction of it.
  \begin{equation}
    x \inunique \mathit{xs} \coloneqq \text{isContr}(x \in \mathit{xs})
  \end{equation}
\end{definition}
With this we can define manifest Bishop finiteness:
\begin{definition}[Manifest Bishop Finiteness]  \label{bish-def}
  A type is manifest Bishop finite if there exists a list which contains each
  value in the type once.
  \begin{equation}
    \mathcal{B}(A) \coloneqq \Sigma {(\mathit{xs} : \textbf{List}(A))} , \Pi {(x : A)} , x \inunique xs
  \end{equation}
\end{definition}
The only difference between manifest Bishop finiteness and split enumerability
is the membership term: here we require unique membership (\(\inunique\)),
rather than simple membership (\(\in\)).

We use the word ``manifest'' here to distinguish from another common
interpretation of Bishop finiteness, which we have called cardinal finiteness in
this paper.
The ``manifest'' refers to the fact that we have a concrete, non-truncated list
of the elements in the proof.

\subsection{The Relationship Between Manifest Bishop Finiteness and Split
  Enumerability}
While manifest Bishop finiteness might seem stronger than split enumerability,
it turns out this is not the case.
Both predicates imply the other.
\begin{lemma} \label{manifest-bishop-to-split-enum}
  Any manifest Bishop finite type is split enumerable.
\end{lemma}
\begin{proof}
  To construct a proof of split enumerability from one of manifest Bishop
  finiteness, it suffices to convert a proof of \(x \inunique \mathit{xs}\) to
  one of \(x \in \mathit{xs}\), for all \(x\) and \(\mathit{xs}\).
  Since \(\inunique\) is defined as a contraction of \(\in\), such a conversion
  is simply the \(\text{fst}\) function.
\end{proof}

\begin{lemma} \label{split-enum-to-manifest-bishop}
  Any split enumerable set is manifest Bishop finite.
\end{lemma}
This proof takes significantly more work.
The ``unique membership'' condition in \(\mathcal{B}\) means that we are not
permitted duplicates in the support list.
The first step in the proof, then, is to filter those duplicates out from the
support list of the \(\mathcal{E}!\) proof: we can do this using the decidable
equality provided by \(\mathcal{E}!\) (lemma~\ref{split-enum-discrete}).
From there, we need to show that the membership proof carries over
appropriately.
\todo{Provide more info on this proof?}

We have now proved that every manifestly Bishop finite type is split enumerable,
and vice versa.
While the types are not \emph{equivalent} (there are more split enumerable
proofs than there are manifest Bishop finite proofs), they are of equal power,
so any closure proof we have on one can be transferred to the other.
In particular, it means that manifest Bishop finiteness is closed under
\(\Sigma\).
\subsection{From Manifest Bishop Finiteness to Equivalence}
We have seen that split enumerability was in fact a split-surjection in
disguise.
We will now see that manifest Bishop finiteness is in fact an \emph{equivalence}
in disguise.
\emph{equivalence} with \(\mathbf{Fin}\).
\begin{lemma} \label{bishop-equiv}
  Manifest bishop finiteness is equivalent to an equivalence to a finite prefix
  of the natural numbers.
  \begin{equation}
    \mathcal{B}(A) \simeq \Sigma {(n : \mathbb{N})} , \left( \mathbf{Fin}(n) \simeq A \right)
  \end{equation}
\end{lemma}
\begin{proof}
  \begin{align*}
     \mathcal{B}(A) &
    \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , x \inunique \mathit{xs}
    && \text{def.~\ref{bish-def} }(\mathcal{B})
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \text{isContr}(x \in \mathit{xs})
    && \text{eqn.~\ref{uniq-memb-def} } (\inunique)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \text{isContr}(\text{fib}_{\text{snd}(\mathit{xs})}(x))
    && \text{eqn.~\ref{container-membership} } (\in)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \text{isEquiv}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{is-equiv-def} (isEquiv)}
    \\
    & \simeq \Sigma (\mathit{xs} : \llbracket \mathbb{N} , \mathbf{Fin} \rrbracket (A)) , \text{isEquiv}(\text{snd}(\mathit{xs}))
    && \text{def.~\ref{List} } (\mathbf{List})
    \\
    & \simeq \Sigma (\mathit{xs} : \Sigma (n : \mathbb{N}) , \Pi (i : \mathbf{Fin}(n)) , A) , \text{isEquiv}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{container-interp} } (\llbracket \wc \rrbracket)
    \\
    & \simeq \Sigma (n : \mathbb{N}) , \Sigma (f : \mathbf{Fin}(n) \rightarrow A) , \text{isEquiv}(f)
    && \text{Reassociation of } \Sigma
    \\
    & \simeq \Sigma (n : \mathbb{N}) , ( \mathbf{Fin}(n) \simeq A )
    && \text{eqn.~\ref{equiv-def} } (\simeq) \; \qedhere
  \end{align*}
\end{proof}
This proof is almost identical\footnotemark to the proof for
lemma~\ref{split-enum-is-split-surj}: it reveals that
enumeration-based finiteness predicates are simply another perspective on
relation-based ones.
\footnotetext{
  Unfortunately in our formalisation this proof cannot be a single line: for
  performance reasons \(\simeq\) is defined as a record type with eta-equality
  disabled, instead of the definition here which uses \(\Sigma\).
}

As we are working in CuTT, a proof of equivalence between two types gives us the
ability to \emph{transport} proofs from one type to the other.
This is extremely powerful, as we will see.
\subsection{Closure Under \(\Pi\)}
The glaring omission from our closure proofs under type formers so far has been
the \(\Pi\) type: we have not proved closure under functions, dependent or
otherwise.
In MLTT, this is of course not provable: since all of the finiteness predicates
we have seen so far imply decidable equality, and since we don't have any kind
of decidable equality on functions in MLTT, we know that we won't be able to
show that any kind of function is finite; even one like \(\mathbf{Bool}
\rightarrow \mathbf{Bool}\).

CuTT is not so restricted.
Since we have things like function extensionality and transport, we can indeed
prove the finiteness of function types.
Our proof here makes use directly of the univalence axiom, and makes use
furthermore of all the previous closure proofs.
We will prove this closure on split enumerability, rather than on manifest
Bishop finiteness, as it requires slightly less legwork in the proof itself, but
of course we can derive the proof on manifest Bishop finiteness in a few lines.
\begin{theorem} \label{split-enum-pi}
  Split enumerability is closed under dependent functions.
  (\(\Pi\)-types).
  \begin{equation}
    \frac{
      \mathcal{E}!(A) \; \; \; \Pi {(x : A)} , \mathcal{E}!\left( U(x) \right)
    }{
      \mathcal{E}!\left(\Pi {(x : A)} , U(x)\right)
    }
  \end{equation}
\end{theorem}
\begin{proof}
  Let \(A\) be a split enumerable type, and \(U\) be a type family from \(A\),
  which is split enumerable over all points of \(A\).

  As \(A\) is split enumerable, we know that it is also manifestly Bishop finite
  (lemma~\ref{split-enum-to-manifest-bishop}), and consequently we know \(A
  \simeq \mathbf{Fin}(n)\), for some \(n\) (lemma~\ref{bishop-equiv}).
  We can therefore replace all occurrences of \(A\) with \(\mathbf{Fin}(n)\),
  changing our goal to:
  \begin{equation}
    \frac{
      \mathcal{E}!(\mathbf{Fin}(n)) \; \; \; \Pi (x : \mathbf{Fin}(n)) , \mathcal{E}!\left( U(x) \right)
    }{
      \mathcal{E}!\left(\Pi (x : \mathbf{Fin}(n)) , U(x)\right)
    }
  \end{equation}
  
  We then define the type of \(n\)-tuples over some type family \(T :
  \mathbf{Fin}(n) \rightarrow \mathbf{Type}\).
  \begin{equation}
    \begin{alignedat}{3}
      & \mathbf{Tuple}(0, T)   &&\coloneqq \top \\
      & \mathbf{Tuple}(n+1, T) &&\coloneqq T(0) \times \mathbf{Tuple}(n, T \circ \text{suc})
    \end{alignedat}
  \end{equation}
  We can show that this type is equivalent to functions (proven in our formalisation):
  \begin{equation}
    \Pi(x : \mathbf{Fin}(n)) , U(x) \simeq \mathbf{Tuple}(n, U)
  \end{equation}
  And therefore we can simplify again our goal to the following:
  \begin{equation}
    \frac{
      \mathcal{E}!(\mathbf{Fin}(n)) \; \; \; \Pi (x : \mathbf{Fin}(n)) , \mathcal{E}!\left( U(x) \right)
    }{
      \mathcal{E}!\left(\mathbf{Tuple}(n, U)\right)
    }
  \end{equation}
  
  We can prove this goal by showing that \(\mathbf{Tuple}(n, U)\) is split
  enumerable: it is made up of finitely many products of points of \(U\), which
  are themselves split enumerable, and \(\top\), which is also split enumerable.
  Lemma~\ref{split-enum-sigma} shows us that the product of finitely many split
  enumerable types is itself split enumerable, proving our goal.
\end{proof}
\section{Cardinal Finiteness} \label{cardinal-finiteness}
While we have removed some of the unnecessary information from our finiteness
predicates, one piece still remains.
\begin{agdalisting}
  The two following proofs are both valid proofs of the finiteness of
  \(\mathbf{Bool}\), and both do not include any duplicates.
  However they still differ:
  \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{bool-inst} \smallskip
  \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{bool-rev}
\end{agdalisting}
Each finiteness predicate so far has contained an \emph{ordering} of the
underlying type.
For our purposes, this is too much information: it means that when constructing
the ``category of finite sets'' later on, instead of each type having one
canonical representative, it will have \(n!\), where \(n\) is the cardinality of
the type\footnotemark.

\footnotetext{
  We actually do get a category (a groupoid, even) from manifest Bishop
  finiteness \cite{yorgeyCombinatorialSpeciesLabelled2014}: it's the groupoid of
  finite sets equipped with a linear order, whose morphisms are order-preserving
  bijections.
  We do not explore this particular construction in any detail.
}

To remedy the problem, we will use propositional truncation
(def.~\ref{prop-trunc}).
\begin{definition}[Cardinal Finiteness]
  A type \(A\) is cardinally finite if there exists a propositionally truncated
  proof that \(A\) is manifest Bishop finite or equivalent to a finite prefix of
  the natural numbers.
  \begin{equation}
    \mathcal{C}(A) \coloneqq \lVert \mathcal{B}(A) \rVert \simeq \lVert \Sigma(n : \mathbb{N}) , (\mathbf{Fin}(n) \simeq A) \rVert
  \end{equation}
\end{definition}
At first glance, it might seem that we lose any useful properties we could
derive from \(\mathcal{B}\).
Luckily, this is not the case: by eliminator \ref{elim-prop-coh} of
def.~\ref{prop-trunc}, we need only show that the output is uniquely determined.
\subsection{Deriving Uniquely-Determined Quantities}
The following two lemmas are proven in
\cite{yorgeyCombinatorialSpeciesLabelled2014} (Proposition 2.4.9 and 2.4.10,
respectively), in much the same way as we have done here.
Our contribution for this section is simply the formalisation.
\begin{lemma}
  Given a cardinally finite type, we can derive the type's cardinality, as well
  as a propositionally truncated proof of equivalence with \(\textbf{Fin}\)s of
  the same cardinality.
  \begin{equation}
    \mathcal{C}(A) \rightarrow \Sigma {(n : \mathbb{N})} , \lVert \textbf{Fin}(n) \simeq A \rVert
  \end{equation}
\end{lemma}
\begin{proof}
  Let \(A\) be a cardinally-finite type, with proof \(F : \mathcal{C}(A)\).
  Our task is to extract a natural number \(n : \mathbb{N}\) representing the
  cardinality of \(A\), and a propositionally-truncated proof that \(A\) is
  equivalent to \(\mathbf{Fin}(n)\).

  Extracting the second component of the pair is trivial, as it itself is
  truncated.
  We will now focus on extracting the cardinality.

  Without the propositional truncation, \(\text{fst}\) would suffice for this
  task.
  Given that the pair is hidden under the truncation, then, we need a way to
  convert a function \(f : A \rightarrow B\) to \(g : \lVert A \rVert
  \rightarrow B\).
  This is precisely what eliminator \ref{elim-prop-coh} gives us.
  For our case, we need to show the following:
  \begin{equation}
    \frac{(n : \mathbb{N}) \; \; \; (p : \mathbf{Fin}(n) \simeq A) \; \; \;
          (m : \mathbb{N}) \; \; \; (q : \mathbf{Fin}(m) \simeq A)
        }{
          n \equiv m
        }
  \end{equation}
  Immediately we can construct the following term:
  \begin{equation}
    \begin{alignedat}{3}
      \mathbf{Fin}(n) & \simeq A && (p) \\
                      & \simeq \mathbf{Fin}(m) && (q)
    \end{alignedat}
  \end{equation}
  Given univalence we have \(\mathbf{Fin}(n) \equiv \mathbf{Fin}(m)\),
  and the rest of our task is to prove:
  \begin{equation}
    \frac{\mathbf{Fin}(n) \equiv \mathbf{Fin}(m)}{n \equiv m}
  \end{equation}

  This is a well-known chestnut in dependently-typed programming, and one that
  has a surprisingly tricky and complex proof.
  We do not include it here, since it has already been explored elsewhere, but
  it is present in our formalisation.
\end{proof}

In order to prove that cardinal finiteness implies decidable equality, we will
need to show that decidable equality itself is a proposition.
In doing that we will use the following lemma:
\begin{lemma} \label{prop-refute}
  We can ``refute'' a propositionally-truncated proof of some proposition with a
  proof that the non-truncated proposition is false.
  \begin{equation}
    \frac{\neg A \; \; \; \lVert A \rVert}{\bot}
  \end{equation}
\end{lemma}
\begin{proof}
  We know we can eliminate from any value of type \(\lVert A \rVert\) into some
  \(B\) with a function \(A \to B\) if \(B\) is a proposition.
  That's precisely what we do in this case: \(\neg A\) is a function of type \(A
  \to \bot\), and we know that \(\bot\) is a proposition.
\end{proof}

\begin{lemma} \label{cardinal-finite-discrete}
  Any cardinal-finite set has decidable equality.
\end{lemma}
\begin{proof}
  Since we can already derive decidable equality from a proof of manifest Bishop
  finiteness, it suffices to show that decidable equality is itself a
  proposition.
  \begin{equation}
    \text{isProp}(\Pi(x, y : A) , \mathbf{Dec}(x \equiv y))
  \end{equation}
  First, it is clear that \(x \equiv y\) is a proposition: since the type \(A\)
  has decidable equality, by Hedburg's theorem it is a set,
  meaning precisely that \(x \equiv y\) is a proposition.

  Secondly, we know that any decision over a proposition is itself a
  proposition.
  For any two terms \(x, y: \mathbf{Dec}(A)\) we cannot have the case that one
  is a yes decision and the other is no: from that we could derive \(\bot\).
  If both are no then they are both equal since \(A \rightarrow \bot\) is a
  proposition through function extensionality.
  And finally if both are yes then we know they must be equal because the type
  decided over is itself a proposition.

  Finally, since we know that \(\mathbf{Dec}(x \equiv y)\) is a proposition, we
  can derive that \(\Pi(x, y : A) , \mathbf{Dec}(x \equiv y)\) is a proposition
  (through function extensionality), proving our goal.
\end{proof}
\subsection{Restrictiveness}
So far our explorations into finiteness predicates have pushed us in the
direction of ``less informative'': however, as mentioned in the introduction, we
can \emph{also} ask how \emph{restrictive} certain predicates are.
Since split enumerability and manifest Bishop finiteness imply each other we
know that there can be no type which satisfies one but not the other.
We also know that manifest Bishop finiteness implies cardinal finiteness, but we
do \emph{not} have a function in the other direction:
\begin{equation}
  \mathcal{C}(A) \rightarrow \mathcal{B}(A)
\end{equation}
So the question arises naturally: is there a cardinally finite type which is
\emph{not} manifest Bishop finite?

It turns out the answer is no!
\begin{lemma}
  \begin{equation}
    \neg (\Sigma(A : \mathbf{Type}) , \mathcal{C}(A) \times \neg \mathcal{B}(A))
  \end{equation}
\end{lemma}
\begin{proof}
  We will actually prove a slightly more general statement.
  For any type \(A\), the following holds:
  \begin{equation}
    \neg (\lVert A \rVert \times \neg A)
  \end{equation}
  The solution becomes more clear if we write out the definition of \(\neg\):
  \begin{equation}
    \frac{\lVert A \rVert \;\;\; A \rightarrow \bot }{\bot}
  \end{equation}
  We clearly need to apply a function of type \(A \rightarrow \bot\) to a value
  of type \(\lVert A \rVert\).
  Luckily, this is permissible, as \(\bot\) is a mere proposition.
\end{proof}

\subsection{Going from Cardinal Finiteness to Manifest Bishop Finiteness}
\begin{lemma} \label{manifest-bishop-to-cardinal}
  Any manifest Bishop finite type is cardinal finite.
\end{lemma}
\begin{theorem} \label{cardinal-to-manifest-bishop}
  Any cardinal finite type with a total order is Bishop finite.
\end{theorem}
The proof for this particular theorem is quite involved in the formalisation, so
we only give its sketch here.
First, note that we actually convert to manifest enumerability first: this can
be converted to split enumerability with decidable equality, which is provided
by cardinal finiteness.

Next, we define permutations.
\begin{definition}[List Permutations]
  Two lists are permutations of each other if their membership proofs are all
  equivalent\footnotemark \cite{danielssonBagEquivalenceProofRelevant2012}.
  \begin{equation}
    \mathit{xs} \leftrightsquigarrow \mathit{ys} = \Pi {(x : A)} , x \in \mathit{xs} \simeq x \in \mathit{ys}
  \end{equation}
\end{definition}

\footnotetext{
  The definition in \cite{danielssonBagEquivalenceProofRelevant2012} and our
  formalisation is slightly different: we say permutations are lists with
  \emph{isomorphic} membership proofs.
  The distinction, as it happens, does not affect our work here.
}

Next, we define a sort function which relies on the provided total order.
We further prove the following fact about this sort function:
\begin{equation}
  \Pi(\mathit{xs}, \mathit{ys} : \mathbf{List}(A)) , \mathit{xs} \leftrightsquigarrow \mathit{ys} \rightarrow \text{sort}(\mathit{xs}) \equiv \text{sort}(\mathit{ys})
\end{equation}

Next, notice that the support lists of any two proofs of manifest Bishop
finiteness must be permutations of each other.
This will allow us to sort the support list of a proof of cardinal finiteness in
a coherently constant (definition~\ref{prop-trunc},
eliminator~\ref{elim-prop-coh}) way, pulling the support list out from the
truncation.
The cover proof emerges naturally from the definition of the permutation.
\subsection{Closure}
Since we don't have a function of type \(\mathcal{C}(A) \rightarrow
\mathcal{B}(A)\), closure proofs on \(\mathcal{B}\) do not transfer over to
\(\mathcal{C}\) trivially (unlike with \(\mathcal{E}!\) and \(\mathcal{B}\)).
The cases for \(\bot\), \(\top\), and \(\mathbf{Bool}\) are simple to adapt: we
can just propositionally truncate their Bishop finiteness proof.

Non-dependent operators like \(\times\), \(\uplus\), and \(\rightarrow\) are
also relatively straightforward: since \(\lVert {\wc} \rVert\) forms a monad, we
can apply \(n\)-ary functions to values inside it, combining them together.
\begin{agdalisting}
  The fact that \(\lVert \wc \rVert\) forms a monad means that we can lift
  \(n\)-ary functions like the following:
  \ExecuteMetaData[agda/Cardinality/Finite/ManifestBishop.tex]{times-clos-sig}
  Into a truncated context:
  \ExecuteMetaData[agda/Cardinality/Finite/Cardinal.tex]{times-clos-impl}
\end{agdalisting}

Unfortunately, for the dependent type formers like \(\Sigma\) and \(\Pi\), the
same trick does not work.
We have closure proofs like:
\begin{equation}
  \frac{
    \mathcal{B}(A) \; \; \; \Pi(x : A) , \mathcal{B}(U(x))
  }{
    \mathcal{B}(\Pi \; A \; U)
  }
\end{equation}
If we apply the monadic truncation trick we can derive closure proofs like the
following:
\begin{equation}
  \frac{
    \lVert \mathcal{B}(A) \rVert \; \; \; \lVert \Pi(x : A) , \mathcal{B}(U(x)) \rVert
  }{
    \lVert \mathcal{B}(\Pi \; A \; U) \rVert
  }
\end{equation}
However our \emph{desired} closure proof is the following:
\begin{equation}
  \frac{
    \lVert \mathcal{B}(A) \rVert \; \; \; \Pi(x : A) , \lVert \mathcal{B}(U(x)) \rVert
  }{
    \lVert \mathcal{B}(\Pi \; A \; U) \rVert
  }
\end{equation}
They don't match!

The solution would be to find a function of the following type:
\begin{equation}
  (\Pi(x : A) , \lVert \mathcal{B}(U(x)) \rVert) \rightarrow
  \lVert \Pi(x : A) , \mathcal{B}(U(x)) \rVert
\end{equation}
However we might be disheartened at realising that this is a required goal: the
above equation is \emph{extremely} similar to the axiom of choice!
\begin{definition}[Axiom of Choice]
  In HoTT, the axiom of choice is commonly defined as follows \cite[lemma
  3.8.2]{hottbook}.
  For any set \(A\), and a type family \(U\) which is a set at all the points
  of \(A\), the following function exists:
  \begin{equation}
    \left( \Pi(x : A) ,  \lVert U(x) \rVert \right) \rightarrow \lVert \Pi(x : A) , U(x) \rVert
  \end{equation}
\end{definition}
Luckily the axiom of choice \emph{does} hold for cardinally finite types,
allowing us to prove the following:
\begin{lemma}
  \begin{equation}
    \mathcal{C}(A) \rightarrow (\Pi(x : A) , \lVert U(x) \rVert) \rightarrow \lVert \Pi(x : A) , U(x) \rVert
  \end{equation}
\end{lemma}
\begin{proof}
  Let \(A\) be a cardinally finite type, \(U\) be a type family on \(A\), and
  \(f\) be a dependent function of type \(\Pi(x : A) , \lVert U(x) \rVert\).

  First, since our goal is itself propositionally truncated, we have access to
  values under truncations: put another way, in the context of proving our goal,
  we can rely on the fact that \(A\) is manifestly Bishop finite.
  Using the same technique as we did in lemma~\ref{split-enum-pi}, we can switch
  from working with dependent functions from \(A\) to \(n\)-tuples, where \(n\)
  is the cardinality of \(A\).
  This changes our goal to the following:
  \begin{equation}
    \mathbf{Tuple}(n, \lVert \wc \rVert \circ U) \rightarrow \lVert \mathbf{Tuple}(n, U) \rVert
  \end{equation}
  Since \(\lVert \wc \rVert\) is closed under finite products, this function
  exists (in fact, using the fact that \(\lVert \wc \rVert\) forms a monad, we
  can recognise this function as \verb+sequenceA+ from the \verb+Traversable+
  class in Haskell).
\end{proof}


This gets us all of the necessary closure proofs on \(\mathcal{C}\).
\section{Manifest Enumerability} \label{manifest-enumerability}
We have now explored quite far in the ``less informative'' direction.
However, all three predicates we have examined are equally \emph{restrictive}:
in this section we will see a predicate which is much less restrictive.
In particular, this predicate ranges over non-set types.

\begin{definition}[Manifest Enumerability]
  Manifest enumerability is an enumeration predicate like Bishop finiteness or
  split enumerability with the only difference being a propositionally truncated
  membership proof.
  \begin{equation}
    \mathcal{E}(A) \coloneqq \Sigma {(\mathit{xs} : \mathbf{List}(A))} , \Pi {(x : A)} , \lVert x \in \mathit{xs} \rVert
  \end{equation}
\end{definition}
As a function-based definition, this predicate represents surjections.
\begin{lemma}
  Manifest enumerability is equivalent to a surjection from a finite prefix of
  the natural numbers.
  \begin{equation}
    \mathcal{E}(A) \simeq \Sigma(n : \mathbb{N}) , (\mathbf{Fin}(n) \twoheadrightarrow A)
  \end{equation}
\end{lemma}
\begin{proof}
  \begin{align*}
     \mathcal{E}(A) &
    \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \lVert x \in \mathit{xs} \rVert
    && \text{def.~\ref{split-enum-def} }(\mathcal{E})
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \lVert \text{fib}_{\text{snd}(\mathit{xs})}(x) \rVert
    && \text{eqn.~\ref{container-membership} } (\in)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \text{surj}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{surj-eqn} (surj)}
    \\
    & \simeq \Sigma (\mathit{xs} : \llbracket \mathbb{N} , \mathbf{Fin} \rrbracket (A)) , \text{surj}(\text{snd}(\mathit{xs}))
    && \text{def.~\ref{List} } (\mathbf{List})
    \\
    & \simeq \Sigma (\mathit{xs} : \Sigma (n : \mathbb{N}) , \Pi (i : \mathbf{Fin}(n)) , A) , \text{surj}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{container-interp} } (\llbracket \wc \rrbracket)
    \\
    & \simeq \Sigma (n : \mathbb{N}) , \Sigma (f : \mathbf{Fin}(n) \rightarrow A) , \text{surj}(f)
    && \text{Reassociation of } \Sigma
    \\
    & \simeq \Sigma (n : \mathbb{N}) , ( \mathbf{Fin}(n) \twoheadrightarrow A )
    && \text{eqn.~\ref{surj-arrow-eqn} } (\twoheadrightarrow) \; \qedhere
  \end{align*}
\end{proof}
\subsection{Instances for Non-Set Types}
The truncation has another very important implication: it means that the
predicate doesn't provide decidable equality on the underlying type.
Remember, this is how we knew that our previous predicates wouldn't allow for
non-set types: because they implied decidable equality, they also implied that
all conforming types had homotopy levels of at most 2. \todo{Are we doing the
  homotopy levels starting from -2 thing or from 0?}
This suggests that non-set types like the circle could conform to this
finiteness predicate.
\begin{definition}[\(S^1\)] \label{circle-def}
  The circle, \(S^1\), can be represented in HoTT as a higher inductive type.
  \begin{equation}
    \begin{alignedat}{3}
      S^1 \coloneqq & \; \text{base} &&: S^1 ; \\
      | & \; \text{loop} &&: \text{base} \equiv \text{base} ; 
    \end{alignedat}
  \end{equation}
  We will use it here as an example of a non-set type, i.e. a type for which not
  all paths are equal.
  This also means that it does not have decidable equality.
\end{definition}
\begin{lemma}
  The circle \(S^1\) is manifestly enumerable.
\end{lemma}
\begin{proof}
  The support list firstly is a list containing the point constructor for the
  circle.
  Since the cover proof is truncated, we need only consider the point
  constructors of the circle: as such, the cover proof is essentially the same
  as the one for \(\mathcal{E}!(\top)\).
\end{proof}
\subsection{Relation To Split Enumerability}
It is trivially easy to construct a proof that any split enumerable type is
manifest enumerable: we simply truncate the membership proof.
Going the other was requires us to extract a non-truncated proof from a
truncated one.
This proof relies on the following lemma:
\begin{lemma}
  We can ``recompute'' a truncated proof given a decision over a proof of the
  same type.
  \begin{equation}
    \frac{\lVert A \rVert \; \; \; \mathbf{Dec}(A)}{A}
  \end{equation}
\end{lemma}
\begin{proof}
  We proceed by case-analysis over the decision over \(A\).
  In the case where \(A\) is proven, we are done.
  In the case where \(A\) is disproven, we use lemma~\ref{prop-refute} to
  derive impossibility.
\end{proof}

\begin{lemma} \label{manifest-enum-to-split-enum}
  A manifestly enumerable type with decidable equality is split enumerable.
\end{lemma}
\begin{proof}
  The only difference between manifest enumerability and split enumerability is
  the membership proof: therefor our goal for this proof is to construct a
  function of the following type:
  \begin{equation}
    \lVert x \in \mathit{xs} \rVert \rightarrow x \in \mathit{xs}
  \end{equation}
  Given decidable equality over the type of \(x\).

  We do this using the previous recompute lemma: that tells us that all we need
  to construct is a decision for \(x \in \mathit{xs}\), and it will be able to
  derive the proof itself.
  Such a decision procedure is not difficult to construct: for any value \(x\)
  and list \(\mathit{xs}\), we proceed through the list \(\mathit{xs}\), testing
  if \(x\) is equal to any of its contents.
  If it is, we return that we have proven the goal, and that \(x\) is indeed
  present in \(\mathit{xs}\).
  Otherwise, we know that \(x\) cannot be in \(\mathit{xs}\) (since we've tested
  every value), so we return that the goal has been disproven.
\end{proof}
\section{Kuratowski Finiteness} \label{kuratowski}
The one big missing definition of finiteness to cover is \emph{Kuratowski}
finiteness.
While it's quite important, it's also quite different from the definitions we've
seen so far.
It starts with an encoding of the free join semilattice.
\begin{definition}[Free Join Semilattice]
  \(\mathcal{K}(A)\) is the free join semilattice, or, alternatively, the type
  of Kuratowski-finite subsets of \(A\).
  \begin{inductivetype}{\mathcal{K}(A)}
    \inductivetypeclause{\left[ \right]}{\mathcal{K}(A)}
    \inductivetypeclause{\wc \dblcolon \wc}{A \rightarrow \mathcal{K}(A) \rightarrow \mathcal{K}(A)}
    \inductivetypeclause{\text{com}}{\Pi (x, y: A) , \Pi (\mathit{xs} : \mathcal{K}(A)) , x \dblcolon y \dblcolon \mathit{xs} \equiv y \dblcolon x \dblcolon \mathit{xs}}
    \inductivetypeclause{\text{dup}}{\Pi (x : A) , \Pi (\mathit{xs} : \mathcal{K}(A)) , x \dblcolon x \dblcolon \mathit{xs} \equiv x \dblcolon \mathit{xs}}
    \inductivetypeclause{\text{trunc}}{\Pi (\mathit{xs}, \mathit{ys}: \mathcal{K}(A)) , \Pi (p, q : \mathit{xs} \equiv \mathit{ys}) , p \equiv q}
  \end{inductivetype}
  We define it as a HIT (definition~\ref{HITs}).
  The first two constructors are point constructors, giving ways to create
  values of type \(\mathcal{K}(A)\).
  They are also recognisable as the two constructors for finite lists, a type
  which represents the free monoid.

  The next two constructors add extra paths to the type: equations that usage of
  the type must obey.
  These extra paths turn the free monoid into the free \emph{commutative} (com)
  \emph{idempotent} (dup) monoid.

  The final constructor enforces that the type \(\mathcal{K}(A)\) must be a set.
\end{definition}
The Kuratowski finite subset is a free join semilattice (or, equivalently, a
free commutative idempotent monoid).
More prosaically, \(\mathcal{K}\) is the abstract data type for finite sets, as
defined in the Boom hierarchy \cite{boomFurtherThoughtsAbstracto1981,
  bunkenburgBoomHierarchy1994}.
However, rather than just being a specification, \(\mathcal{K}\) is fully usable
as a data type in its own right, thanks to HITs.

Other definitions of \(\mathcal{K}\) exist (such as the one in
\cite{fruminFiniteSetsHomotopy2018}) which make the fact that \(\mathcal{K}\) is
the free join semilattice more obvious.
We have included such a definition in our formalisation, and proven it
equivalent to the one above.

Next, we need a way to say that an entire type is Kuratowski finite.
For that, we will need to define membership of \(\mathcal{K}\).
\begin{definition}[Membership of \(\mathcal{K}\)]
  Membership is defined by pattern-matching on \(\mathcal{K}\).
  The two point constructors are handled like so:
  \begin{equation}
    \begin{alignedat}{2}
      x \in&& \; []                      &\coloneqq \bot ; \\
      x \in&& \; y \dblcolon \mathit{ys} &\coloneqq \lVert x \equiv y \uplus x \in \mathit{ys} \rVert ;
    \end{alignedat}
  \end{equation}
  The \(\text{com}\) and \(\text{dup}\) constructors are handled by proving that
  the truncated form of \(\uplus\) is itself commutative and idempotent.
  The type of propositions is itself a set, satisfying the \(\text{trunc}\)
  constructor.
\end{definition}
Finally, we have enough background to define Kuratowski finiteness.
\begin{definition}[Kuratowski Finiteness]
  \begin{equation}
    \mathcal{K}^{f}(A) = \Sigma {(\mathit{xs} : \mathcal{K}(A))} , \Pi (x : A) , x \in \mathit{xs}
  \end{equation}
\end{definition}

We also have the following two lemmas, proven in both
\cite{fruminFiniteSetsHomotopy2018} and our formalisation.
\begin{lemma}
  \(\mathcal{K}^f\) is a mere proposition.
\end{lemma}
\begin{lemma}
  This circle \(S^1\) is Kuratowski finite.
\end{lemma}
\subsection{Relation to Cardinal Finiteness}
\begin{lemma} \label{cardinal-kuratowski}
  Cardinal finiteness is equivalent to Kuratowski finiteness over a discrete
  set.
  \begin{equation}
    \mathcal{C}(A) \simeq \mathcal{K}^f(A) \times \text{Discrete}(A)
  \end{equation}
\end{lemma}
This proof is constructed by providing a pair of functions: one from
\(\mathcal{C}(A)\) to \(\mathcal{K}^f(A) \times \text{Discrete}(A)\), and one the
other way.
This pair implies an equivalence, because both source and target are
propositions.
The actual functions themselves are proven in our formalisation, as well as in
\cite{fruminFiniteSetsHomotopy2018}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: