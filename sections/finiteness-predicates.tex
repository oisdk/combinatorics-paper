\chapter{Finiteness Predicates} \label{finiteness-predicates}
In this section, we will define and briefly describe each of the five predicates
in Figure~\ref{finite-classification}.
We will also explain \emph{why} there are five separate predicates: how can it
be the case that so many different things describe ``finiteness''?
As we will see, some predicates are too informative (they
tell us more about the underlying type other than it just being finite), or too
restrictive (they don't allow certain finite types to be classified as finite).
These diversions won't be dead-ends, however: the final predicate we will land
on as the ``correct'' (or, more accurately, most useful) notion of finiteness
will be built out of all of the others.
\section{Split Enumerability} \label{split-enumerability}
We will start with a simple notion of finiteness, called split enumerability.
This predicate is perhaps the first definition of ``finite'' that someone might
come up with (it's certainly the most common in dependently-typed programming):
put simply, a split enumerable type is a type for which all of its elements can
be listed.
\begin{definition}[Split Enumerable Set] \label{split-enum-def}
  To say that some type \(A\) is split enumerable is to say that there is a list
  \(\mathit{support} : \AgdaDatatype{List}(A)\) such that any value \(x : A\) is in
  \(\mathit{support}\).
  \begin{agdalisting} \label{split-enum-def-eqn}
    \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable/Container.tex]{split-enum-def}
  \end{agdalisting}
  We call the first component of this pair the ``support'' list, and the second
  component the ``cover'' proof.
  An equivalent version of this predicate was called \verb+Listable+ in
  \cite{firsovDependentlyTypedProgramming2015}.
\end{definition}

Simple as it is, this predicate is arguably the most useful of the finiteness
predicates.
We will see presently why it doesn't entirely capture what we mean by the term
``finite'', but we will nonetheless use it throughout the paper.
Before we dive in to exploring the predicate itself, though, we will need to
explain some of the terms we used in its definition.
\subsection{Terms used in the Definition of Split Enumerability}
We have used two types there which we have not yet defined:
\(\AgdaDatatype{List}\) and \(\AgdaDatatype{\ensuremath{\in}}\).
We will define them here.

\begin{definition}[\(\AgdaDatatype{List}\)] \label{List}
  In this paper we will work with two equivalent definitions of lists.
  The first is the standard definition as an inductive type:
  \begin{agdalisting}
    \ExecuteMetaData[agda/Data/List/Base.tex]{list-def}
  \end{agdalisting}

  The second way to define lists is to define them as a \emph{container}:
  \begin{agdalisting}
    \ExecuteMetaData[agda/Container/List.tex]{list-def}
  \end{agdalisting}
  The reason we use this second strange definition is that it turns out to be
  quite useful in some later proofs.
  We have proven the two types equivalent in our formalisation, however, so we
  can switch between them freely without loss of generality.
\end{definition}

In defining lists we have introduced another concept which needs defining:
\(\AgdaDatatype{Fin}\).
\begin{definition}[\(\AgdaDatatype{Fin}\)] \label{Fin}
  \(\AgdaDatatype{Fin}\;n\) is the type of natural numbers smaller than \(n\). We
  define it the standard way:
  \begin{agdalisting}
    \ExecuteMetaData[agda/Data/Fin/Base.tex]{fin-def}
  \end{agdalisting}
\end{definition}
Here \(\uplus\) refers to the disjoint union of two types.
\begin{definition}[Disjoint Union]
  We define disjoint union as an inductive type.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Introduction.tex]{disj-union}
  \end{agdalisting}
  It is also expressible with only \(\Sigma\):
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Introduction.tex]{sigma-disj-union}
  \end{agdalisting}
  Although the inductive type definition is slightly more ergonomic.
\end{definition}

After that interlude, we can get back to defining containers.
\begin{definition}[Containers] \label{container-def}
  A container \cite{abbottContainersConstructingStrictly2005} is a pair
  \(S , P\) where \(S\) is a type, the elements of which are called
  the \emph{shapes} of the container, and \(P\) is a type family on \(S\), where
  the elements of \(P(s)\) are called the \emph{positions} of a container.
  We ``interpret'' a container into a functor defined like so:
  \begin{agdalisting} \label{container-interp}
    \ExecuteMetaData[agda/Container.tex]{container-interp}
  \end{agdalisting}
\end{definition}

The definition of container is a little abstract: it is instructive to think of
it more concretely for the case of lists.
The container representing finite lists is a pair of a natural number \(n\)
representing the length of the list, and a function \(\AgdaDatatype{Fin}\;n\to
A\), representing the indexing function into the list.

\begin{definition}[Container Membership] \label{container-membership}
  Membership of a container can be defined like so:
  \begin{agdalisting} 
    \ExecuteMetaData[agda/Container/Membership.tex]{membership-def}
  \end{agdalisting}
  Where \(x\;\AgdaDatatype{\ensuremath{\in}}\;\mathit{xs}\) is to be read as ``\(x\)
  is in \(\mathit{xs}\)''.
\end{definition}
\begin{definition}[Fibers] \label{fibers}
  A fiber \cite[definition 4.2.4]{hottbook} is defined over some function \(f :
  A \rightarrow B\).
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Introduction.tex]{fiber}
  \end{agdalisting}
\end{definition}

Membership also makes more sense when described concretely in terms of lists.
Understood this way, \(x\;\AgdaDatatype{\ensuremath{\in}}\;\mathit{xs}\) means
``there is an index into \(\mathit{xs}\) such that the index points at an item
equal to \(x\)''.
\subsection{Split Surjections}
We will now look at how this predicate relates to more traditional, classical
notions of finiteness.
In a classical setting we likely wouldn't mention ``lists'' or the like, and
would instead define finiteness based on the existence of some injection or
surjection.
As it turns out, our definition of finiteness here is precisely the same as the
surjection-based one, in quite a deep way!

First, we will need to define our terms: in HoTT, surjections are a little more
complex than what you'd find in either MLTT or classical mathematics.
\begin{definition}[Split Surjections] \label{split-surjections}
  We define \emph{split} surjections here \cite[definition
  4.6.1]{hottbook}.
  \begin{agdalisting} \label{sp-surj-eqn}
    \ExecuteMetaData[agda/Function/Surjective/Base.tex]{split-surjective}
  \end{agdalisting} \vspace{-1.5\baselineskip}
  \begin{agdalisting} \label{sp-surj-arrow-eqn}
    \ExecuteMetaData[agda/Function/Surjective/Base.tex]{split-surjection}
  \end{agdalisting}
\end{definition}
Over sets, the surjections and split surjections are the same thing, but there
is a difference one we involve non-set types like the circle.

We will now see that split enumerability is in fact a split surjection in
another form:
\begin{lemma} \label{split-enum-is-split-surj}%
  A proof of split enumerability is equivalent to a split surjection from a
  finite prefix of the natural numbers.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{is-split-inj-type}
  \end{agdalisting}
\end{lemma}
\begin{proof} \let\qed\relax \vspace{-1\baselineskip}
  \begin{minipage}[t]{.7\textwidth}\vspace{-\baselineskip}
    \begin{agdalisting*}
      \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{is-split-inj}
    \end{agdalisting*}
  \end{minipage}
  \begin{minipage}[t]{.19\textwidth} \setstretch{1.1}

      Def.~\ref{split-enum-def} (\AgdaDatatype{\ensuremath{\mathcal{E}!}}) \\
      Eqn.~\ref{container-membership} (\AgdaDatatype{\ensuremath{\in}}) \\
      Eqn.~\ref{sp-surj-eqn}  \\
      Def.~\ref{List} (\(\AgdaDatatype{List}\)) \\
      Eqn.~\ref{container-interp}  \\
      Reassociation \\
      Eqn.~\ref{sp-surj-arrow-eqn}
  \end{minipage}
\end{proof}
In the above proof syntax the
\(\AgdaDatatype{\ensuremath{\equiv \langle{} \rangle{} }}\) connects lines which
are definitionally equal, i.e. they are ``obviously'' equal from the type
checker's perspective.
Clearly, only one line isn't a definitional equality: 
\begin{agdalisting}
  \ExecuteMetaData[agda/Data/Sigma/Properties.tex]{reassoc}
\end{agdalisting}
(The simplicity of this proof, by the way, is why we preferred the
container-based definition of lists over the traditional one.)
\subsection{Instances}
We have now characterised the informativeness of split enumerability (it's the
same as a split surjection), so we should also look at its
\emph{restrictiveness}.
For this we'll first look at some simple types which are clearly finite, and
we'll see how to prove that's the fact using split enumerability.
\begin{lemma}
  \(\bot\), \(\top\), and \(\AgdaDatatype{Bool}\) are split enumerable.
\end{lemma}
\begin{proof}
  These three types are quite obviously finite: we will show only the proof of
  finiteness for \(\AgdaDatatype{Bool}\) here for brevity's sake.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{bool-inst}
  \end{agdalisting}
\end{proof}

As a slightly more complex example, consider the \(\AgdaDatatype{Fin}\) type
we've been using.
Remember that split enumerability is in fact the same as a split surjection from
\(\AgdaDatatype{Fin}\) (Lemma~\ref{split-enum-is-split-surj}): to show that
\(\AgdaDatatype{Fin}\) is split enumerable, then, we need only show that it has
a split surjection from itself.
We'll prove the following slightly more general statement:
\begin{lemma}
  Every type has a split surjection into itself: the identity function.
\end{lemma}
\begin{proof}
  We provide the simple proof here in Agda:
  \begin{agdalisting}
    \ExecuteMetaData[agda/Function/Surjective/Properties.tex]{split-surj-ident}
  \end{agdalisting}
\end{proof}
\subsection{Decidable Equality}
We have now seen some examples of types which \emph{are} split enumerable: but
what types are excluded?
Clearly infinite types like \(\AgdaDatatype{\ensuremath{\mathbb{N}}}\) aren't
allowed, but we haven't yet answered the question of non-set types.
Certainly these can be finite in some sense, but can they be split enumerable?

As our running example of a non-set type we will use the circle:
\begin{definition}[\(S^1\)] \label{circle-def}
  The circle, \(S^1\), can be represented in HoTT as a higher inductive type.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Circle.tex]{circle-def}
  \end{agdalisting}
  We will use it here as an example of a non-set type, i.e. a type for which not
  all paths are equal.
  This also means that it does not have decidable equality.
\end{definition}

Any attempt to prove that this type is split enumerable will run into trouble:
our task here, then, is to show that such a proof is impossible.
To do will remember Hedberg's theorem
\cite{hedbergCoherenceTheoremMartinLof1998}:
\begin{theorem}[Hedberg's Theorem]
  Every discrete type is a set.
\end{theorem}
With this theorem in mind, then, if we prove that every split enumerable type is
discrete we will have proven that the circle is not split enumerable, because if
it were it would be discrete and therefore a set, which we know already it is
not.

At this point we will define what we mean by \emph{discrete}.
\begin{definition}[Discrete Types]
  A discrete type is one with decidable equality.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Relation/Nullary/Discrete/Base.tex]{discrete-def}
  \end{agdalisting}
\end{definition}
We also use here a data type called \AgdaDatatype{Dec}.
\begin{definition}[Decidable Types]
  If some proposition is decidable it means that it is proven true or false.
  We can encapsulate this with a data type\footnotemark:
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Dec.tex]{dec-def}
  \end{agdalisting}
  A proof of type \(\AgdaDatatype{Dec}\;A\) is a proof that \(A\) is either true
  or false.
\end{definition}
\footnotetext{This is not, as it happens, the definition of
  \(\AgdaDatatype{Dec}\) you will find in Agda's standard library.
The version of the type that exists there is a good deal more complicated (for
computational reasons),
although its interface behaves}

Split enumerability implies decidable equality on the underlying type.
To prove this, we will make use of the following lemma, proven in the
formalisation:
\begin{definition}[Injections]
  Injective functions are more straightforward to define constructively than
  surjective ones:
  \begin{alignat}{3}
    & \text{injective}(f) &&\coloneqq \Pi (x, y : A) , f \; x \equiv f \; y \rightarrow x \equiv y \\
    & A \rightarrowtail B &&\coloneqq \Sigma(f : A \rightarrow B) , \text{injective}(f)
  \end{alignat}
\end{definition}
\begin{lemma} \label{split-surj-to-inj}
  A split-surjection from \(A\) to \(B\) implies an injection from \(B\) to
  \(A\).
  \begin{equation}
    (A \twoheadrightarrow! \; B) \rightarrow (B \rightarrowtail A)
  \end{equation}
\end{lemma}
\begin{lemma} \label{inj-discrete}
  For any type \(A\) which injects into a discrete type \(B\), \(A\) is
  discrete.
  \begin{equation}
    \frac{
      A \rightarrowtail B \; \; \; \text{Discrete}(B)
    }{
      \text{Discrete}(A)
    }
  \end{equation}
\end{lemma}


\begin{lemma} \label{discrete-surj}
  \begin{equation}
    \frac{
      A \twoheadrightarrow! \; B \; \; \; \text{Discrete}(A)
    }{
      \text{Discrete}(B) 
    }
  \end{equation}
\end{lemma}
\begin{proof}
  This proof is can be straightforwardly derived from lemmas
  \ref{split-surj-to-inj} and \ref{inj-discrete}.
\end{proof}

\begin{lemma} \label{split-enum-discrete}
  Every split enumerable type is discrete.
\end{lemma}
\begin{proof}
  Let \(A\) be a split enumerable type.
  By lemma~\ref{split-enum-is-split-surj}, there is a surjection from
  \(\AgdaDatatype{Fin}\;n\) for some \(n\).
  Also, we know that \(\AgdaDatatype{Fin}\;n\) is discrete (proven in our
  formalisation).
  Therefore, by lemma~\ref{discrete-surj}, \(A\) is discrete.
\end{proof}

\section{Manifest Bishop Finiteness} \label{manifest-bishop-finiteness}
We mentioned in the introduction that occasionally in constructive mathematics
proofs will contain ``too much'' information.
With split enumerability we can see an instance of this.
Consider the following proof of the finiteness of the operators for countdown:
\begin{agdalisting} \label{op-slop}
  \ExecuteMetaData[agda/Countdown.tex]{op-slop}
\end{agdalisting}
While it represents the ``same'' information as the proof in
equation~\ref{op-fin}, it clearly is not the same \emph{object}.

There is ``slop'' in the type of split enumerability: there are more distinct
values than there are \emph{usefully} distinct values.
For the purposes of solving countdown this has the undesirable effect of
duplicating search effort, but more generally this reveals that the predicate
for finiteness we have doesn't represent in a concise way what we intend it to
represent.
To reconcile this, we will disallow duplicates in the support list.

How exactly we should do this is the next question.
One approach might be to change the definition of \(\AgdaDatatype{List}\), or
introduce a new type \(\AgdaDatatype{NoDupeList}\), and use it in the predicate
instead.
However, this would mean we lose access to the functions we have defined on
lists, and we have to change the definition of \(\in\) as well.

There is a much simpler and more elegant solution: we insist that every
\emph{membership proof} must be unique.
This would disallow a definition of \(\AgdaDatatype{\ensuremath{\mathcal{E}!}}\;
\AgdaDatatype{Bool}\) with
duplicates, as there are multiple values which inhabit the type \(\text{false}
\in \left[ \text{false}, \text{true}, \text{false} \right]\).
It also allows us to keep most of the split enumerability definition unchanged,
just adding a condition to the returned membership proof in the cover proof.

To specify that a value must exist uniquely in HoTT we can use the concept of a
\emph{contraction}.

\begin{definition}[Homotopy Levels] \label{homotopy-types}
  Types in HoTT and CuTT are not necessarily sets, as they are in MLTT.
  Some have higher homotopies (paths which aren't unique).
  We actually have a hierarchy of complexity of structure of path spaces in
  types, starting with the contractions \cite[definition 3.11.1]{hottbook}, then
  the mere propositions \cite[definition 3.3.1]{hottbook}, and the sets
  \cite[definition 3.1.1]{hottbook}.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Introduction.tex]{hlevels}
  \end{agdalisting}
\end{definition}
\begin{definition}[Unique Membership] \label{uniq-memb-def}
  Unique list membership is defined in terms of list membership: it is a
  contraction of it.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Container/Membership.tex]{uniq-memb-def}
  \end{agdalisting}
\end{definition}

With this we can define manifest Bishop finiteness:
\begin{definition}[Manifest Bishop Finiteness]  \label{bish-def}
  A type is manifest Bishop finite if there exists a list which contains each
  value in the type once.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Cardinality/Finite/ManifestBishop/Container.tex]{bish-def}
  \end{agdalisting}
\end{definition}
The only difference between manifest Bishop finiteness and split enumerability
is the membership term: here we require unique membership (\(\inunique\)),
rather than simple membership (\(\in\)).

We use the word ``manifest'' here to distinguish from another common
interpretation of Bishop finiteness, which we have called cardinal finiteness in
this paper.
The ``manifest'' refers to the fact that we have a concrete, non-truncated list
of the elements in the proof.

\subsection{The Relationship Between Manifest Bishop Finiteness and Split
  Enumerability}
While manifest Bishop finiteness might seem stronger than split enumerability,
it turns out this is not the case.
Both predicates imply the other.
\begin{lemma} \label{manifest-bishop-to-split-enum}
  Any manifest Bishop finite type is split enumerable.
\end{lemma}
\begin{proof}
  To construct a proof of split enumerability from one of manifest Bishop
  finiteness, it suffices to convert a proof of \(x \inunique \mathit{xs}\) to
  one of \(x \in \mathit{xs}\), for all \(x\) and \(\mathit{xs}\).
  Since \(\inunique\) is defined as a contraction of \(\in\), such a conversion
  is simply the \(\text{fst}\) function.
\end{proof}

\begin{lemma} \label{split-enum-to-manifest-bishop}
  Any split enumerable set is manifest Bishop finite.
\end{lemma}
This proof takes significantly more work.
The ``unique membership'' condition in
\(\AgdaDatatype{\ensuremath{\mathcal{B}}}\) means that we are not permitted
duplicates in the support list.
The first step in the proof, then, is to filter those duplicates out from the
support list of the \(\AgdaDatatype{\ensuremath{\mathcal{E}!}}\) proof: we can do this using the decidable
equality provided by \(\AgdaDatatype{\ensuremath{\mathcal{E}!}}\) (lemma~\ref{split-enum-discrete}).
From there, we need to show that the membership proof carries over
appropriately.
\todo{Provide more info on this proof?}

We have now proved that every manifestly Bishop finite type is split enumerable,
and vice versa.
While the types are not \emph{equivalent} (there are more split enumerable
proofs than there are manifest Bishop finite proofs), they are of equal power,
so any closure proof we have on one can be transferred to the other.
In particular, it means that manifest Bishop finiteness is closed under
\(\Sigma\).
\subsection{From Manifest Bishop Finiteness to Equivalence}
We have seen that split enumerability was in fact a split-surjection in
disguise.
We will now see that manifest Bishop finiteness is in fact an \emph{equivalence}
in disguise.

\begin{definition}[Equivalences] \label{equivalences}
  We will take contractible maps \cite[definition 4.4.1]{hottbook} as our
  ``default'' definition of equivalences.
  \begin{agdalisting} \label{is-equiv-def}
    \ExecuteMetaData[agda/Snippets/Equivalence.tex]{is-equiv-def}
  \end{agdalisting} \vspace{-.5\baselineskip}
  \begin{agdalisting} \label{equiv-def}
    \ExecuteMetaData[agda/Snippets/Equivalence.tex]{equiv-def}
  \end{agdalisting}
\end{definition}
\begin{lemma} \label{bishop-equiv}
  Manifest bishop finiteness is equivalent to an equivalence to a finite prefix
  of the natural numbers.
  \begin{equation}
  \end{equation}
\end{lemma}
\begin{proof}
  \begin{align*}
     \AgdaDatatype{\ensuremath{\mathcal{B}}}(A) &
    \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , x \inunique \mathit{xs}
    && \text{def.~\ref{bish-def} }(\AgdaDatatype{\ensuremath{\mathcal{B}}})
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \text{isContr}(x \in \mathit{xs})
    && \text{eqn.~\ref{uniq-memb-def} } (\inunique)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \text{isContr}(\text{fib}_{\text{snd}(\mathit{xs})}(x))
    && \text{eqn.~\ref{container-membership} } (\in)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \text{isEquiv}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{is-equiv-def} (isEquiv)}
    \\
    & \simeq \Sigma (\mathit{xs} : \llbracket \mathbb{N} , \AgdaDatatype{Fin} \rrbracket (A)) , \text{isEquiv}(\text{snd}(\mathit{xs}))
    && \text{def.~\ref{List} } (\AgdaDatatype{List})
    \\
    & \simeq \Sigma (\mathit{xs} : \Sigma (n : \mathbb{N}) , \Pi (i : \AgdaDatatype{Fin}\;n) , A) , \text{isEquiv}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{container-interp} } (\llbracket \wc \rrbracket)
    \\
    & \simeq \Sigma (n : \mathbb{N}) , \Sigma (f : \AgdaDatatype{Fin}\;n \rightarrow A) , \text{isEquiv}(f)
    && \text{Reassociation of } \Sigma
    \\
    & \simeq \Sigma (n : \mathbb{N}) , ( \AgdaDatatype{Fin}\;n \simeq A )
    && \text{eqn.~\ref{equiv-def} } (\simeq) \; \qedhere
  \end{align*}
\end{proof}
This proof is almost identical\footnotemark to the proof for
lemma~\ref{split-enum-is-split-surj}: it reveals that
enumeration-based finiteness predicates are simply another perspective on
relation-based ones.
\footnotetext{
  Unfortunately in our formalisation this proof cannot be a single line: for
  performance reasons \(\simeq\) is defined as a record type with eta-equality
  disabled, instead of the definition here which uses \(\Sigma\).
}

As we are working in CuTT, a proof of equivalence between two types gives us the
ability to \emph{transport} proofs from one type to the other.
This is extremely powerful, as we will see.
\section{Cardinal Finiteness} \label{cardinal-finiteness}
While we have removed some of the unnecessary information from our finiteness
predicates, one piece still remains.
\begin{agdalisting}
  The two following proofs are both valid proofs of the finiteness of
  \(\AgdaDatatype{Bool}\), and both do not include any duplicates.
  However they still differ:
  \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{bool-inst} \smallskip
  \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{bool-rev}
\end{agdalisting}
Each finiteness predicate so far has contained an \emph{ordering} of the
underlying type.
For our purposes, this is too much information: it means that when constructing
the ``category of finite sets'' later on, instead of each type having one
canonical representative, it will have \(n!\), where \(n\) is the cardinality of
the type\footnotemark.

\footnotetext{
  We actually do get a category (a groupoid, even) from manifest Bishop
  finiteness \cite{yorgeyCombinatorialSpeciesLabelled2014}: it's the groupoid of
  finite sets equipped with a linear order, whose morphisms are order-preserving
  bijections.
  We do not explore this particular construction in any detail.
}

To remedy the problem, we will use propositional truncation
(def.~\ref{prop-trunc}).

\begin{definition}[Higher Inductive Types] \label{HITs}
  Normal inductive types have \emph{point} constructors: constructors which
  construct values of the type.
  Higher Inductive Types (HITs) also have \emph{path} constructors: ways to
  construct paths in the type.
\end{definition}
\begin{definition}[Propositional Truncation] \label{prop-trunc}
  The type \(\lVert A \rVert\) on some type \(A\) is a propositionally truncated
  proof of \(A\) \cite[3.7]{hottbook}.
  In other words, it is a proof that some \(A\) exists, but it does not tell you
  \emph{which} \(A\).

  It is defined as a Higher Inductive Type:
  \begin{equation} {
    \begin{alignedat}{3}
      \lVert A \rVert \coloneqq & \; \lvert \wc \rvert &:& \; A \rightarrow \lVert A \rVert ; \\
                              | & \; \text{squash}     &:& \; \Pi {(x, y : \lVert A \rVert)} , x \equiv y  ; 
    \end{alignedat} }
  \end{equation}
  We will use two eliminators from \(\lVert A \rVert\) in this paper.
  \begin{enumerate}
  \item \label{elim-prop-prop} For any function \(A \rightarrow B\), where
    \(\text{isProp}(B)\), we have a function \(\lVert A \rVert \rightarrow B\).
  \item \label{elim-prop-coh} We can eliminate from \(\lVert A \rVert\) with a
    function \(f : A \rightarrow B\) iff \(f\) ``doesn't care'' about the
    choice of \(A\):
    \[\Pi {(x , y : A)} , f(x) \equiv f(y) \]
    Formally speaking, \(f\) needs to be ``coherently constant''
    \cite{krausGeneralUniversalProperty2015}, and \(B\) needs to be an
    \(n\)-type for some finite \(n\).
  \end{enumerate}
\end{definition}
\begin{definition}[Cardinal Finiteness]
  A type \(A\) is cardinally finite if there exists a propositionally truncated
  proof that \(A\) is manifest Bishop finite or equivalent to a finite prefix of
  the natural numbers.
  \begin{equation}
    \mathcal{C}(A) \coloneqq \lVert \AgdaDatatype{\ensuremath{\mathcal{B}}}(A) \rVert \simeq \lVert \Sigma(n : \mathbb{N}) , (\AgdaDatatype{Fin}\;n \simeq A) \rVert
  \end{equation}
\end{definition}
At first glance, it might seem that we lose any useful properties we could
derive from \(\AgdaDatatype{\ensuremath{\mathcal{B}}}\).
Luckily, this is not the case: by eliminator \ref{elim-prop-coh} of
def.~\ref{prop-trunc}, we need only show that the output is uniquely determined.
\subsection{Deriving Uniquely-Determined Quantities}
The following two lemmas are proven in
\cite{yorgeyCombinatorialSpeciesLabelled2014} (Proposition 2.4.9 and 2.4.10,
respectively), in much the same way as we have done here.
Our contribution for this section is simply the formalisation.
\begin{lemma}
  Given a cardinally finite type, we can derive the type's cardinality, as well
  as a propositionally truncated proof of equivalence with \(\textbf{Fin}\)s of
  the same cardinality.
  \begin{equation}
    \mathcal{C}(A) \rightarrow \Sigma {(n : \mathbb{N})} , \lVert \textbf{Fin}(n) \simeq A \rVert
  \end{equation}
\end{lemma}
\begin{proof}
  Let \(A\) be a cardinally-finite type, with proof \(F : \mathcal{C}(A)\).
  Our task is to extract a natural number \(n : \mathbb{N}\) representing the
  cardinality of \(A\), and a propositionally-truncated proof that \(A\) is
  equivalent to \(\AgdaDatatype{Fin}\;n\).

  Extracting the second component of the pair is trivial, as it itself is
  truncated.
  We will now focus on extracting the cardinality.

  Without the propositional truncation, \(\text{fst}\) would suffice for this
  task.
  Given that the pair is hidden under the truncation, then, we need a way to
  convert a function \(f : A \rightarrow B\) to \(g : \lVert A \rVert
  \rightarrow B\).
  This is precisely what eliminator \ref{elim-prop-coh} gives us.
  For our case, we need to show the following:
  \begin{equation}
    \frac{(n : \mathbb{N}) \; \; \; (p : \AgdaDatatype{Fin}\;n \simeq A) \; \; \;
          (m : \mathbb{N}) \; \; \; (q : \AgdaDatatype{Fin}(m) \simeq A)
        }{
          n \equiv m
        }
  \end{equation}
  Immediately we can construct the following term:
  \begin{equation}
    \begin{alignedat}{3}
      \AgdaDatatype{Fin}\;n & \simeq A && (p) \\
                      & \simeq \AgdaDatatype{Fin}(m) && (q)
    \end{alignedat}
  \end{equation}
  Given univalence we have \(\AgdaDatatype{Fin}\;n \equiv \AgdaDatatype{Fin}(m)\),
  and the rest of our task is to prove:
  \begin{equation}
    \frac{\AgdaDatatype{Fin}\;n \equiv \AgdaDatatype{Fin}(m)}{n \equiv m}
  \end{equation}

  This is a well-known chestnut in dependently-typed programming, and one that
  has a surprisingly tricky and complex proof.
  We do not include it here, since it has already been explored elsewhere, but
  it is present in our formalisation.
\end{proof}

In order to prove that cardinal finiteness implies decidable equality, we will
need to show that decidable equality itself is a proposition.
In doing that we will use the following lemma:
\begin{lemma} \label{prop-refute}
  We can ``refute'' a propositionally-truncated proof of some proposition with a
  proof that the non-truncated proposition is false.
  \begin{equation}
    \frac{\neg A \; \; \; \lVert A \rVert}{\bot}
  \end{equation}
\end{lemma}
\begin{proof}
  We know we can eliminate from any value of type \(\lVert A \rVert\) into some
  \(B\) with a function \(A \to B\) if \(B\) is a proposition.
  That's precisely what we do in this case: \(\neg A\) is a function of type \(A
  \to \bot\), and we know that \(\bot\) is a proposition.
\end{proof}

\begin{lemma} \label{cardinal-finite-discrete}
  Any cardinal-finite set has decidable equality.
\end{lemma}
\begin{proof}
  Since we can already derive decidable equality from a proof of manifest Bishop
  finiteness, it suffices to show that decidable equality is itself a
  proposition.
  \begin{equation}
    \text{isProp}(\Pi(x, y : A) , \mathbf{Dec}(x \equiv y))
  \end{equation}
  First, it is clear that \(x \equiv y\) is a proposition: since the type \(A\)
  has decidable equality, by Hedburg's theorem it is a set,
  meaning precisely that \(x \equiv y\) is a proposition.

  Secondly, we know that any decision over a proposition is itself a
  proposition.
  For any two terms \(x, y: \mathbf{Dec}(A)\) we cannot have the case that one
  is a yes decision and the other is no: from that we could derive \(\bot\).
  If both are no then they are both equal since \(A \rightarrow \bot\) is a
  proposition through function extensionality.
  And finally if both are yes then we know they must be equal because the type
  decided over is itself a proposition.

  Finally, since we know that \(\mathbf{Dec}(x \equiv y)\) is a proposition, we
  can derive that \(\Pi(x, y : A) , \mathbf{Dec}(x \equiv y)\) is a proposition
  (through function extensionality), proving our goal.
\end{proof}
\subsection{Restrictiveness}
So far our explorations into finiteness predicates have pushed us in the
direction of ``less informative'': however, as mentioned in the introduction, we
can \emph{also} ask how \emph{restrictive} certain predicates are.
Since split enumerability and manifest Bishop finiteness imply each other we
know that there can be no type which satisfies one but not the other.
We also know that manifest Bishop finiteness implies cardinal finiteness, but we
do \emph{not} have a function in the other direction:
\begin{equation}
  \mathcal{C}(A) \rightarrow \AgdaDatatype{\ensuremath{\mathcal{B}}}(A)
\end{equation}
So the question arises naturally: is there a cardinally finite type which is
\emph{not} manifest Bishop finite?

It turns out the answer is no!
\begin{lemma}
  \begin{equation}
    \neg (\Sigma(A : \mathbf{Type}) , \mathcal{C}(A) \times \neg \AgdaDatatype{\ensuremath{\mathcal{B}}}(A))
  \end{equation}
\end{lemma}
\begin{proof}
  We will actually prove a slightly more general statement.
  For any type \(A\), the following holds:
  \begin{equation}
    \neg (\lVert A \rVert \times \neg A)
  \end{equation}
  The solution becomes more clear if we write out the definition of \(\neg\):
  \begin{equation}
    \frac{\lVert A \rVert \;\;\; A \rightarrow \bot }{\bot}
  \end{equation}
  We clearly need to apply a function of type \(A \rightarrow \bot\) to a value
  of type \(\lVert A \rVert\).
  Luckily, this is permissible, as \(\bot\) is a mere proposition.
\end{proof}

\subsection{Going from Cardinal Finiteness to Manifest Bishop Finiteness}
\begin{lemma} \label{manifest-bishop-to-cardinal}
  Any manifest Bishop finite type is cardinal finite.
\end{lemma}
\begin{theorem} \label{cardinal-to-manifest-bishop}
  Any cardinal finite type with a total order is Bishop finite.
\end{theorem}
The proof for this particular theorem is quite involved in the formalisation, so
we only give its sketch here.
First, note that we actually convert to manifest enumerability first: this can
be converted to split enumerability with decidable equality, which is provided
by cardinal finiteness.

Next, we define permutations.
\begin{definition}[List Permutations]
  Two lists are permutations of each other if their membership proofs are all
  equivalent\footnotemark \cite{danielssonBagEquivalenceProofRelevant2012}.
  \begin{equation}
    \mathit{xs} \leftrightsquigarrow \mathit{ys} = \Pi {(x : A)} , x \in \mathit{xs} \simeq x \in \mathit{ys}
  \end{equation}
\end{definition}

\footnotetext{
  The definition in \cite{danielssonBagEquivalenceProofRelevant2012} and our
  formalisation is slightly different: we say permutations are lists with
  \emph{isomorphic} membership proofs.
  The distinction, as it happens, does not affect our work here.
}

Next, we define a sort function which relies on the provided total order.
We further prove the following fact about this sort function:
\begin{equation}
  \Pi(\mathit{xs}, \mathit{ys} : \AgdaDatatype{List}(A)) , \mathit{xs} \leftrightsquigarrow \mathit{ys} \rightarrow \text{sort}(\mathit{xs}) \equiv \text{sort}(\mathit{ys})
\end{equation}

Next, notice that the support lists of any two proofs of manifest Bishop
finiteness must be permutations of each other.
This will allow us to sort the support list of a proof of cardinal finiteness in
a coherently constant (definition~\ref{prop-trunc},
eliminator~\ref{elim-prop-coh}) way, pulling the support list out from the
truncation.
The cover proof emerges naturally from the definition of the permutation.
\section{Manifest Enumerability} \label{manifest-enumerability}
We have now explored quite far in the ``less informative'' direction.
However, all three predicates we have examined are equally \emph{restrictive}:
in this section we will see a predicate which is much less restrictive.
In particular, this predicate ranges over non-set types.


\begin{definition}[Manifest Enumerability]
  Manifest enumerability is an enumeration predicate like Bishop finiteness or
  split enumerability with the only difference being a propositionally truncated
  membership proof.
  \begin{equation}
    \mathcal{E}(A) \coloneqq \Sigma {(\mathit{xs} : \AgdaDatatype{List}(A))} , \Pi {(x : A)} , \lVert x \in \mathit{xs} \rVert
  \end{equation}
\end{definition}
As a function-based definition, this predicate represents surjections.

\begin{definition}[Surjections] \label{surjections}
  We define proper surjections (not split surjections) here \cite[definition
  4.6.1]{hottbook}.
  \begin{alignat}{3}
    &\text{surj}(f)             &&\coloneqq \Pi(y : B) , \lVert \text{fib}_f(y) \rVert \label{surj-eqn} \\
    &A \twoheadrightarrow B     &&\coloneqq \Sigma (f : A \rightarrow B) , \text{surj}(f) \label{surj-arrow-eqn}
  \end{alignat}
\end{definition}
\begin{lemma}
  Manifest enumerability is equivalent to a surjection from a finite prefix of
  the natural numbers.
  \begin{equation}
    \mathcal{E}(A) \simeq \Sigma(n : \mathbb{N}) , (\AgdaDatatype{Fin}\;n \twoheadrightarrow A)
  \end{equation}
\end{lemma}
\begin{proof}
  \begin{align*}
     \mathcal{E}(A) &
    \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \lVert x \in \mathit{xs} \rVert
    && \text{def.~\ref{split-enum-def} }(\mathcal{E})
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \lVert \text{fib}_{\text{snd}(\mathit{xs})}(x) \rVert
    && \text{eqn.~\ref{container-membership} } (\in)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \text{surj}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{surj-eqn} (surj)}
    \\
    & \simeq \Sigma (\mathit{xs} : \llbracket \mathbb{N} , \AgdaDatatype{Fin} \rrbracket (A)) , \text{surj}(\text{snd}(\mathit{xs}))
    && \text{def.~\ref{List} } (\AgdaDatatype{List})
    \\
    & \simeq \Sigma (\mathit{xs} : \Sigma (n : \mathbb{N}) , \Pi (i : \AgdaDatatype{Fin}\;n) , A) , \text{surj}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{container-interp} } (\llbracket \wc \rrbracket)
    \\
    & \simeq \Sigma (n : \mathbb{N}) , \Sigma (f : \AgdaDatatype{Fin}\;n \rightarrow A) , \text{surj}(f)
    && \text{Reassociation of } \Sigma
    \\
    & \simeq \Sigma (n : \mathbb{N}) , ( \AgdaDatatype{Fin}\;n \twoheadrightarrow A )
    && \text{eqn.~\ref{surj-arrow-eqn} } (\twoheadrightarrow) \; \qedhere
  \end{align*}
\end{proof}
\subsection{Instances for Non-Set Types}
The truncation has another very important implication: it means that the
predicate doesn't provide decidable equality on the underlying type.
Remember, this is how we knew that our previous predicates wouldn't allow for
non-set types: because they implied decidable equality, they also implied that
all conforming types had homotopy levels of at most 2. \todo{Are we doing the
  homotopy levels starting from -2 thing or from 0?}
This suggests that non-set types like the circle could conform to this
finiteness predicate.
\begin{lemma}
  The circle \(S^1\) is manifestly enumerable.
\end{lemma}
\begin{proof}
  The support list firstly is a list containing the point constructor for the
  circle.
  Since the cover proof is truncated, we need only consider the point
  constructors of the circle: as such, the cover proof is essentially the same
  as the one for \(\AgdaDatatype{\ensuremath{\mathcal{E}!}}(\top)\).
\end{proof}
\subsection{Relation To Split Enumerability}
It is trivially easy to construct a proof that any split enumerable type is
manifest enumerable: we simply truncate the membership proof.
Going the other was requires us to extract a non-truncated proof from a
truncated one.
This proof relies on the following lemma:
\begin{lemma}
  We can ``recompute'' a truncated proof given a decision over a proof of the
  same type.
  \begin{equation}
    \frac{\lVert A \rVert \; \; \; \mathbf{Dec}(A)}{A}
  \end{equation}
\end{lemma}
\begin{proof}
  We proceed by case-analysis over the decision over \(A\).
  In the case where \(A\) is proven, we are done.
  In the case where \(A\) is disproven, we use lemma~\ref{prop-refute} to
  derive impossibility.
\end{proof}

\begin{lemma} \label{manifest-enum-to-split-enum}
  A manifestly enumerable type with decidable equality is split enumerable.
\end{lemma}
\begin{proof}
  The only difference between manifest enumerability and split enumerability is
  the membership proof: therefor our goal for this proof is to construct a
  function of the following type:
  \begin{equation}
    \lVert x \in \mathit{xs} \rVert \rightarrow x \in \mathit{xs}
  \end{equation}
  Given decidable equality over the type of \(x\).

  We do this using the previous recompute lemma: that tells us that all we need
  to construct is a decision for \(x \in \mathit{xs}\), and it will be able to
  derive the proof itself.
  Such a decision procedure is not difficult to construct: for any value \(x\)
  and list \(\mathit{xs}\), we proceed through the list \(\mathit{xs}\), testing
  if \(x\) is equal to any of its contents.
  If it is, we return that we have proven the goal, and that \(x\) is indeed
  present in \(\mathit{xs}\).
  Otherwise, we know that \(x\) cannot be in \(\mathit{xs}\) (since we've tested
  every value), so we return that the goal has been disproven.
\end{proof}
\section{Kuratowski Finiteness} \label{kuratowski}
The one big missing definition of finiteness to cover is \emph{Kuratowski}
finiteness.
While it's quite important, it's also quite different from the definitions we've
seen so far.
It starts with an encoding of the free join semilattice.
\begin{definition}[Free Join Semilattice]
  \(\mathcal{K}(A)\) is the free join semilattice, or, alternatively, the type
  of Kuratowski-finite subsets of \(A\).
  \begin{inductivetype}{\mathcal{K}(A)}
    \inductivetypeclause{\left[ \right]}{\mathcal{K}(A)}
    \inductivetypeclause{\wc \dblcolon \wc}{A \rightarrow \mathcal{K}(A) \rightarrow \mathcal{K}(A)}
    \inductivetypeclause{\text{com}}{\Pi (x, y: A) , \Pi (\mathit{xs} : \mathcal{K}(A)) , x \dblcolon y \dblcolon \mathit{xs} \equiv y \dblcolon x \dblcolon \mathit{xs}}
    \inductivetypeclause{\text{dup}}{\Pi (x : A) , \Pi (\mathit{xs} : \mathcal{K}(A)) , x \dblcolon x \dblcolon \mathit{xs} \equiv x \dblcolon \mathit{xs}}
    \inductivetypeclause{\text{trunc}}{\Pi (\mathit{xs}, \mathit{ys}: \mathcal{K}(A)) , \Pi (p, q : \mathit{xs} \equiv \mathit{ys}) , p \equiv q}
  \end{inductivetype}
  We define it as a HIT (definition~\ref{HITs}).
  The first two constructors are point constructors, giving ways to create
  values of type \(\mathcal{K}(A)\).
  They are also recognisable as the two constructors for finite lists, a type
  which represents the free monoid.

  The next two constructors add extra paths to the type: equations that usage of
  the type must obey.
  These extra paths turn the free monoid into the free \emph{commutative} (com)
  \emph{idempotent} (dup) monoid.

  The final constructor enforces that the type \(\mathcal{K}(A)\) must be a set.
\end{definition}
The Kuratowski finite subset is a free join semilattice (or, equivalently, a
free commutative idempotent monoid).
More prosaically, \(\mathcal{K}\) is the abstract data type for finite sets, as
defined in the Boom hierarchy \cite{boomFurtherThoughtsAbstracto1981,
  bunkenburgBoomHierarchy1994}.
However, rather than just being a specification, \(\mathcal{K}\) is fully usable
as a data type in its own right, thanks to HITs.

Other definitions of \(\mathcal{K}\) exist (such as the one in
\cite{fruminFiniteSetsHomotopy2018}) which make the fact that \(\mathcal{K}\) is
the free join semilattice more obvious.
We have included such a definition in our formalisation, and proven it
equivalent to the one above.

Next, we need a way to say that an entire type is Kuratowski finite.
For that, we will need to define membership of \(\mathcal{K}\).
\begin{definition}[Membership of \(\mathcal{K}\)]
  Membership is defined by pattern-matching on \(\mathcal{K}\).
  The two point constructors are handled like so:
  \begin{equation}
    \begin{alignedat}{2}
      x \in&& \; []                      &\coloneqq \bot ; \\
      x \in&& \; y \dblcolon \mathit{ys} &\coloneqq \lVert x \equiv y \uplus x \in \mathit{ys} \rVert ;
    \end{alignedat}
  \end{equation}
  The \(\text{com}\) and \(\text{dup}\) constructors are handled by proving that
  the truncated form of \(\uplus\) is itself commutative and idempotent.
  The type of propositions is itself a set, satisfying the \(\text{trunc}\)
  constructor.
\end{definition}
Finally, we have enough background to define Kuratowski finiteness.
\begin{definition}[Kuratowski Finiteness]
  \begin{equation}
    \mathcal{K}^{f}(A) = \Sigma {(\mathit{xs} : \mathcal{K}(A))} , \Pi (x : A) , x \in \mathit{xs}
  \end{equation}
\end{definition}

We also have the following two lemmas, proven in both
\cite{fruminFiniteSetsHomotopy2018} and our formalisation.
\begin{lemma}
  \(\mathcal{K}^f\) is a mere proposition.
\end{lemma}
\begin{lemma}
  This circle \(S^1\) is Kuratowski finite.
\end{lemma}
\subsection{Relation to Cardinal Finiteness}
\begin{lemma} \label{cardinal-kuratowski}
  Cardinal finiteness is equivalent to Kuratowski finiteness over a discrete
  set.
  \begin{equation}
    \mathcal{C}(A) \simeq \mathcal{K}^f(A) \times \text{Discrete}(A)
  \end{equation}
\end{lemma}
This proof is constructed by providing a pair of functions: one from
\(\mathcal{C}(A)\) to \(\mathcal{K}^f(A) \times \text{Discrete}(A)\), and one the
other way.
This pair implies an equivalence, because both source and target are
propositions.
The actual functions themselves are proven in our formalisation, as well as in
\cite{fruminFiniteSetsHomotopy2018}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: