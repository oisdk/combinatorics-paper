\chapter{Countdown}
Countdown is a well-known functional programming puzzle (with a spin-off TV show
in the UK), first popularised as a puzzle in which to demonstrate functional
algorithms in \cite{huttonCountdownProblem2002}.
The idea is simple: given a list of numbers, contestants must construct an
arithmetic expression (using a small set of functions) using some or all of the
numbers, to reach some target.


In this section we will develop a program/proof which can decide countdown
problems totally.
In other words, given a list of numbers and a target, our program will prove
whether a solution exists, and if so, it will provide just that solution.
\section{Classifying The Problem}
So what is a ``solution'' to the countdown problem?
Put simply, it is a way to:
\begin{enumerate}
  \item Arrange some or all of the given numbers into an expression
  \item Such that the expression evaluates to our target.
\end{enumerate}
The first part of this solution is a transformation (from a list of numbers into
an expression), and the second is a filter (into valid expressions which
evaluate to the target).

We are going to define this transformation/filter pair as a type.
We will then show that this type is itself finite, and from there we will be
able to enumerate all possible solutions, derive the cardinality of the
solutions, and so on.

\input{figures/countdown-transformation}

Let's first look at the transformation aspect of the solution.
We have broken this transformation into four steps in
figure~\ref{countdown-transform}.

First, we select which numbers in the input we are going to use in our solution
candidate: this is the selection step of the transformation
(fig.~\ref{countdown-selection}).
Next we decide the order of the selected numbers in the output: this is the
permutation step of the transformation (fig.~\ref{countdown-permutation}).
We then select \(n-1\) operators to use with our \(n\) chosen numbers
(fig.~\ref{countdown-operators}).
Finally, we have to apply the binary operators with some parenthesising order
(fig.~\ref{countdown-parens}).

Each of these transformations can be represented by a finite object: a selection
from \(n\), for instance, can be represented as an \(n\)-tuple of bools.
The full transformation itself will be a product of each of these intermediate
steps, which itself is finite by closure under \(\Sigma\).

In this section we will use split-enumerability as our finiteness predicate.
Most of what we examine would work equally well with the other predicates, but
split enumerability is the most powerful and the simplest to define.
Since we will work only with set types, there won't be any need to look at
non-set predicates like manifest enumerability.
\section{Selection and Operators}
The first component of the transformation is relatively simple: we select some
of the given numbers to use in our solution.
We can represent this transformation as an \(n\)-tuple of bools.
The filter in fig.~\ref{countdown-selection}, for instance, could be represented
with the following:
\begin{equation}
  \langle 0 , 1 , 1 , 1 , 1 , 1  \rangle
\end{equation}
The proof that this type is finite is straightforward: by induction on \(n\), we
see that any \(n\)-tuple of finite things is itself finite.

At this point we can look forward slightly to an upcoming transformation and
prove it finite: the selection of \(n\) operators is \emph{also} constructed
using an \(n\)-tuple.
Clearly there are finitely many operators available to us, so an \(n\)-tuple of
operators is finite for the same reason as the selection.
\section{Permutations}
Permutations are slightly trickier, and have a number of possible
representations.
One option, for instance, would be to represent a permutation of size \(n\) as a
bijection between \(\mathbf{Fin}(n)\) and \(\mathbf{Fin}(n)\).


\section{Enumerating Binary Trees}

% \section{Filtering Out Invalid Expressions with the Subobject Classifier}
% \section{Filtering Out Duplicates with Quotients}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: