\chapter{Countdown}
\input{figures/countdown-transformation}
Countdown is a well-known functional programming puzzle (with a spin-off TV show
in the UK), first popularised as a puzzle in which to demonstrate functional
algorithms in \cite{huttonCountdownProblem2002}.
The idea is simple: given a list of numbers, contestants must construct an
arithmetic expression (using a small set of functions) using some or all of the
numbers, to reach some target.

Take the following problem as an example:
\begin{gather*}
  \boxed{1} \boxed{3} \boxed{7} \boxed{10} \boxed{25} \boxed{50} \\
  \boxed{765} \tag{Target}
\end{gather*}
It has the following answer:
\begin{equation}
  3 \times ((7 \times (50 - 10)) - 25)
\end{equation}
Importantly, we do not have to use every number given to get to the target.
For our problem, we will use the operators \(\times\), \(+\), and \(-\).

In this section we will develop a program/proof which can decide countdown
problems totally.
In other words, given a list of numbers and a target, our program will prove
whether a solution exists, and if so, it will provide just that solution.
\section{Classifying The Problem}
So what is a ``solution'' to the countdown problem?
Put simply, it is a way to:
\begin{enumerate}
  \item Arrange some or all of the given numbers into a valid expression
  \item Such that the expression, when evaluated, is equal to the target.
\end{enumerate}
Our task is to construct a \emph{type} for this transformation.
We will mainly focus on the first of these two concerns: arranging a list of
numbers into an expression using the given rules of Countdown.

We can break this transformation into parts, displayed in
figure~\ref{countdown-transform}.
\section{Enumerating Combinations and Permutations}
\section{Enumerating Binary Trees}
\section{Filtering Out Invalid Expressions with the Subobject Classifier}
\section{Filtering Out Duplicates with Quotients}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: