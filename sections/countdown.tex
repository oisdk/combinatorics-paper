\chapter{Countdown}
Countdown is a well-known functional programming puzzle (with a spin-off TV show
in the UK), first popularised as a puzzle in which to demonstrate functional
algorithms in \cite{huttonCountdownProblem2002}.
The idea is simple: given a list of numbers, contestants must construct an
arithmetic expression (using a small set of functions) using some or all of the
numbers, to reach some target.

Take the following problem as an example:
\begin{gather*}
  \boxed{1} \boxed{3} \boxed{7} \boxed{10} \boxed{25} \boxed{50} \\
  \boxed{765} \tag{Target}
\end{gather*}
It has the following answer:
\begin{equation}
  3 \times ((7 \times (50 - 10)) - 25)
\end{equation}
Importantly, we do not have to use every number given to get to the target.
For our problem, we will use the operators \(\times\), \(+\), and \(-\).

In this section we will develop a program/proof which can decide countdown
problems totally.
In other words, given a list of numbers and a target, our program will prove
whether a solution exists, and if so, it will provide just that solution.
\section{Classifying The Problem}
So what is a ``solution'' to the countdown problem?
Put simply, it is a way to:
\begin{enumerate}
  \item Arrange some or all of the given numbers into a valid expression
  \item Such that the expression, when evaluated, is equal to the target.
\end{enumerate}
The first part of this solution is a transformation (from a list of numbers into
an expression), and the second is a filter (into valid expressions which
evaluate to the target).

In order to find and prove countdown solutions, we will prove that the above
transformation is \emph{finite}: this will allow us to search exhaustively
through the available transformations, proving the existence or absence of a
transformation which is a solution.

\input{figures/countdown-transformation}

Let's first look at the transformation part.
As shown in figure~\ref{countdown-transform}, we can break the transformation
into four parts.
First, we notice that we don't have to use all of the given numbers in the
solution candidate: keeping or discarding input numbers, then, is the first step
of the transformation (fig.~\ref{countdown-filter}).
Next, we are allowed to rearrange the order of the numbers in our output: the
next step of the transformation, then, applies a permutation to the selected
numbers (fig.~\ref{countdown-permutation}).
Thirdly, we can choose the operators we're going to use: note that for \(n\)
chosen numbers, we can choose \(n - 1\) operators
(fig.~\ref{countdown-operators}).
Finally, we have to apply the binary operators with some parenthesising order
(fig.~\ref{countdown-parens}).

There are finitely many of each of these transformations: finitely many filters
for \(n\) objects, for instance, or finitely many tuples of \(n\) operators.
We are going to construct a type for each of these transformations, prove it
finite, and use that type to search.
The final, completed transformation will then be a dependent product of each
constituent step.


% \section{Filtering and Operators}
% \section{Enumerating Binary Trees}
% \section{Filtering Out Invalid Expressions with the Subobject Classifier}
% \section{Filtering Out Duplicates with Quotients}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: