\chapter{Search} \label{search}
A common theme in dependently-typed programming is that proofs of interesting
theoretical things often correspond to useful algorithms in some way
related to that thing.
Finiteness is one such case: if we have a proof that a type \(A\) is finite,
we should be able to search through all the elements of that type in a
systematic, automated way.

As it happens, this kind of search is a very common method of proof automation
in dependently-typed languages like Agda.
Proofs of statements like ``the following function is associative''
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{and-def}
\end{agdalisting}
can be tedious: the associativity proof in particular would take \(2^3 = 8\)
cases.
This is unacceptable!
There are only finitely many cases to examine, after all, and we're
\emph{already} on a computer: why not automate it?
A proof that \(\AgdaDatatype{Bool}\) is finite can get us much of the way to a
library to do just that.
\todo{These examples so far are pretty focused on the bool associativity
  example.
  I'm not sure I can think of a good way to put countdown in instead: will we
  try switch?
  Or will we keep the bool for this short bit?
  }

Similar automation machinery can be leveraged to provide search algorithms for
certain ``logic programming''-esque problems.
Using the machinery we will describe in this section, though, when the program
says it finds a solution to some problem that solution will be accompanied by a
formal \emph{proof} of its correctness.

In this section, we will describe the theoretical underpinning and
implementation of a library for proof search over finite domains, based on the
finiteness predicates we have introduced already.
The library will be able to prove statements like the proof of associativity
above, as well as more complex statements.
As a running example for a ``more complex statement'' we will use the countdown
problem, which we have been using throughout: we will demonstrate how to
construct a prover for the existence of, or absence of, a solution to a given
countdown puzzle.

The API for writing searches over finite domains comes from the language of the
\(\Pi\)-pretopos: with it we will show how to compose QuickCheck-like generators
for proof search, with the addition of some automation machinery that allows us
to prove things like the associativity in a couple of lines:
\begin{agdalisting} \label{bool-assoc-auto-proof}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{bool-assoc-auto-proof}
\end{agdalisting}

We have already, in previous sections, explored the theoretical implications of
Cubical Type Theory on our formalisation.
With this library for proof search, however, we will see two distinct
practical applications which would simply not be possible without
computational univalence.
First and foremost: our proofs of finiteness, constructed with the API we will
describe, have all the power of full equalities.
Put another way any proof over a finite type \(A\) can be lifted to any other
type with the same cardinality.
Secondly our proof search can range over functions: we could, for instance, have
asked the prover to find if \emph{any} function over \(\AgdaDatatype{Bool}\) is
associative, and if so return it to us.
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{some-assoc}
\end{agdalisting}
The usefulness of which is dubious, but we will see a more interesting
application soon.
\section{Proof Automation And Search Techniques}
For this prover we will not resort to reflection or similar techniques: instead,
we will trick the type checker to do our automation for us.
This is a relatively common technique, although not so much outside of Agda, so
we will briefly explain it here.

To understand the technique we should first notice that some proof automation
\emph{already} happens in Agda, like the following:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{obvious}
\end{agdalisting}
The type checker does not require us to manually explain each step of evaluation
of
\(\AgdaInductiveConstructor{true}\;\AgdaFunction{∧}\;\AgdaInductiveConstructor{false}\).
While it's not a particularly impressive example of automation, it does nonetheless
demonstrate a principle we will exploit: closed terms will compute to a normal
form if they're needed to type check.
The type checker will perform \(\beta\)-reduction as much as it can.

So our task is to rewrite proof obligations like the one in
Equation~\ref{bool-assoc-auto-proof} into ones which can reduce completely. 
As it turns out, we have already described the type of proofs which can ``reduce
completely'': \emph{decidable} proofs.
If we have a decision procedure over some proposition \(P\) we can run that
decision during type checking, because the decision procedure itself is a proof
that the decision will terminate.
In code, we capture this idea with the following pair of functions:
\begin{multicols}{2}
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Bool.tex]{is-true}
  \end{agdalisting} \columnbreak
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Bool.tex]{from-true}
  \end{agdalisting}
\end{multicols}
The first is a function which derives a type from whether a decision is
successful or not.
This function is important because if we use the output of this type at any
point we will effectively force the unifier to run the decision computation.
The second takes---as an implicit argument---an inhabitant of the type generated
from the first, and uses it to prove that the decision can only be true, and the
extracts the resulting proof from that decision.
All in all, we can use it like this:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{extremely-obvious}
\end{agdalisting}
This technique will allow us to automatically compute any decidable predicate.
\section{Omniscience}
So we now know what is needed of us for proof automation: we need to take our
proofs and make them decidable.
In particular, we need to be able to ``lift'' decidability back over a
function arrow.
For instance, given \(x\), \(y\), and \(z\) we already have
\(\AgdaDatatype{Dec}\;((x\;\AgdaFunction{∧}\;y)\;\AgdaFunction{∧}\;z\;\AgdaFunction{≡}\;x\;\AgdaFunction{∧}\;(y\;\AgdaFunction{∧}\;z))\)
(because equality over booleans is decidable).
In order to turn this into a proof that \AgdaFunction{∧} is associative we need
\(\AgdaDatatype{Dec}\;(\forall \; x \; y \; z \rightarrow (x\;\AgdaFunction{∧}\;y)\;\AgdaFunction{∧}\;z\;\AgdaFunction{≡}\;x\;\AgdaFunction{∧}\;(y\;\AgdaFunction{∧}\;z))\).
The ability to do this is described formally by the notion of
``Exhaustibility''.
\begin{agdalisting}
  \ExecuteMetaData[agda/Relation/Nullary/Omniscience.tex]{exhaustible}
\end{agdalisting}
We say a type \(A\) is exhaustible if, for any decidable predicate \(P\) on
\(A\), the universal quantification of the predicate is decidable.

This property of \AgdaDatatype{Bool} would allow us to automate the proof of
associativity, but it is in fact not strong enough to find individual
representatives of a type which support some property.
For that we need the more well-known related property of
\emph{omniscience}.
\begin{agdalisting}
  \ExecuteMetaData[agda/Relation/Nullary/Omniscience.tex]{omniscient}
\end{agdalisting}
The ``limited principle of omniscience''
\cite{bishopFoundationsConstructiveAnalysis1967} is a classical principle which
says that omniscience holds for all sets.
It doesn't hold constructively, of course: it lies a little bit below LEM in
terms of its non-constructiveness, given that it can be derived from LEM but LEM
cannot be derived from it.

Omniscience implies exhaustibility: we can use the usual rule of \todo{what is
  this called/from again?}
\begin{equation}
  \neg \exists x. P(x) \iff \forall x. \neg P(x)
\end{equation}
to turn omniscience for some predicate \(P\) into exhaustibility for some
predicate \(\neg \neg P\).
Usually we don't have double negation elimination constructively, but since
\(P\) is decidable it's actually present in this case:
\begin{agdalisting}
  \ExecuteMetaData[agda/Relation/Nullary/Decidable/Properties.tex]{dec-double-neg-elim}
\end{agdalisting}
All together, this gives us the following proof:
\begin{agdalisting}
  \ExecuteMetaData[agda/Relation/Nullary/Omniscience.tex]{omniscient-to-exhaustible}
\end{agdalisting}

Our focus here is on those types for which omniscience \emph{does} hold,
which includes the (ordered) finite types.
Perhaps surprisingly, it is not \emph{only} finite types which are exhaustible.
Certain infinite types can be
exhaustible~\cite{escardoInfiniteSetsThat2007}, but an exploration of that is
beyond the scope of this work.

All of the finiteness predicates imply exhaustibility.
To prove that fact we'll just show that the Kuratowski finite types are
exhaustible: since it's the weakest predicate, and can be derived from all the
others.
\begin{lemma}
  Kuratowski finiteness implies exhaustibility.
\end{lemma} \todo{Proof?}
Manifest enumerability is similarly the weakest of the ordered predicates, so we
will prove here that it implies omniscience.
\begin{lemma}
  Manifest enumerability implies omniscience.
\end{lemma} \todo{proof?}

Finally, there is a form of omniscience which works with Kuratowski finiteness:
propositional omniscience.
\begin{agdalisting}
  \ExecuteMetaData[agda/Relation/Nullary/Omniscience.tex]{prop-omniscient}
\end{agdalisting}
By truncating the returned \AgdaDatatype{\ensuremath{\Sigma}} we don't reveal
which \(A\) we've chosen which satisfies the predicate: this means that it can
be pulled out of the Kuratowski finite subset without issue.
\begin{agdalisting}
  \ExecuteMetaData[agda/Cardinality/Finite/Kuratowski.tex]{kuratowski-prop-omniscient}
\end{agdalisting}
\section{Countdown}
The Countdown problem~\cite{huttonCountdownProblem2002} is a well-known puzzle
in functional programming (which was apparently turned into a TV show).
As a running example in this paper, we will produce a verified program which
lists all solutions to a given countdown puzzle: here we will briefly explain
the game and our strategy for solving it.

The idea behind countdown is simple: given a list of numbers, contestants must
construct an arithmetic expression (using a small set of functions) using some
or all of the numbers, to reach some target.
Here's an example puzzle:
\begin{gather*}
  \boxed{1} \boxed{3} \boxed{7} \boxed{10} \boxed{25} \boxed{50} \\
  \boxed{765} \tag{Target}
\end{gather*}
We'll allow the use of \(+\), \(-\), \(\times\), and \(\div\).
The answer is at the bottom of this page\footnotemark.

\footnotetext{\rotatebox[origin=c]{180}{Answer: \(3 \times (7 \times (50 - 10) - 25)\)}}

Our strategy for finding solutions to a given puzzle is to describe precisely
the type of solutions to a puzzle, and then show that that type is finite.
So what is a ``solution'' to a countdown puzzle?
Broadly, it has two parts:
\begin{description}
  \item[A Transformation] from a list of numbers to an expression.
  \item[A Predicate] showing that the expression is valid and evaluates to the
    target.
\end{description}
The first part is described in Figure~\ref{countdown-transform}.

\input{figures/countdown-transformation}

This transformation has four steps.
First (Fig.~\ref{countdown-selection}) we have to pick which numbers we include
in our solution.
We will need to show there are finitely many ways to filter \(n\) numbers.

Secondly (Fig.~\ref{countdown-permutation}) we have to permute the chosen
numbers.
The representation for a permutation is a little trickier to envision: proving
that it's finite is trickier still.
We will need to rely on some of the more involved lemmas later on for this
problem.

The third step (Fig.~\ref{countdown-operators}) is a vector of length \(n\) of finite objects (in this case operators
chosen from \(+\), \(\times\), \(-\), and \(\div\)).
Although it is complicated slightly by the fact that the \(n\) in this
\(n\)-tuple is dependent on the amount of numbers we let through in the filter
in step one.
(in terms of types, that means we'll need a \(\Sigma\) rather than a
\(\times\), explanations of which are forthcoming).

Finally (Fig.~\ref{countdown-parens}), we have to parenthesise the expression in
a certain way.
This can be encapsulated by a binary tree with a certain number of leaves:
proving that that is finite is tricky again.

Once we have proven that there are finitely many transformations for a list of
numbers, we will then have to filter them down to those transformations which
are valid, and evaluate to the target.
This amounts to proving that the decidable subset of a finite set is also
finite.

Finally, we will also want to optimise our solutions and solver: for this we
will remove equivalent expressions, which can be accomplished with quotients.
We have already introduced and described countdown: in this section, we will
fill in the remaining parts of the solver, glue the pieces together, and show
how the finiteness proofs can assist us to write the solver.
\subsection{Finite Permutations}
The first step of the transformation we will represent as a finite object is a
\emph{permutation}: once we choose the numbers we're going to use for the
candidate for the solution, we have to order them in some way.

Our first attempt at representing permutations might look something like this:
\begin{agdalisting}
  \ExecuteMetaData[agda/Countdown.tex]{wrong-perm}
\end{agdalisting}
the idea is that \(\AgdaDatatype{Perm}\;n\) represents a permutation of \(n\)
things, as a function from positions to positions.
Unfortunately such a simple answer won't work: there are no restrictions on the
operation of the function, so it could (for instance), send more than one input
position into the same output.

What we actually need is not just a function between positions, but an
\emph{isomorphism} between them.
In types:
\begin{agdalisting}
  \ExecuteMetaData[agda/Countdown.tex]{iso-perm}
\end{agdalisting}
Where an isomorphism is defined as follows:
\begin{agdalisting}
  \ExecuteMetaData[agda/Countdown.tex]{isomorphism}
\end{agdalisting}
\todo{Should this isomorphism definition be put earlier in the intro with the
  equivalences etc?}
While it may look complex, this term is actually composed of individual
components we've already proven finite.
First we have \(\AgdaDatatype{Fin}\;n\rightarrow\AgdaDatatype{Fin}\;n\):
functions between finite types are, as we know, finite
(Theorem~\ref{split-enum-pi}).
We take a pair of them: pairs of finite things are \emph{also} finite
(Lemma~\ref{split-enum-sigma}).
To get the next two components we can filter to the subobject: this requires
these predicates to be decidable. \todo{Need to do filter subobject in topos section}
We will construct a term of the following type:
\begin{agdalisting}
  \ExecuteMetaData[agda/Cardinality/Finite/ManifestBishop.tex]{dec-type}
\end{agdalisting}
So can we construct such a term? Yes!

We basically need to construct decidable equality for functions between
\(\AgdaDatatype{Fin}\;n\)s: of course, this decidable equality is provided by
the fact that such functions are themselves finite.

All in all we can now prove that the isomorphism, and by extension the
permutation, is finite:
\begin{agdalisting}
  \ExecuteMetaData[agda/Cardinality/Finite/ManifestBishop.tex]{iso-finite}
\end{agdalisting}

Unfortunately this implementation is too slow to be useful.
As nice and declarative as it is, fundamentally it builds a list of all possible
pairs of functions between \(\AgdaDatatype{Fin}\;n\) and itself (an operation
which takes in the neighbourhood of \(\mathcal{O}(n^n)\) time), and then tests
each for equality (which is likely worse than \(\mathcal{O}(n^2)\) time).
We will instead use a factoriadic encoding: this is a relatively simple encoding
of permutations which will reduce our time to a blazing fast
\(\mathcal{O}(n!)\).
It is expressed in Agda as follows:
\begin{agdalisting}
  \ExecuteMetaData[agda/Countdown.tex]{perm-def}
\end{agdalisting}
It is a vector of positions, each represented with a \(\AgdaDatatype{Fin}\).
Each position can only refer to the length of the tail of the list at that
point: this prevents two input positions mapping to the same output point, which
was the problem with the naive encoding we had previously.
And it also has a relatively simple proof of finiteness:
\begin{agdalisting}
  \ExecuteMetaData[agda/Countdown.tex]{perm-fin}
\end{agdalisting}
\subsection{Parenthesising}
Our next step is figuring out a way to encode the parenthesisation of the
expression (Fig.~\ref{countdown-parens}). \todo{There's no way
  ``parenthesisation'' is a real word}
At this point of the transformation, we already have our numbers picked out, we
have ordered them a certain way, and we have also selected the operators we're
interested in.
We have, in other words, the following:
\begin{equation}
  3 \times 7 \times 50 - 10 - 25
\end{equation}
Without parentheses, however, (or a religious adherence to BOMDAS) this
expression is still ambiguous.
\begin{align}
  3 \times ((7 \times (50 - 10)) - 25) &= 765 \\
  (((3 \times 7) \times 50) - 10) - 25 &= 1015
\end{align}
The different ways to parenthesise the expression result in different outputs
of evaluation.

So what data type encapsulates the ``different ways to parenthesise'' a given
expression?
That's what we will figure out in this section, and what we will prove finite.

One way to approach the problem is with a binary tree.
A binary tree with \(n\) leaves corresponds in a straightforward way to a
parenthesisation of \(n\) numbers (Fig.~\ref{countdown-parens}).
\todo{Tree diagram? Or link to previous tree?}
This doesn't get us much closer to a finiteness proof, however: for that we will
need to rely on \emph{Dyck} words.
\begin{definition}[Dyck words]
  A Dyck word is a string of balanced parentheses.
  In Agda, we can express it as the following:
  \begin{agdalisting}
    \ExecuteMetaData[agda/Dyck.tex]{dyck-def}
  \end{agdalisting}
  A fully balanced string of \(n\) parentheses has the type
  \(\AgdaDatatype{Dyck}\;\AgdaInductiveConstructor{zero}\;n\).
  Here are some example strings:
  \begin{multicols}{2}
    \begin{agdalisting}
      \ExecuteMetaData[agda/Dyck.tex]{dyck-0-2}
    \end{agdalisting}
    \begin{agdalisting}
      \ExecuteMetaData[agda/Dyck.tex]{dyck-0-3}
    \end{agdalisting}
  \end{multicols}
  The first parameter on the type represents the amount of unbalanced closing
  parens, for instance:
  \begin{agdalisting}
    \ExecuteMetaData[agda/Dyck.tex]{dyck-1-2}
  \end{agdalisting}
\end{definition}

Already Dyck words look easier to prove finite than straight binary trees, but
for that proof to be useful we'll have to relate Dyck words and binary trees
somehow.
As it happens, Dyck words of length \(2n\) are isomorphic to binary trees with
\(n-1\) leaves, but we only need to show this relation in one direction: from
Dyck to binary tree.
To demonstrate the algorithm we'll use a simple tree definition:
\begin{agdalisting}
  \ExecuteMetaData[agda/Dyck.tex]{tree-simpl-def}
\end{agdalisting}
The algorithm itself is quite similar to stack-based parsing algorithms.
\begin{agdalisting}
  \ExecuteMetaData[agda/Dyck.tex]{from-dyck}
\end{agdalisting}
\subsection{Filtering to Correct Expressions}
\subsection{Putting It All Together}
\section{Automating Proofs}
One use for above constructions is the automation of certain proofs.
In \cite{firsovDependentlyTypedProgramming2015}, which uses a similar approach
to ours, the \(\AgdaDatatype{Pauli}\) group is used as an example.
\ExecuteMetaData[agda/Data/Pauli.tex]{def}
As \(\AgdaDatatype{Pauli}\) has 4 constructors, \(n\)-ary functions on
\(\AgdaDatatype{Pauli}\) may require up to \(4^n\) cases, making even simple
proofs prohibitively verbose.

The alternative is to derive the things we need from omniscience, itself derived
from a finiteness predicate.
For proof search, the procedure is a well-known one in Agda
\cite{devrieseBrightSideType2011}: we ask for the result of a decision procedure
as an \emph{instance argument}, which will demand computation during
typechecking.
Our addition to this technique is a way to handle multiple arguments based on
fully level-polymorphic dependent currying and uncurrying, building on 
\cite{allaisGenericLevelPolymorphic2019}.
\ExecuteMetaData[agda/Data/Pauli.tex]{assoc-prf}

Finally, we can derive decidable equality on functions over finite types.
We can also use functions in our proof search.
Here, for instance, is an automated procedure which finds the
\(\AgdaFunction{not}\) function on \(\mathbf{Bool}\), given a specification.
\ExecuteMetaData[agda/Data/Pauli.tex]{not-spec}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: