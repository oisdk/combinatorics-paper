\chapter{Search} \label{search}
A common theme in dependently-typed programming is that proofs of interesting
theoretical things may actually correspond to useful algorithms in some way
related to that thing.
Finiteness is one such case: if we have a proof that a type \(A\) is finite,
we should be able to search through all the elements of that type in a
systematic, automated way.

As it happens, this kind of search is a very common method of proof automation
in dependently-typed languages like Agda.
Proofs of statements like ``the following function is associative''
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{and-def}
\end{agdalisting}
can be tedious: the associativity proof in particular would take \(2^3 = 8\)
cases.
This is unacceptable!
There are only finitely many cases to examine, after all, and we're
\emph{already} on a computer: why not automate it?
A proof that \(\AgdaDatatype{Bool}\) is finite can get us much of the way to a
library to do just that.
\todo{These examples so far are pretty focused on the bool associativity
  example.
  I'm not sure I can think of a good way to put countdown in instead: will we
  try switch?
  Or will we keep the bool for this short bit?
  }

Similar automation machinery can be leveraged to provide search algorithms for
certain ``logic programming''-esque problems.
Using the machinery we will describe in this section, though, when the program
says it finds a solution to some problem that solution will be accompanied by a
formal \emph{proof} of its correctness.

In this section, we will describe the theoretical underpinning and
implementation of a library for proof search over finite domains, based on the
finiteness predicates we have introduced already.
The library will be able to prove statements like the proof of associativity
above, as well as more complex statements.
As a running example for a ``more complex statement'' we will use the countdown
problem, which we have been using throughout: we will demonstrate how to
construct a prover for the existence of, or absence of, a solution to a given
countdown puzzle.

The API for writing searches over finite domains comes from the language of the
\(\Pi\)-pretopos: with it we will show how to compose QuickCheck-like generators
for proof search, with the addition of some automation machinery that allows us
to prove things like the associativity in a couple of lines:
\begin{agdalisting} \label{bool-assoc-auto-proof}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{bool-assoc-auto-proof}
\end{agdalisting}

We have already, in previous sections, explored the theoretical implications of
Cubical Type Theory on our formalisation.
With this library for proof search, however, we will see two distinct
practical applications which would simply not be possible without
computational univalence.
First and foremost: our proofs of finiteness, constructed with the API we will
describe, have all the power of full equalities.
Put another way any proof over a finite type \(A\) can be lifted to any other
type with the same cardinality.
Secondly our proof search can range over functions: we could, for instance, have
asked the prover to find if \emph{any} function over \(\AgdaDatatype{Bool}\) is
associative, and if so return it to us.
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{some-assoc}
\end{agdalisting}
The usefulness of which is dubious, but we will see a more interesting
application soon.
\section{Proof Automation And Search Techniques}
For this prover we will not resort to reflection or similar techniques: instead,
we will trick the type checker to do our automation for us.
This is a relatively common technique, although not so much outside of Agda, so
we will briefly explain it here.

To understand the technique we should first notice that some proof automation
\emph{already} happens in Agda, like the following:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{obvious}
\end{agdalisting}
The type checker does not require us to manually explain each step of evaluation
of:
\(\AgdaInductiveConstructor{true}\;\AgdaFunction{∧}\;\AgdaInductiveConstructor{false}\).
While it's not a particularly impressive example of automation, it does nonetheless
demonstrate a principle we will exploit: closed terms will compute to a normal
form if they're needed to type check.
The type checker will perform \(\beta\)-reduction as much as it can.

So our task is to rewrite proof obligations like the one in
Equation~\ref{bool-assoc-auto-proof} into ones which can reduce completely. 
As it turns out, we have already described the type of proofs which can ``reduce
completely'': \emph{decidable} proofs.
If we have a decision procedure over some proposition \(P\) we can run that
decision during type checking, because the decision procedure itself is a proof
that the decision will terminate.
In code, we capture this idea with the following pair of functions:
\begin{multicols}{2}
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Bool.tex]{is-true}
  \end{agdalisting} \columnbreak
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Bool.tex]{from-true}
  \end{agdalisting}
\end{multicols}
The first is a function which derives a type from whether a decision is
successful or not.
This function is important because if we use the output of this type at any
point we will effectively force the unifier to run the decision computation.
The second takes---as an implicit argument---an inhabitant of the type generated
from the first, and uses it to prove that the decision can only be true, and the
extracts the resulting proof from that decision.
All in all, we can use it like this:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{extremely-obvious}
\end{agdalisting}
This technique will allow us to automatically compute any decidable predicate.
\section{Omniscience}
So we now know what is needed of us for proof automation: we need to take our
proofs and make them decidable.
In particular, we need to be able to ``lift'' decidability back over a
function arrow.
For instance, given \(x\), \(y\), and \(z\) we already have
\(\AgdaDatatype{Dec}\;((x\;\AgdaFunction{∧}\;y)\;\AgdaFunction{∧}\;z\;\AgdaFunction{≡}\;x\;\AgdaFunction{∧}\;(y\;\AgdaFunction{∧}\;z))\)
(because equality over booleans is decidable).
In order to turn this into a proof that \AgdaFunction{∧} is associative we need
\(\AgdaDatatype{Dec}\;(\forall \; x \; y \; z \rightarrow (x\;\AgdaFunction{∧}\;y)\;\AgdaFunction{∧}\;z\;\AgdaFunction{≡}\;x\;\AgdaFunction{∧}\;(y\;\AgdaFunction{∧}\;z))\).
The ability to do this is described formally by the notion of
``Exhaustibility''.
\begin{definition}[Exhaustibility]
  We say a type \(A\) is exhaustible if, for any decidable predicate \(P\) on
  \(A\), the universal quantification of the predicate is decidable.
  \begin{agdalisting}
    \ExecuteMetaData[agda/Relation/Nullary/Omniscience.tex]{exhaustible}
  \end{agdalisting}
\end{definition}
This property of \AgdaDatatype{Bool} would allow us to automate the proof of
associativity, but it is in fact not strong enough to find individual
representatives of a type which support some property.
For that we need the more well-known, but related, property of
\emph{omniscience}.
\begin{definition}[Limited Principle of Omniscience]
  For any type \(A\) and predicate \(P\) on \(A\), the limited principle of
  omniscience \cite{myhillErrettBishopFoundations1972} is as follows:
  \begin{agdalisting}
    \ExecuteMetaData[agda/Relation/Nullary/Omniscience.tex]{omniscient}
  \end{agdalisting}
  In other words, for any decidable predicate the existential quantification of
  that predicate is also decidable.
\end{definition}

Because we're constructive, only a select few types are omniscient: finite
types, for instance (the law of the excluded middle implies that all types are
omniscient, meaning that all types are omniscient classically).
Perhaps surprisingly, it is not \emph{only} finite types which are exhaustible.
Certain infinite types can be
exhaustible~\cite{escardoInfiniteSetsThat2007}, but an exploration of that is
beyond the scope of this work.

Omniscience and exhaustibility are not interchangeable: every omniscient type is
exhaustible, but the converse is not true.
Conceptually, omniscience needs some kind of ordering on the underlying type.
This is because omniscience returns a candidate satisfying the given predicate:
there is no requirement, though, that only one element in the underlying type
satisfies the decidable predicate.
As a result, omniscience needs some way to choose among all possible candidates:
this is the ``order'' we are referring to.
This is also the same ``order'' that we referred to when talking about the
finiteness predicates: all ordered predicates (in
Figure~\ref{finite-classification}) imply omniscience, whereas the unordered
predicates only imply exhaustibility.
\begin{lemma}
  Omniscience implies exhaustibility
\end{lemma}
\begin{proof}
  \todo{proof here}
\end{proof}

\begin{lemma}
  If exhaustibility implies omniscience, then the axiom of choice holds
\end{lemma}
\begin{proof}
  \todo{proof here}
\end{proof}

And the relation to the finiteness predicates is straightforward: all of the
finiteness predicates we have seen imply exhaustibility, and all of the ordered
finiteness predicates imply omniscience.
We can prove this by showing exhaustibility and omniscience for the weakest
candidate of finiteness predicates.
\begin{lemma}
  Kuratowski finiteness implies exhaustibility
\end{lemma}
\begin{lemma}
  Manifest enumerability implies omniscience
\end{lemma}

Finally, we can get around the order requirement for prop-valued predicates for
omniscience.
\begin{lemma}
  Omniscience and exhaustibility coincide for prop-valued predicates.
\end{lemma}
\section{Countdown}
We have already introduced and described countdown: in this section, we will
fill in the remaining parts of the solver, glue the pieces together, and show
how the finiteness proofs can assist us to write the solver.
\subsection{Finite Permutations}
The first step of the transformation we will represent as a finite object is a
\emph{permutation}: once we choose the numbers we're going to use for the
candidate for the solution, we have to order them in some way.

Our first attempt at representing permutations might look something like this:
\begin{agdalisting}
  \ExecuteMetaData[agda/Countdown.tex]{wrong-perm}
\end{agdalisting}
the idea is that \(\AgdaDatatype{Perm}\;n\) represents a permutation of \(n\)
things, as a function from positions to positions.
Unfortunately such a simple answer won't work: there are no restrictions on the
operation of the function, so it could (for instance), send more than one input
position into the same output.

What we actually need is not just a function between positions, but an
\emph{isomorphism} between them.
In types:
\begin{agdalisting}
  \ExecuteMetaData[agda/Countdown.tex]{iso-perm}
\end{agdalisting}
Where an isomorphism is defined as follows:
\begin{agdalisting}
  \ExecuteMetaData[agda/Countdown.tex]{isomorphism}
\end{agdalisting}
\todo{Should this isomorphism definition be put earlier in the intro with the
  equivalences etc?}
While it may look complex, this term is actually composed of individual
components we've already proven finite.
First we have \(\AgdaDatatype{Fin}\;n\rightarrow\AgdaDatatype{Fin}\;n\):
functions between finite types are, as we know, finite
(Theorem~\ref{split-enum-pi}).
We take a pair of them: pairs of finite things are \emph{also} finite
(Lemma~\ref{split-enum-sigma}).
To get the next two components we can filter to the subobject: this requires
these predicates to be decidable. \todo{Need to do filter subobject in topos section}
We will construct a term of the following type:
\begin{agdalisting}
  \ExecuteMetaData[agda/Cardinality/Finite/ManifestBishop.tex]{dec-type}
\end{agdalisting}
So can we construct such a term? Yes!

We basically need to construct decidable equality for functions between
\(\AgdaDatatype{Fin}\;n\)s: of course, this decidable equality is provided by
the fact that such functions are themselves finite.

All in all we can now prove that the isomorphism, and by extension the
permutation, is finite:
\begin{agdalisting}
  \ExecuteMetaData[agda/Cardinality/Finite/ManifestBishop.tex]{iso-finite}
\end{agdalisting}

Unfortunately this implementation is too slow to be useful.
As nice and declarative as it is, fundamentally it builds a list of all possible
pairs of functions between \(\AgdaDatatype{Fin}\;n\) and itself (an operation
which takes in the neighbourhood of \(\mathcal{O}(n^n)\) time), and then tests
each for equality (which is likely worse than \(\mathcal{O}(n^2)\) time).
We will instead use a factoriadic encoding: this is a relatively simple encoding
of permutations which will reduce our time to a blazing fast
\(\mathcal{O}(n!)\).
It is expressed in Agda as follows:
\begin{agdalisting}
  \ExecuteMetaData[agda/Countdown.tex]{perm-def}
\end{agdalisting}
It is a vector of positions, each represented with a \(\AgdaDatatype{Fin}\).
Each position can only refer to the length of the tail of the list at that
point: this prevents two input positions mapping to the same output point, which
was the problem with the naive encoding we had previously.
And it also has a relatively simple proof of finiteness:
\begin{agdalisting}
  \ExecuteMetaData[agda/Countdown.tex]{perm-fin}
\end{agdalisting}
\subsection{Parenthesising}
Our next step is figuring out a way to encode the parenthesisation of the
expression (Fig.~\ref{countdown-parens}). \todo{There's no way
  ``parenthesisation'' is a real word}
At this point of the transformation, we already have our numbers picked out, we
have ordered them a certain way, and we have also selected the operators we're
interested in.
We have, in other words, the following:
\begin{equation}
  3 \times 7 \times 50 - 10 - 25
\end{equation}
Without parentheses, however, (or a religious adherence to BOMDAS) this
expression is still ambiguous.
\begin{align}
  3 \times ((7 \times (50 - 10)) - 25) &= 765 \\
  (((3 \times 7) \times 50) - 10) - 25 &= 1015
\end{align}
The different ways to parenthesise the expression result in different outputs
of evaluation.

So what data type encapsulates the ``different ways to parenthesise'' a given
expression?
That's what we will figure out in this section, and what we will prove finite.

One way to approach the problem is with a binary tree.
A binary tree with \(n\) leaves corresponds in a straightforward way to a
parenthesisation of \(n\) numbers (Fig.~\ref{countdown-parens}).
\todo{Tree diagram? Or link to previous tree?}
This doesn't get us much closer to a finiteness proof, however: for that we will
need to rely on \emph{Dyck} words.
\begin{definition}[Dyck words]
  A Dyck word is a string of balanced parentheses.
  In Agda, we can express it as the following:
  \begin{agdalisting}
    \ExecuteMetaData[agda/Dyck.tex]{dyck-def}
  \end{agdalisting}
  A fully balanced string of \(n\) parentheses has the type
  \(\AgdaDatatype{Dyck}\;\AgdaInductiveConstructor{zero}\;n\).
  Here are some example strings:
  \begin{multicols}{2}
    \begin{agdalisting}
      \ExecuteMetaData[agda/Dyck.tex]{dyck-0-2}
    \end{agdalisting}
    \begin{agdalisting}
      \ExecuteMetaData[agda/Dyck.tex]{dyck-0-3}
    \end{agdalisting}
  \end{multicols}
  The first parameter on the type represents the amount of unbalanced closing
  parens, for instance:
  \begin{agdalisting}
    \ExecuteMetaData[agda/Dyck.tex]{dyck-1-2}
  \end{agdalisting}
\end{definition}

Already Dyck words look easier to prove finite than straight binary trees, but
for that proof to be useful we'll have to relate Dyck words and binary trees
somehow.
As it happens, Dyck words of length \(2n\) are isomorphic to binary trees with
\(n-1\) leaves, but we only need to show this relation in one direction: from
Dyck to binary tree.
To demonstrate the algorithm we'll use a simple tree definition:
\begin{agdalisting}
  \ExecuteMetaData[agda/Dyck.tex]{tree-simpl-def}
\end{agdalisting}
The algorithm itself is quite similar to stack-based parsing algorithms.
\begin{agdalisting}
  \ExecuteMetaData[agda/Dyck.tex]{from-dyck}
\end{agdalisting}
\subsection{Filtering to Correct Expressions}
\subsection{Putting It All Together}
\section{Automating Proofs}
One use for above constructions is the automation of certain proofs.
In \cite{firsovDependentlyTypedProgramming2015}, which uses a similar approach
to ours, the \(\AgdaDatatype{Pauli}\) group is used as an example.
\ExecuteMetaData[agda/Data/Pauli.tex]{def}
As \(\AgdaDatatype{Pauli}\) has 4 constructors, \(n\)-ary functions on
\(\AgdaDatatype{Pauli}\) may require up to \(4^n\) cases, making even simple
proofs prohibitively verbose.

The alternative is to derive the things we need from omniscience, itself derived
from a finiteness predicate.
For proof search, the procedure is a well-known one in Agda
\cite{devrieseBrightSideType2011}: we ask for the result of a decision procedure
as an \emph{instance argument}, which will demand computation during
typechecking.
Our addition to this technique is a way to handle multiple arguments based on
fully level-polymorphic dependent currying and uncurrying, building on 
\cite{allaisGenericLevelPolymorphic2019}.
\ExecuteMetaData[agda/Data/Pauli.tex]{assoc-prf}

Finally, we can derive decidable equality on functions over finite types.
We can also use functions in our proof search.
Here, for instance, is an automated procedure which finds the
\(\AgdaFunction{not}\) function on \(\mathbf{Bool}\), given a specification.
\ExecuteMetaData[agda/Data/Pauli.tex]{not-spec}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: