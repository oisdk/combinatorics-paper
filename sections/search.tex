\chapter{Search} \label{search}
Finiteness proofs often play a role in proof automation in dependently-typed
programming languages \cite{firsovDependentlyTypedProgramming2015}.
Our work here is no exception.
Our work goes slightly further than similar libraries which already exist,
however: using CuTT we are able to search over functions as well as finite data
types.
\section{Countdown}
\section{Omniscience}
\begin{definition}[Limited Principle of Omniscience]
  For any type \(A\) and predicate \(P\) on \(A\), the limited principle of
  omniscience \cite{myhillErrettBishopFoundations1972} is as follows:
  \begin{equation}
    \left( \Pi {(x : A)} , \mathbf{Dec}(P(x)) \right) \rightarrow \mathbf{Dec} \left( \Sigma {(x : A)} , P(x) \right)
  \end{equation}
  In other words, for any decidable predicate the existential quantification of
  that predicate is also decidable.
\end{definition}
The limited principle of omniscience is non-constructive, but individual types
can themselves satisfy omniscience.
In particular, cardinal finite types are omniscient.

There is also a universal form of omniscience, which we call exhaustibility.
\begin{definition}[Exhaustibility]
  We say a type \(A\) is exhaustible if, for any decidable predicate \(P\) on
  \(A\), the universal quantification of the predicate is decidable.
  \begin{equation}
    \left( \Pi {(x : A)} , \mathbf{Dec}(P(x)) \right) \rightarrow \mathbf{Dec} \left( \Pi {(x : A)} , P(x) \right)
  \end{equation}
\end{definition}

All of the finiteness predicates we have seen imply exhaustibility.
Omniscience is stronger than exhaustibility, as we can derive the latter from
the former.
All of the ordered finiteness predicates imply omniscience.
For the unordered finiteness definitions, we have omniscience for prop-valued
predicates.
\section{Automating Proofs}
One use for above constructions is the automation of certain proofs.
In \cite{firsovDependentlyTypedProgramming2015}, which uses a similar approach
to ours, the \(\AgdaDatatype{Pauli}\) group is used as an example.
\ExecuteMetaData[agda/Data/Pauli.tex]{def}
As \(\AgdaDatatype{Pauli}\) has 4 constructors, \(n\)-ary functions on
\(\AgdaDatatype{Pauli}\) may require up to \(4^n\) cases, making even simple
proofs prohibitively verbose.

The alternative is to derive the things we need from omniscience, itself derived
from a finiteness predicate.
For proof search, the procedure is a well-known one in Agda
\cite{devrieseBrightSideType2011}: we ask for the result of a decision procedure
as an \emph{instance argument}, which will demand computation during
typechecking.
Our addition to this technique is a way to handle multiple arguments based on
fully level-polymorphic dependent currying and uncurrying, building on 
\cite{allaisGenericLevelPolymorphic2019}.
\ExecuteMetaData[agda/Data/Pauli.tex]{assoc-prf}

Finally, we can derive decidable equality on functions over finite types.
We can also use functions in our proof search.
Here, for instance, is an automated procedure which finds the
\(\AgdaFunction{not}\) function on \(\mathbf{Bool}\), given a specification.
\ExecuteMetaData[agda/Data/Pauli.tex]{not-spec}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: