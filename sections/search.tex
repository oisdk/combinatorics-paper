\chapter{Search} \label{search}
A common theme in dependently-typed programming is that proofs of interesting
theoretical things may actually correspond to useful algorithms in some way
related to that thing.
Finiteness is one such case: if we have a proof that a type \(A\) is finite,
we should be able to search through all the elements of that type in a
systematic, automated way.

As it happens, this kind of search is a very common method of proof automation
in dependently-typed languages like Agda.
Proofs of statements like ``the following function is associative''
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{and-def}
\end{agdalisting}
can be tedious: the associativity proof in particular would take \(2^3 = 8\)
cases.
This is unacceptable!
There are only finitely many cases to examine, after all, and we're
\emph{already} on a computer: why not automate it?
A proof that \(\AgdaDatatype{Bool}\) is finite can get us much of the way to a
library to do just that.
\todo[inline]{These examples so far are pretty focused on the bool associativity
  example.
  I'm not sure I can think of a good way to put countdown in instead: will we
  try switch?
  Or will we keep the bool for this short bit?
  }

Similar automation machinery can be leveraged to provide search algorithms for
certain ``logic programming''-esque problems.
Using the machinery we will describe in this section, though, when the program
says it finds a solution to some problem that solution will be accompanied by a
formal \emph{proof} of its correctness.

In this section, we will describe the theoretical underpinning and
implementation of a library for proof search over finite domains, based on the
finiteness predicates we have introduced already.
The library will be able to prove statements like the proof of associativity
above, as well as more complex statements.
As a running example for a ``more complex statement'' we will use the countdown
problem, which we have been using throughout: we will demonstrate how to
construct a prover for the existence of, or absence of, a solution to a given
countdown puzzle.

The API for writing searches over finite domains comes from the language of the
\(\Pi\)-pretopos: with it we will show how to compose QuickCheck-like generators
for proof search, with the addition of some automation machinery that allows us
to prove things like the associativity in a couple of lines:
\begin{agdalisting} \label{bool-assoc-auto-proof}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{bool-assoc-auto-proof}
\end{agdalisting}

We have already, in previous sections, explored the theoretical implications of
Cubical Type Theory on our formalisation.
With this library for proof search, however, we will see two distinct
\emph{practical} applications which would simply not be possible without
computational univalence.
First and foremost: our proofs of finiteness, constructed with the API we will
describe, have all the power of full equalities.
Put another way any proof over a finite type \(A\) can be lifted to any other
type with the same cardinality.
Secondly our proof search can range over functions: we could, for instance, have
asked the prover to find if \emph{any} function over \(\AgdaDatatype{Bool}\) is
associative, and if so return it to us.
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{some-assoc}
\end{agdalisting}
The usefulness of which is dubious, but we will see a more interesting
application soon.
\section{Proof Automation And Search Techniques}
For this prover we will not resort to reflection or similar techniques: instead,
we will trick the type checker to do our automation for us.
This is a relatively common technique, although not so much outside of Agda, so
we will briefly explain it here.

To understand the technique we should first notice that some proof automation
\emph{already} happens in Agda, like the following:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{obvious}
\end{agdalisting}
The type checker does not require us to manually explain each step of evaluation
of:
\(\AgdaInductiveConstructor{true}\;\AgdaFunction{∧}\;\AgdaInductiveConstructor{false}\).
While it's not a particularly impressive example of automation, it does nonetheless
demonstrate a principle we will exploit: closed terms will compute to a normal
form if they're needed to type check.

So our task is to rewrite proof obligations like the one in
Equation~\ref{bool-assoc-auto-proof} into ones which can reduce completely. 
As it turns out, we have already described the type of proofs which can ``reduce
completely'': \emph{decidable} proofs.
If we have a decision procedure over some proposition \(P\) we can run that
decision during type checking, because the decision procedure itself is a proof
that the decision will terminate.
In code, we capture this idea with the following pair of functions:
\begin{multicols}{2}
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Bool.tex]{is-true}
  \end{agdalisting} \columnbreak
  \begin{agdalisting}
    \ExecuteMetaData[agda/Snippets/Bool.tex]{from-true}
  \end{agdalisting}
\end{multicols}
The first is a function which derives a type from whether a decision is
successful or not.
This function is important because if we use the output of this type at any
point we will effectively force the unifier to run the decision computation.
The second takes---as an implicit argument---an inhabitant of the type generated
from the first, and uses it to prove that the decision can only be true, and the
extracts the resulting proof from that decision.
All in all, we can use it like this:
\begin{agdalisting}
  \ExecuteMetaData[agda/Snippets/Bool.tex]{extremely-obvious}
\end{agdalisting}
This technique will allow us to automatically compute any decidable predicate.
\section{Omniscience}
So we now know what is needed of us for proof automation: we need to take our
proofs and make them decidable.
In particular, our strategy will be to take a proposition which is decidable in
the individual case (like
\((x\;\AgdaFunction{∧}\;y)\;\AgdaFunction{∧}\;z\;\AgdaFunction{≡}\;x\;\AgdaFunction{∧}\;(y\;\AgdaFunction{∧}\;z)\)
for a given \(x\), \(y\), and \(z\)) and make it decidable in the universal case.
Whether this is possible or not is a property of the \emph{domain} of a
decidable predicate, and is described formally by the notion of ``Exhaustibility''.
\begin{definition}[Exhaustibility]
  We say a type \(A\) is exhaustible if, for any decidable predicate \(P\) on
  \(A\), the universal quantification of the predicate is decidable.
  \begin{equation}
    \left( \Pi {(x : A)} , \mathbf{Dec}(P(x)) \right) \rightarrow \mathbf{Dec} \left( \Pi {(x : A)} , P(x) \right)
  \end{equation}
\end{definition}
This property of \AgdaDatatype{Bool} would allow us to automate the proof of
associativity, but it is in fact not strong enough to find individual
representatives of a type which support some property.
For that we need the more well-known, but related, property of
\emph{omniscience}.
\begin{definition}[Limited Principle of Omniscience]
  For any type \(A\) and predicate \(P\) on \(A\), the limited principle of
  omniscience \cite{myhillErrettBishopFoundations1972} is as follows:
  \begin{equation}
    \left( \Pi {(x : A)} , \mathbf{Dec}(P(x)) \right) \rightarrow \mathbf{Dec} \left( \Sigma {(x : A)} , P(x) \right)
  \end{equation}
  In other words, for any decidable predicate the existential quantification of
  that predicate is also decidable.
\end{definition}

Both of these properties only make sense to talk about in a constructive
setting: classically speaking, \emph{every} type is omniscient and exhaustible.
Finite types are omniscient (the reason should be clear, but we will prove this
fact presently), but perhaps surprisingly, it is not \emph{only} finite types
which are exhaustible.
Certain infinite types can be
exhaustible~\cite{escardoInfiniteSetsThat2007}, but an exploration of that is
beyond the scope of this work.

Omniscience and exhaustibility are not interchangeable: conceptually, for
omniscience you need some kind of ordering on the underlying type.
If we had a property, say like the associativity property above, that is
satisfied by more than one element of the type, we would have to have some way
to pick a candidate element from the type to return in the case of the property
being satisfied.
This requirement of order mirrors the Ord difference in
Fig.~\ref{finite-classification}.

Omniscience implies exhaustibility, then, but the converse is not true.
\begin{lemma}
  Omniscience implies exhaustibility
\end{lemma}
\begin{proof}
  \todo{proof here}
\end{proof}

And the relation to the finiteness predicates is straightforward: all of the
finiteness predicates we have seen imply exhaustibility, and all of the ordered
finiteness predicates imply omniscience.
We can prove this by showing exhaustibility and omniscience for the weakest
candidate of finiteness predicates.
\begin{lemma}
  Kuratowski finiteness implies exhaustibility
\end{lemma}
\begin{lemma}
  Manifest enumerability implies omniscience
\end{lemma}

Finally, we can get around the order requirement for prop-valued predicates for
omniscience.
\begin{lemma}
  Omniscience and exhaustibility coincide for prop-valued predicates.
\end{lemma}


\section{Countdown}
\section{Automating Proofs}
One use for above constructions is the automation of certain proofs.
In \cite{firsovDependentlyTypedProgramming2015}, which uses a similar approach
to ours, the \(\AgdaDatatype{Pauli}\) group is used as an example.
\ExecuteMetaData[agda/Data/Pauli.tex]{def}
As \(\AgdaDatatype{Pauli}\) has 4 constructors, \(n\)-ary functions on
\(\AgdaDatatype{Pauli}\) may require up to \(4^n\) cases, making even simple
proofs prohibitively verbose.

The alternative is to derive the things we need from omniscience, itself derived
from a finiteness predicate.
For proof search, the procedure is a well-known one in Agda
\cite{devrieseBrightSideType2011}: we ask for the result of a decision procedure
as an \emph{instance argument}, which will demand computation during
typechecking.
Our addition to this technique is a way to handle multiple arguments based on
fully level-polymorphic dependent currying and uncurrying, building on 
\cite{allaisGenericLevelPolymorphic2019}.
\ExecuteMetaData[agda/Data/Pauli.tex]{assoc-prf}

Finally, we can derive decidable equality on functions over finite types.
We can also use functions in our proof search.
Here, for instance, is an automated procedure which finds the
\(\AgdaFunction{not}\) function on \(\mathbf{Bool}\), given a specification.
\ExecuteMetaData[agda/Data/Pauli.tex]{not-spec}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: