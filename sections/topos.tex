\chapter{Topos} \label{topos}
In this section we will examine the categorical interpretation of finite sets.
In particular, we will prove that decidable Kuratowski finite types form a
\(\Pi\)-pretopos.
A lot of the work for this proof has been done already: in
Theorem~\ref{cardinal-kuratowski} we saw that discrete Kuratowski finite types
were equivalent to Cardinally finite types.
We will use the latter definition implementation-wise from now on, as it is
slightly easier to work with: CuTT's transport means we can do this without loss
of generality.

There are two reasons we're interested in the categorical and topos-theoretic
interpretation of finite sets: first, it's an important theoretical grounding
for finite sets, which allows us to understand them in the context of other
set-like constructions.
Secondly, and more practically, the language of a topos is (or in our case the
\(\Pi\)-pretopos) is a common standard framework for doing mathematics
generally.
This makes it a good basis for an API for building QuickCheck-like generators,
for example.
\section{Categories in HoTT}
At first glance, HoTT seems like a perfect setting for category theory: the
univalence axiom identifies isomorphisms with equality, a useful tool for
category theory missing from MLTT.
While this initial impression is broadly true, the construction of categories in
HoTT is unfortunately quite complex and involved (much of the following is a
summary of \citet[chapter 9]{hottbook}).

\todo{references here are tricky, need to disentangle the contributions quite
  precisely}
Much of this section is simply a summary of parts of \citet[chapter
9]{hottbook}.
The formal proofs we provide are part translation of those proofs in that
chapter, part from \cite{iversenFredefoxCat2018}
\cite{huProofrelevantCategoryTheory2020}, and part our own.

First, we need to think about the type of objects and arrows.
We cannot, unfortunately, leave them unrestricted: because of the potential for
higher homotopy in HoTT types \todo{This sentence is a tongue twister}, we have
to restrict the type of arrows to just the sets.
This notion: that of a category with all the usual laws such that arrows are a
set, is called a \emph{precategory}.
\begin{agdalisting}
  \ExecuteMetaData[agda/Categories.tex]{precategory}
\end{agdalisting}
We will use long arrows to refer to morphisms within a category:
\begin{agdalisting}
  \ExecuteMetaData[agda/Categories.tex]{morph-arrow}
\end{agdalisting}

From here, we can define a notion of isomorphisms.
\begin{agdalisting}
  \ExecuteMetaData[agda/Categories.tex]{isomorphism}
\end{agdalisting}
It's a condition on this type which separates the precategories from the
categories: if it satisfies a form of univalence, it the precategory is a full
category.
\begin{agdalisting}
  \ExecuteMetaData[agda/Categories.tex]{cat-univalence}
\end{agdalisting}
\section{The Category of Sets}

\section{Closure}
\todo{This is just the closure bits pulled over from the finiteness predicates
  section. They need to be reworked to fit in here.}
\subsection{Split Enumerability Closure}
Now that we have a suitable definition of finiteness, we will next prove that
some things are finite.
With the most basic simple types out of the way, the obvious next choice is the
(non-dependent) sums and products: \(\uplus\) and \(\times\).
Both of these types can be constructed from the \emph{dependent} sum, however,
so that is the type we will prove finite.
From that we can derive a much wider array of finiteness proofs.

\begin{lemma} \label{split-enum-sigma} \todo{Convert to Agda}
  Split enumerability is closed under \(\Sigma\).
  \begin{equation}
    \frac{
      \AgdaDatatype{\ensuremath{\mathcal{E}!}}\;A \; \; \; (x : A) \rightarrow \AgdaDatatype{\ensuremath{\mathcal{E}!}}(U\;x)
    }{
      \AgdaDatatype{\ensuremath{\mathcal{E}!}}(\AgdaDatatype{\ensuremath{\Sigma [}}\;x \AgdaDatatype{:} A \AgdaDatatype{]} U\;x)
    }
  \end{equation}
\end{lemma}
\begin{proof}
  Let \(A\) be a type which is split enumerable, and \(U\) be a type family over
  \(A\) which is split enumerable at every point.
  Formally, we have the following proofs:
  \begin{align}
    \AgdaDatatype{\ensuremath{\mathcal{E}!}}_A &: \AgdaDatatype{\ensuremath{\mathcal{E}!}}(A) \\
    \AgdaDatatype{\ensuremath{\mathcal{E}!}}_U &: \Pi(x : A) , \AgdaDatatype{\ensuremath{\mathcal{E}!}}(U(x))
  \end{align}

  Our task is to construct a proof of type:
  \begin{equation}
    \AgdaDatatype{\ensuremath{\mathcal{E}!}}(\Sigma(x : A) , U(x))
  \end{equation}
  This proof itself is composed of two components:
  \begin{align}
    \mathit{support} &: \AgdaDatatype{List}(\Sigma(x : A) , U(x)) \\
    \mathit{cover} &: \Pi(x : \Sigma(y : A) , U(y)) , x \in \mathit{support}
  \end{align}
  To construct the support list, we apply the function \(\AgdaDatatype{\ensuremath{\mathcal{E}!}}_U\) to
  every element in the support list of \(\AgdaDatatype{\ensuremath{\mathcal{E}!}}_A\), extract the support
  lists from the resulting finiteness proofs, and concatenate them.


  To prove that this support list does in fact cover the entirety of the type
  \(\Sigma \; A \; U\), we note that any element of type \(\Sigma \; A \; U\)
  must have a first component in the support list of \(\AgdaDatatype{\ensuremath{\mathcal{E}!}}_A\), and its
  second component must be in the result of applying \(\AgdaDatatype{\ensuremath{\mathcal{E}!}}_U\) to that
  first element (since that support list contains every element of type
  \(U(x)\)).
  Therefore, the pair itself must be in our constructed support list.
\end{proof}

This pattern of applying a function to each element in a list and
concatenating the result is of course well-known in functional programming,
and is in fact the pattern that makes lists a monad.
While this insight isn't strictly relevant to our work here, it does mean
the implementation of this function can use Agda's do notation, resulting
in the following extremely clean implementation:
\begin{agdalisting}
  \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{sup-sigma}
\end{agdalisting}

We now have two components we'll need for the proof that the countdown
transformation is finite.
The component we'll look at is step~\ref{countdown-operators}: selection of the
operators.
We'll first need a type representing the operators available to us.
\begin{agdalisting}
  \ExecuteMetaData[agda/Countdown.tex]{ops-def}
\end{agdalisting}
Proving that this type is finite takes much the same form as the proof of
finiteness for bool.
\begin{agdalisting} \label{op-fin}
  \ExecuteMetaData[agda/Countdown.tex]{op-fin}
\end{agdalisting}

Next, we will need to build a proof of finiteness for vectors of length \(n\).
This uses the proof of finiteness for \(\Sigma\).
\begin{agdalisting}
  \ExecuteMetaData[agda/Countdown.tex]{vec-fin}
\end{agdalisting}

\subsection{Manifest Bishop Closure Under \(\Pi\)}
The glaring omission from our closure proofs under type formers so far has been
the \(\Pi\) type: we have not proved closure under functions, dependent or
otherwise.
In MLTT, this is of course not provable: since all of the finiteness predicates
we have seen so far imply decidable equality, and since we don't have any kind
of decidable equality on functions in MLTT, we know that we won't be able to
show that any kind of function is finite; even one like \(\AgdaDatatype{Bool}
\rightarrow \AgdaDatatype{Bool}\).

CuTT is not so restricted.
Since we have things like function extensionality and transport, we can indeed
prove the finiteness of function types.
Our proof here makes use directly of the univalence axiom, and makes use
furthermore of all the previous closure proofs.
We will prove this closure on split enumerability, rather than on manifest
Bishop finiteness, as it requires slightly less legwork in the proof itself, but
of course we can derive the proof on manifest Bishop finiteness in a few lines.
\begin{theorem} \label{split-enum-pi}
  Split enumerability is closed under dependent functions.
  (\(\Pi\)-types).
  \begin{equation}
    \frac{
      \AgdaDatatype{\ensuremath{\mathcal{E}!}}(A) \; \; \; \Pi {(x : A)} , \AgdaDatatype{\ensuremath{\mathcal{E}!}}\left( U(x) \right)
    }{
      \AgdaDatatype{\ensuremath{\mathcal{E}!}}\left(\Pi {(x : A)} , U(x)\right)
    }
  \end{equation}
\end{theorem}
\begin{proof}
  Let \(A\) be a split enumerable type, and \(U\) be a type family from \(A\),
  which is split enumerable over all points of \(A\).

  As \(A\) is split enumerable, we know that it is also manifestly Bishop finite
  (lemma~\ref{split-enum-to-manifest-bishop}), and consequently we know \(A
  \simeq \AgdaDatatype{Fin}\;n\), for some \(n\) (lemma~\ref{bishop-equiv}).
  We can therefore replace all occurrences of \(A\) with \(\AgdaDatatype{Fin}\;n\),
  changing our goal to:
  \begin{equation}
    \frac{
      \AgdaDatatype{\ensuremath{\mathcal{E}!}}(\AgdaDatatype{Fin}\;n) \; \; \; \Pi (x : \AgdaDatatype{Fin}\;n) , \AgdaDatatype{\ensuremath{\mathcal{E}!}}\left( U(x) \right)
    }{
      \AgdaDatatype{\ensuremath{\mathcal{E}!}}\left(\Pi (x : \AgdaDatatype{Fin}\;n) , U(x)\right)
    }
  \end{equation}
  
  We then define the type of \(n\)-tuples over some type family \(T :
  \AgdaDatatype{Fin}\;n \rightarrow \mathbf{Type}\).
  \begin{equation}
    \begin{alignedat}{3}
      & \mathbf{Tuple}(0, T)   &&\coloneqq \top \\
      & \mathbf{Tuple}(n+1, T) &&\coloneqq T(0) \times \mathbf{Tuple}(n, T \circ \text{suc})
    \end{alignedat}
  \end{equation}
  We can show that this type is equivalent to functions (proven in our formalisation):
  \begin{equation}
    \Pi(x : \AgdaDatatype{Fin}\;n) , U(x) \simeq \mathbf{Tuple}(n, U)
  \end{equation}
  And therefore we can simplify again our goal to the following:
  \begin{equation}
    \frac{
      \AgdaDatatype{\ensuremath{\mathcal{E}!}}(\AgdaDatatype{Fin}\;n) \; \; \; \Pi (x : \AgdaDatatype{Fin}\;n) , \AgdaDatatype{\ensuremath{\mathcal{E}!}}\left( U(x) \right)
    }{
      \AgdaDatatype{\ensuremath{\mathcal{E}!}}\left(\mathbf{Tuple}(n, U)\right)
    }
  \end{equation}
  
  We can prove this goal by showing that \(\mathbf{Tuple}(n, U)\) is split
  enumerable: it is made up of finitely many products of points of \(U\), which
  are themselves split enumerable, and \(\top\), which is also split enumerable.
  Lemma~\ref{split-enum-sigma} shows us that the product of finitely many split
  enumerable types is itself split enumerable, proving our goal.
\end{proof}

This proof can again give us insight into how to prove finiteness of our
countdown transformation.
In the first step (Fig.~\ref{countdown-selection}), we need to select some
numbers from an input list: this can be described with a function of type
\(\AgdaDatatype{Fin}\;n \rightarrow \AgdaDatatype{Bool}\), from indices in the
original list into whether we keep the values or not.
We now know that we can prove functions finite without difficulty: in this case,
we can do it even more simply by proving that an \(n\)-tuple of booleans is
finite.

\subsection{Closure on Cardinal Finiteness}
Since we don't have a function of type \(\mathcal{C}(A) \rightarrow
\AgdaDatatype{\ensuremath{\mathcal{B}}}(A)\), closure proofs on \(\AgdaDatatype{\ensuremath{\mathcal{B}}}\) do not transfer over to
\(\mathcal{C}\) trivially (unlike with \(\AgdaDatatype{\ensuremath{\mathcal{E}!}}\) and \(\AgdaDatatype{\ensuremath{\mathcal{B}}}\)).
The cases for \(\bot\), \(\top\), and \(\AgdaDatatype{Bool}\) are simple to adapt: we
can just propositionally truncate their Bishop finiteness proof.

Non-dependent operators like \(\times\), \(\uplus\), and \(\rightarrow\) are
also relatively straightforward: since \(\lVert {\wc} \rVert\) forms a monad, we
can apply \(n\)-ary functions to values inside it, combining them together.
\begin{agdalisting}
  The fact that \(\lVert \wc \rVert\) forms a monad means that we can lift
  \(n\)-ary functions like the following:
  \ExecuteMetaData[agda/Cardinality/Finite/ManifestBishop.tex]{times-clos-sig}
  Into a truncated context:
  \ExecuteMetaData[agda/Cardinality/Finite/Cardinal.tex]{times-clos-impl}
\end{agdalisting}

Unfortunately, for the dependent type formers like \(\Sigma\) and \(\Pi\), the
same trick does not work.
We have closure proofs like:
\begin{equation}
  \frac{
    \AgdaDatatype{\ensuremath{\mathcal{B}}}(A) \; \; \; \Pi(x : A) , \AgdaDatatype{\ensuremath{\mathcal{B}}}(U(x))
  }{
    \AgdaDatatype{\ensuremath{\mathcal{B}}}(\Pi \; A \; U)
  }
\end{equation}
If we apply the monadic truncation trick we can derive closure proofs like the
following:
\begin{equation}
  \frac{
    \lVert \AgdaDatatype{\ensuremath{\mathcal{B}}}(A) \rVert \; \; \; \lVert \Pi(x : A) , \AgdaDatatype{\ensuremath{\mathcal{B}}}(U(x)) \rVert
  }{
    \lVert \AgdaDatatype{\ensuremath{\mathcal{B}}}(\Pi \; A \; U) \rVert
  }
\end{equation}
However our \emph{desired} closure proof is the following:
\begin{equation}
  \frac{
    \lVert \AgdaDatatype{\ensuremath{\mathcal{B}}}(A) \rVert \; \; \; \Pi(x : A) , \lVert \AgdaDatatype{\ensuremath{\mathcal{B}}}(U(x)) \rVert
  }{
    \lVert \AgdaDatatype{\ensuremath{\mathcal{B}}}(\Pi \; A \; U) \rVert
  }
\end{equation}
They don't match!

The solution would be to find a function of the following type:
\begin{equation}
  (\Pi(x : A) , \lVert \AgdaDatatype{\ensuremath{\mathcal{B}}}(U(x)) \rVert) \rightarrow
  \lVert \Pi(x : A) , \AgdaDatatype{\ensuremath{\mathcal{B}}}(U(x)) \rVert
\end{equation}
However we might be disheartened at realising that this is a required goal: the
above equation is \emph{extremely} similar to the axiom of choice!
\begin{definition}[Axiom of Choice]
  In HoTT, the axiom of choice is commonly defined as follows \cite[lemma
  3.8.2]{hottbook}.
  For any set \(A\), and a type family \(U\) which is a set at all the points
  of \(A\), the following function exists:
  \begin{equation}
    \left( \Pi(x : A) ,  \lVert U(x) \rVert \right) \rightarrow \lVert \Pi(x : A) , U(x) \rVert
  \end{equation}
\end{definition}
Luckily the axiom of choice \emph{does} hold for cardinally finite types,
allowing us to prove the following:
\begin{lemma}
  \begin{equation}
    \mathcal{C}(A) \rightarrow (\Pi(x : A) , \lVert U(x) \rVert) \rightarrow \lVert \Pi(x : A) , U(x) \rVert
  \end{equation}
\end{lemma}
\begin{proof}
  Let \(A\) be a cardinally finite type, \(U\) be a type family on \(A\), and
  \(f\) be a dependent function of type \(\Pi(x : A) , \lVert U(x) \rVert\).

  First, since our goal is itself propositionally truncated, we have access to
  values under truncations: put another way, in the context of proving our goal,
  we can rely on the fact that \(A\) is manifestly Bishop finite.
  Using the same technique as we did in lemma~\ref{split-enum-pi}, we can switch
  from working with dependent functions from \(A\) to \(n\)-tuples, where \(n\)
  is the cardinality of \(A\).
  This changes our goal to the following:
  \begin{equation}
    \mathbf{Tuple}(n, \lVert \wc \rVert \circ U) \rightarrow \lVert \mathbf{Tuple}(n, U) \rVert
  \end{equation}
  Since \(\lVert \wc \rVert\) is closed under finite products, this function
  exists (in fact, using the fact that \(\lVert \wc \rVert\) forms a monad, we
  can recognise this function as \verb+sequenceA+ from the \verb+Traversable+
  class in Haskell).
\end{proof}


This gets us all of the necessary closure proofs on \(\mathcal{C}\).
\section{The Absence of the Subobject Classifier}
\begin{agdalisting} \label{filter-subobject}
  \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{subobject}
\end{agdalisting}


\section{Closure}
For the first three closure proofs, we only consider split enumerability:
as it is the strongest of the finiteness predicates, we can derive the other
closure proofs from it.

\section{The Category of Finite Sets}
HoTT and CuTT seem to be especially suitable settings for formalisations of
category theory.
The univalence axiom in particular allows us to treat categorical isomorphisms
as equalities, saving us from the dreaded ``setoid hell''.

We follow \cite[chapter 9]{hottbook} in its treatment of
categories in HoTT, and in its proof that sets do indeed form a category.
We will first briefly go through the construction of the category
\(\mathit{Set}\), as it differs slightly from the usual method in type theory.

First, the type of objects and arrows:
\begin{alignat}{3}
  &\text{Obj}_\mathit{Set}      &&\coloneqq \Sigma(x : \mathbf{Type}) , \text{isSet}(x) \\
  &\text{Hom}_\mathit{Set}(x , y) &&\coloneqq  \text{fst}(x) \rightarrow \text{fst}(y)
\end{alignat}
As the type of objects makes clear, we have already departed slightly from the
simpler \(\text{Obj}_\mathit{Set} \coloneqq \mathbf{Type}\) way of doing things:
of course we have to, as HoTT allows non-set types.
Furthermore, after proving the usual associativity and identity laws for
composition (which are definitionally true in this case), we must further show
\(\text{isSet}(\text{Hom}_\mathit{Set}(x,y))\); even then we only have a
precategory.

To show that \(\mathit{Set}\) is a category, we must show that categorical
isomorphisms are equivalent to equivalences.
In a sense, we must give a univalence rule for the category we are working in.

We have provided formal proofs that \(\mathit{Set}\) does indeed form a
category, and the following:
\begin{theorem}[The Category of Finite Sets]
  Finite sets form a category in HoTT when defined like so:
  \begin{equation}
    \begin{alignedat}{3}
      &\text{Obj}_\mathit{FinSet}      &&\coloneqq \Sigma(x : \mathbf{Type}) , \mathcal{C}(x) \\
      &\text{Hom}_\mathit{FinSet}(x , y) &&\coloneqq  \text{fst}(x) \rightarrow \text{fst}(y)
    \end{alignedat}
  \end{equation}
\end{theorem}
\section{The \(\Pi\)-pretopos of Finite Sets}
For this proof, we follow again the proof that \(\mathit{Set}\) forms a \(\Pi
W\)-pretopos from \cite[chapter 10]{hottbook} and
\cite{rijkeSetsHomotopyType2015}.
The difference here is that clearly we do not have access to \(W\)-types, as
they would permit infinitary structures.

We first must show that \(\mathit{Set}\) has an initial object and finite,
disjoint sums, which are stable under pullback.
We also must show that \(\mathit{Set}\) is a regular category with effective
quotients.
We now have a pretopos: the presence of \(\Pi\) types make it a
\(\Pi\)-pretopos.

We have proven the above statements for both \(\mathit{Set}\) and
\(\mathit{FinSet}\).
As far as we know, this is the first formalisation of either.
\begin{theorem} \label{finite-topos}
  The category of finite sets, \(\mathit{FinSet}\), forms a \(\Pi\)-pretopos.
\end{theorem}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End: