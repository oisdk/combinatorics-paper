\input{preamble}
\title{Finiteness in Cubical Type Theory}
\author{
  Donnacha Oisín Kidney\inst{1}\and Gregory Provan \inst{2}
}
\institute{
  University College Cork \email{o.kidney@cs.ucc.ie} \and
  University College Cork \email{g.provan@cs.ucc.ie}
}
\begin{document}
\maketitle
\begin{abstract}
  We study five different notions of finiteness in Cubical Type Theory and prove
  the relationship between them.
  In particular we show that any totally ordered Kuratowski finite type is
  manifestly Bishop finite.

  We also prove closure properties for each finite type, and classify them
  topos-theoretically.
  This includes a proof that the category of decidable Kuratowski finite sets
  (also called the category of cardinal finite sets) form a \(\Pi\)-pretopos.

  We then develop a parallel classification for the countably infinite types, as
  well as a proof of the countability of \(A^\star\) for a countable type \(A\).

  We formalise our work in Cubical Agda, where we implement a library for proof
  search (including combinators for level-polymorphic fully generic currying).
  Through this library we demonstrate a number of uses for the computational
  content of the univalence axiom, including searching for and synthesising
  functions.
  \keywords{Agda \and Homotopy Type Theory \and Cubical Type Theory \and
    Dependent Types \and Finiteness \and Topos \and Kuratowski finite}
\end{abstract}
\section{Introduction}
\subsection{Foreword}
In constructive mathematics we are often preoccupied with \emph{why} something
is true.
Take finiteness, for example.
There are a handful of ways to demonstrate some type is finite: we could provide
a surjection to it from another finite type; we could show that any collection
of its elements larger than some bound contains duplicates; or we could show
that any stream of its elements contain duplicates.

Classically, all of these proofs end up proving the same thing: that our type is
finite.
Constructively (in Martin-Löf Type Theory
\cite{martin-lofIntuitionisticTypeTheory1980} at least), however, all three
of the statements above construct a different version of finiteness.
\emph{How} we show that some type is finite has a significant impact on the
type of finiteness we end up dealing with.

Homotopy Type Theory \cite{hottbook} adds another wrinkle to the story.
Firstly, in HoTT we cannot assume that every type is a (homotopy) set: this
means that the finiteness predicates above can be further split into versions
which apply to sets only, and those that apply to all types.
Secondly, HoTT gives us a principled and powerful way to construct quotients,
allowing us to regain some of the flexibility of classical definitions by
``forgetting'' the parts of a proof we would be forced to remember in MLTT.

Finally, for a computer scientist constructive mathematics has one invaluable
feature missing from classical mathematics: computation.
Cubical Type Theory \cite{cohenCubicalTypeTheory2016}, and its implementation in
Cubical Agda \cite{vezzosiCubicalAgdaDependently2019}, realise this property
even in the presence of univalence, giving computational content to programs
written in HoTT.
\subsection{Contributions}
In this work we will examine five notions of finiteness in Cubical Type Theory,
the relationships between them, and their topos-theoretic characterisation.
We also briefly examine a predicate for countable sets, comparing it to the
finiteness predicates.
Our work is formalised in Cubical Agda, where we also develop a library for
proof search based on the finiteness predicates.

\input{figures/finite-classification}

The finiteness predicates we are interested in are organised in
figure~\ref{finite-classification}, and defined in
section~\ref{finiteness-predicates}.
We will explore two aspects of each predicate: its relation to the other
predicates, and its topos-theoretic classification.

When we say ``relation'' we are referring to the arrows in
figure~\ref{finite-classification}.
In section~\ref{relations} we will provide a function which inhabits each arrow.
Each unlabelled arrow is an unconditional implication: every manifest Bishop
finite set is cardinal finite (lemma~\ref{manifest-bishop-to-cardinal}), for
instance.
The labelled arrows are strengthening proofs: every manifest enumerable set
\emph{with decidable equality} is split enumerable
(lemma~\ref{manifest-enum-to-split-enum}).
Our most significant result here is the proof that a cardinal finite set with a
decidable total order is manifestly Bishop finite.

We will then examine the closure properties of each predicate in
section~\ref{topos}, culminating in a proof that decidable Kuratowski finite
sets form a \(\Pi\)-pretopos (theorem~\ref{finite-topos}).
Our proofs follow the structure of \cite[Chapters 9, 10]{hottbook} and
\cite{rijkeSetsHomotopyType2015}.

After the finite predicates, we will briefly look at the infinite countable
types, and classify them in a parallel way to the finite predicates
(section~\ref{infinite}).

All of our work is formalised in Cubical Agda
\cite{vezzosiCubicalAgdaDependently2019}.
We will make mention of the few occasions where the formalisation of some proof
is of interest, but the main place where we will discuss the code is in
section~\ref{search}, where we implement a library for proof search, based on
omniscience and exhaustibility.
While proof search based on finiteness is not new, implementing it here does
give us an opportunity to demonstrate some actual \emph{computation} in a
univalent setting.
Many of the finiteness predicates are built using univalence, so for the proof
search functionality to work at all we require computational content in the
univalence axiom.
Furthermore, the extensionality afforded to us by HoTT means that we can have
\(\Pi\) types in the domain of the search, making our library more powerful than
comparable libraries.
We will demonstrate some interesting uses for this feature in particular.
\subsection{Notation and Background}
\subsubsection{Notation}
We work in Cubical Type Theory \cite{cohenCubicalTypeTheory2016}.
For the various type formers we use the following notation:
\begin{description}
  \item[Type] We use \(\mathbf{Type}\) to denote the universe of (small) types.
    ``Type families'' are functions into \(\mathbf{Type}\).
  \item[Universes]
    To avoid Girard's paradox
    \cite{girardInterpretationFonctionelleElimination1972} we use explicit
    universe levels.
    A full explanation is beyond the scope of this work, but it means that there
    is a hierarchy of types starting with \(\mathbf{Type}\).
    \begin{equation}
      \begin{alignat}{3}
        & 2               &&: \mathbb{N} \\
        & \mathbb{N}      &&: \mathbf{Type} \\
        & \mathbf{Type}   &&: \mathbf{Type}_1 \\
        & \mathbf{Type}_1 &&: \mathbf{Type}_2
      \end{alignat}
    \end{equation}
    In our formalisation, every proof is done in the most universe polymorphic
    way possible: the proof that the cardinally finite sets form a
    \(\Pi\)-pretopos, for instance, is defined over any universe level.
  \item[0 , 1 , 2] We call the \(\mathbf{0}\), \(\mathbf{1}\), and
    \(\mathbf{2}\) types \(\bot\), \(\top\), and \(\mathbf{Bool}\) respectively.
    The single inhabitant of \(\top\) is tt, and the two inhabitants of
    \(\mathbf{Bool}\) are false and true.
    The ``negation'' of a type, written \(\neg A\), means \(A \rightarrow
    \bot\).
  \item[Dependent Sum and Product] We use \(\Sigma\) and \(\Pi\) for the
    dependent sum and product, respectively.
    The two projections from \(\Sigma\) are called fst and snd.
    In the non-dependent case, \(\Sigma\) can be written as \(\times\), and
    \(\Pi\) as \(\rightarrow\).
  \item[Disjoint Union] Disjoint union can be defined in terms of \(\Sigma\):
    \begin{equation}
      A \uplus B \coloneqq \Sigma(x : \mathbf{Bool}) , \text{if } x \text{ then } A \text{ else } B
    \end{equation}
    However, we prefer to use it as an inductively defined type (though the two
    are equivalent).
    \begin{equation}
      \begin{aligned}
        A \uplus B \coloneqq & \;
        \text{inl} &: A \rightarrow A \uplus B \\
        | & \;  \text{inr} &: B \rightarrow A \uplus B
      \end{aligned}
    \end{equation}
  \item[Equalities, equivalences, and paths] We use the symbol \(\coloneqq\)
    for definitions.
    \(\simeq\) will be used for equivalences, and \(\equiv\) for equalities.
    Of course, we know that \((A \simeq B) \simeq (A \equiv B)\) by univalence,
    so the distinction isn't terribly important in usage: we will only use one
    or the other as a suggestion of how we constructed it or how it is to be
    used.
\end{description}
\subsubsection{Cubical Type Theory}
Cubical Type Theory \cite{cohenCubicalTypeTheory2016} is a constructive type
theory with an implementation in Cubical Agda
\cite{vezzosiCubicalAgdaDependently2019}.
It allows us to do much of the same theory as in HoTT, but crucially the
univalence ``axiom'' is a \emph{theorem}, rather than an axiom.
This allows us to actually compute with univalent proofs, a capability missing
from HoTT.
\begin{romdefinition}[Path Types] \label{path-types}
  The equality type (which we denote with \(\equiv\)) in CuTT is the type of
  Paths\footnotemark.
  The internal structure of paths is largely irrelevant to us here, as we will
  generally treat \(\equiv\) as a black-box equivalence relation with
  substitution and congruence.
\end{romdefinition}

\footnotetext{
  Actually, CuTT does have an identity type with similar semantics to the
  identity type in MLTT.
  We do not use this type anywhere in our work, however, so we will not consider
  it here.
}
\begin{romdefinition}[Homotopy Levels] \label{homotopy-types}
  Types in HoTT and CuTT are not necessarily sets, as they are in MLTT.
  This means that equalities are not necessarily unique.
  In fact, we have an entire hierarchy of homotopy levels, starting with
  contractions, of which sets are level 2.
  \begin{alignat}{2}
    &\text{isContr}(A)    &&\coloneqq \Sigma(x : A) , \Pi(y : A) , (x \equiv y) \\
    &\text{isProp}(A)     &&\coloneqq \Pi(x, y : A) , (x \equiv y) \\
    &\text{isSet}(A)      &&\coloneqq \Pi(x, y : A) , \text{isProp}(x \equiv y) \\
    &\text{isGroupoid}(A) &&\coloneqq \Pi(x, y : A) , \text{isSet}(x \equiv y)
  \end{alignat}
  We can define the above types inductively like so:
  \begin{alignat}{2}
    &\text{isOfHLevel}(0 , A)   &&\coloneqq \text{isContr}(A) \\
    &\text{isOfHLevel}(n+1 , A) &&\coloneqq \Pi(x , y : A) , \text{isOfHLevel}(n , x \equiv y)
  \end{alignat}
  This type is defined similarly in \cite[definition 7.1.1]{hottbook}, although
  there the numbering starts at \(-2\).
\end{romdefinition}
\begin{romdefinition}[Fibres] \label{fibres}
  A fibre \cite[definition 4.2.4]{hottbook} is defined over some function \(f :
  A \rightarrow B\).
  \begin{equation}
    \text{fib}_f(y) = \Sigma(x : A) , (f (x) \equiv y)
  \end{equation}
\end{romdefinition}
\begin{romdefinition}[Equivalences] \label{equivalences}
  We will take contractible maps \cite[definition 4.4.1]{hottbook} as our
  ``default'' definition of equivalences.
  \begin{alignat}{2}
    &\text{isEquiv}(f) &&\coloneqq \Pi(y : B) , \text{isContr}(\text{fib}_f(y)) \label{is-equiv-def} \\
    &A \simeq B        &&\coloneqq \Sigma(f : A \rightarrow B) , \text{isEquiv}(f)
  \end{alignat}
\end{romdefinition}
\begin{romlemma}
  Univalence
  \begin{equation}
    (A \simeq B) \simeq (A \equiv B)
  \end{equation}
  This is the so-called univalence ``axiom'', which is a theorem in CuTT.
\end{romlemma}
\begin{romdefinition}[Decision]
  \begin{equation}
    \mathbf{Dec}(A) \coloneqq A \uplus \neg A
  \end{equation}
\end{romdefinition}
\begin{romdefinition}[Discrete]
  A discrete type is one with decidable equality.
  \begin{equation}
    \text{Discrete}(A) \coloneqq \Pi(x, y : A) , \mathbf{Dec}(x \equiv y)
  \end{equation}
  By Hedberg's theorem \cite{hedbergCoherenceTheoremMartinLof1998} any discrete
  type is a set.
\end{romdefinition}
\begin{romdefinition}[Higher Inductive Types] \label{HITs}
  Normal inductive types have \emph{point} constructors: constructors which
  construct values of the type.
  Higher Inductive Types (HITs) also have \emph{path} constructors: ways to
  construct paths in the type.
\end{romdefinition}
\begin{romdefinition}[Propositional Truncation] \label{prop-trunc}
  The type \(\lVert A \rVert\) on some type \(A\) is a propositionally truncated
  proof of \(A\) \cite[3.7]{hottbook}.
  In other words, it is a proof that some \(A\) exists, but it does not tell you
  \emph{which} \(A\).

  It is defined as a Higher Inductive Type:
  \begin{equation} {
    \begin{alignat*}{3}
      \lVert A \rVert \coloneqq & \; \lvert \wc \rvert &&: A \rightarrow \lVert A \rVert ; \\
                              | & \; \text{squash}     &&: \Pi {(x, y : \lVert A \rVert)} , x \equiv y  ; 
    \end{alignat*} }
  \end{equation}
  We will use three eliminators from \(\lVert A \rVert\) in this paper.
  \begin{enumerate}
  \item \label{elim-prop-prop} For any function \(A \rightarrow B\), where
    \(\text{isProp}(B)\), we have a function \(\lVert A \rVert \rightarrow B\).
  \item \label{elim-prop-monad} A special case of \ref{elim-prop-prop} implies
    that \(\lVert \cdot \rVert\) forms a monad: this means that we get the usual
    Monadic operators on \(\lVert \cdot \rVert\) (bind, pure, fmap, etc.).
    \item \label{elim-prop-coh} We can eliminate from \(\lVert A \rVert\) with a
      function \(f : A \rightarrow B\) iff \(f\) ``doesn't care'' about the
      choice of \(A\) (\(\Pi {(x , y : A)} , f(x) \equiv f(y) \)).
      Formally speaking, \(f\) needs to be ``coherently constant''
      \cite{krausGeneralUniversalProperty2015}, and \(B\) needs to be an
      \(n\)-type for some finite \(n\).
  \end{enumerate}
\end{romdefinition}
\section{Finiteness Predicates} \label{finiteness-predicates}
In this section, we will define and briefly describe each of the five predicates
in Figure~\ref{finite-classification}.
The reason we explore predicates other than our focus (cardinal finiteness) is
that we can often prove things like closure much more readily on the simpler
predicates.
The relations (which we will prove in the next section) then allow us to
transfer those proofs onto Kuratowski finiteness.
\subsection{Split Enumerability}
\begin{romdefinition}[Split Enumerable Set] \label{split-enum-def}
  \begin{equation} \label{split-enum-def-eqn}
    \mathcal{E}!(A) \coloneqq \Sigma {(\mathit{xs} : \textbf{List}(A))} , \Pi {(x : A)} , x \in \mathit{xs}
  \end{equation}
  We call the first component of this pair the ``support'' list, and the second
  component the ``cover'' proof.
  An equivalent version of this predicate was called \verb+Listable+ in
  \cite{firsovDependentlyTypedProgramming2015}.
\end{romdefinition}

We used some extra types in the above definition, which we will define here:
\begin{romdefinition}[Containers] \label{container-def}
  A container \cite{abbottContainersConstructingStrictly2005} is a pair
  \(S , P\) where \(S\) is a type, the elements of which are called
  the \emph{shapes} of the container, and \(P\) is a type family on \(S\), where
  the elements of \(P(s)\) are called the \emph{positions} of a container.
  We ``interpret'' a container into a functor defined like so:
  \begin{equation} \label{container-interp}
    \llbracket S , P \rrbracket(A) \coloneqq \Sigma {(s : S)} , \left( P(s) \rightarrow A \right)
  \end{equation}
  Membership of a container can be defined like so:
  \begin{equation} \label{container-membership}
    x \in \mathit{xs} \coloneqq \text{fib}_{\text{snd}(\mathit{xs})}(x)
  \end{equation}
\end{romdefinition}
\begin{romdefinition}[\(\mathbf{List}\)] \label{List}
  \begin{equation}
    \mathbf{List} \coloneqq \llbracket \mathbb{N} , \mathbf{Fin} \rrbracket
  \end{equation}
\end{romdefinition}
\begin{romdefinition}[\(\mathbf{Fin}\)] \label{Fin}
  \(\mathbf{Fin}(n)\) is the type of natural numbers smaller than \(n\). We
  define it the standard way, where \(\mathbf{Fin}(0) \coloneqq \bot\) and
  \(\mathbf{Fin}(n + 1) &\coloneqq \top \uplus \mathbf{Fin}(n)\).
\end{romdefinition}

We tend to prefer list-based definitions of finiteness, rather than ones based
on bijections or surjections.
This is purely a matter of perspective, however: the definition above is
precisely equivalent to a split surjection from a finite prefix of the natural
numbers.
\begin{romdefinition}[Surjections] \label{surjections}
  We define both surjections and \emph{split} surjections here \cite[definition
  4.6.1]{hottbook}.
  \begin{alignat}{3}
    &\text{surj}(f)             &&\coloneqq \Pi(y : B) , \lVert \text{fib}_f(y) \rVert \\
    &A \twoheadrightarrow B     &&\coloneqq \Sigma (f : A \rightarrow B) , \text{surj}(f) \label{surj-arrow-eqn} \\
    &\text{sp-surj}(f)          &&\coloneqq \Pi(y : B) , \text{fib}_f(y) \label{sp-surj-eqn} \\
    &A \twoheadrightarrow! \; B &&\coloneqq \Sigma (f : A \rightarrow B) , \text{sp-surj}(f) \label{sp-surj-arrow-eqn}
  \end{alignat}
\end{romdefinition}
\begin{romlemma} \label{split-enum-is-split-surj}
  \begin{equation}
    \mathcal{E}!(A) \simeq \Sigma (n : \mathbb{N}) , \left( \mathbf{Fin}(n) \twoheadrightarrow ! \; A \right)
  \end{equation}
\end{romlemma}
\begin{proof}
  \begin{align*}
    \mathcal{E}!(A)
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , x \in \mathit{xs}
    && \text{def.~\ref{split-enum-def} }(\mathcal{E}!)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \text{fib}_{\text{snd}(\mathit{xs})}(x)
    && \text{eqn.~\ref{container-membership} } (\in)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \text{sp-surj}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{sp-surj-eqn} (sp-surj)}
    \\
    & \simeq \Sigma (\mathit{xs} : \llbracket \mathbb{N} , \mathbf{Fin} \rrbracket (A)) , \text{sp-surj}(\text{snd}(\mathit{xs}))
    && \text{def.~\ref{List} } (\mathbf{List})
    \\
    & \simeq \Sigma (\mathit{xs} : \Sigma (n : \mathbb{N}) , \Pi (i : \mathbf{Fin}(n)) , A) , \text{sp-surj}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{container-interp} } (\llbracket \wc \rrbracket)
    \\
    & \simeq \Sigma (n : \mathbb{N}) , \Sigma (f : \mathbf{Fin}(n) \rightarrow A) , \text{sp-surj}(f)
    && \text{Reassociation of } \Sigma
    \\
    & \simeq \Sigma (n : \mathbb{N}) , ( \mathbf{Fin}(n) \twoheadrightarrow ! \; A )
    && \text{eqn.~\ref{sp-surj-arrow-eqn} } (\twoheadrightarrow!)
  \end{align*}
  \qed
\end{proof}

In our formalisation, the proof is a single line: most of the steps above are
simple expansion of definitions.
The only step which isn't definitional equality is the reassociation of
\(\Sigma\).

Split enumerability implies decidable equality on the underlying type.
To prove this, we will make use of the following lemma, proven in the
formalisation:
\begin{romlemma} \label{discrete-surj}
  \begin{equation}
    \frac{
        A \twoheadrightarrow! \; B \; \; \; \text{Discrete}(A)
      }{
       \text{Discrete}(B) 
      }
  \end{equation}
\end{romlemma}
\begin{romlemma} \label{split-enum-discrete}
  Every split enumerable type is discrete.
\end{romlemma}
\begin{proof}
  Let \(A\) be a split enumerable type.
  By lemma~\ref{split-enum-is-split-surj}, there is a surjection from
  \(\mathbf{Fin}(n)\) for some \(n\).
  Also, we know that \(\mathbf{Fin}(n)\) is discrete (proven in our
  formalisation).
  Therefore, by lemma~\ref{discrete-surj}, \(A\) is discrete.
  \qed
\end{proof}
\subsection{Manifest Bishop Finiteness}
\begin{romdefinition}[Manifest Bishop Finiteness]
  \begin{equation} \label{bish-def}
    \mathcal{B}(A) \coloneqq \Sigma {(\mathit{xs} : \textbf{List}(A))} , \Pi {(x : A)} , x \inunique xs
  \end{equation}
\end{romdefinition}
The only difference between manifest Bishop finiteness and split enumerability
is the membership term: here we require unique membership (\(\inunique\)),
rather than simple membership (\(\in\)).
\begin{romdefinition}[Unique Membership] \label{uniq-memb-def}
  \begin{equation}
    x \inunique \mathit{xs} \coloneqq \text{isContr}(x \in \mathit{xs})
  \end{equation}
\end{romdefinition}

We use the word ``manifest'' here to distinguish from another common
interpretation of Bishop finiteness, which we have called Cardinal finiteness in
this paper.
The ``manifest'' refers to the fact that we have a concrete, non-truncated list
of the elements in the proof.

Where split enumerability was the enumeration form of a split surjection from
\(\mathbf{Fin}\), manifest Bishop finiteness is the enumeration form of an
\emph{equivalence} with \(\mathbf{Fin}\).
\begin{romlemma} \label{bishop-equiv}
  \begin{equation}
    \mathcal{B}(A) \simeq \Sigma {(n : \mathbb{N})} , \left( \mathbf{Fin}(n) \simeq A \right)
  \end{equation}
\end{romlemma}
\begin{proof}
  \begin{align*}
    \mathcal{B}(A)
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , x \inunique \mathit{xs}
    && \text{def.~\ref{bish-def} } (\mathcal{B})
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \text{isContr} \left(\text{fib}_{\text{snd}(\mathit{xs})}(x)\right)
    && \text{def.~\ref{uniq-memb-def} } (\inunique)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \text{isEquiv}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{is-equiv-def} (isEquiv)}
    \\
    & \simeq \Sigma (\mathit{xs} : \llbracket \mathbb{N} , \mathbf{Fin} \rrbracket (A)) , \text{isEquiv}(\text{snd}(\mathit{xs}))
    && \text{def.~\ref{List} } (\mathbf{List})
    \\
    & \simeq \Sigma (\mathit{xs} : \Sigma (n : \mathbb{N}) , \Pi (i : \mathbf{Fin}(n)) , A) , \text{isEquiv}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{container-interp} } (\llbracket \wc \rrbracket)
    \\
    & \simeq \Sigma (n : \mathbb{N}) , \Sigma (f : \mathbf{Fin}(n) \rightarrow A) , \text{isEquiv}(f)
    && \text{Reassociation of } \Sigma
    \\
    & \simeq \Sigma (n : \mathbb{N}) , ( \mathbf{Fin}(n) \simeq \; A )
    && \text{eqn.~\ref{surj-arrow-eqn} } (\twoheadrightarrow)
  \end{align*}
  \qed
\end{proof}
\subsection{Cardinal Finiteness}
Each finiteness predicate so far has contained an \emph{ordering} of the
underlying type.
For our purposes, this is too much information: it means that when constructing
the ``category of finite sets'' later on, instead of each type having one
canonical representative, it will have \(n!\), where \(n\) is the cardinality of
the type\footnotemark.

\footnotetext{
  We actually do get a category (a groupoid, even) from manifest Bishop
  finiteness \cite{yorgeyCombinatorialSpeciesLabelled2014}: it's the groupoid of
  finite sets equipped with a linear order, whose morphisms are order-preserving
  bijections.
  We do not explore this particular construction in any detail.
}

To remedy the problem, we will use propositional truncation
(def.~\ref{prop-trunc}).
\begin{romdefinition}[Cardinal Finiteness]
  \begin{equation}
    \mathcal{C}(A) \coloneqq \lVert \mathcal{B}(A) \rVert \simeq \lVert \Sigma(n : \mathbb{N}) , (\mathbf{Fin}(n) \simeq A) \rVert
  \end{equation}
\end{romdefinition}
At first glance, it might seem that we lose any useful properties we could
derive from \(\mathcal{B}\).
Luckily, this is not the case: by eliminator \ref{elim-prop-coh} of
def.~\ref{prop-trunc}, we need only show that the output is uniquely determined.

The following two lemmas are proven in
\cite{yorgeyCombinatorialSpeciesLabelled2014} (Proposition 2.4.9 and 2.4.10,
respectively), in much the same way as we have done here.
Our contribution for this section is simply the formalisation.
\begin{romlemma}
  Given a cardinally finite type, we can derive the type's cardinality, as well
  as a propositionally truncated proof of equivalence with \(\textbf{Fin}\)s of
  the same cardinality.
  \begin{equation}
    \mathcal{C}(A) \rightarrow \Sigma {(n : \mathbb{N})} , \lVert \textbf{Fin}(n) \simeq A \rVert
  \end{equation}
\end{romlemma}
\begin{romlemma} \label{cardinal-finite-discrete}
  Any cardinal-finite set has decidable equality.
\end{romlemma}
\subsection{Manifest Enumerability}
\begin{romdefinition}[Manifest Enumerability]
  \begin{equation}
    \mathcal{E}(A) \coloneqq \Sigma {(\mathit{xs} : \mathbf{List}(A))} , \Pi {(x : A)} , \lVert x \in \mathit{xs} \rVert
  \end{equation}
\end{romdefinition}
As with manifest Bishop finiteness, the only difference with this type and split
enumerability is the membership proof: here we have propositionally truncated
it.
This has two effects.
First, it means that this proof represents a true surjection (rather than a
split surjection) from \(\mathbf{Fin}\).
\begin{romlemma}
  \begin{equation}
    \mathcal{E}(A) \simeq \Sigma(n : \mathbb{N}) , (\mathbf{Fin}(n) \twoheadrightarrow A)
  \end{equation}
\end{romlemma}

Secondly, it means the predicate does not imply decidable equality.
More significantly, it allows the predicate to be defined over non-set types,
like the circle.
\begin{romdefinition}[\(S^1\)] \label{circle-def}
  The circle, \(S^1\), can be represented in HoTT as a higher inductive type.
  \begin{equation}
    \begin{alignat}{5}
      S^1 \coloneqq & \; \text{base} &&: S^1 ; \\
      | & \; \text{loop} &&: \text{base} \equiv \text{base} ; 
    \end{alignat}
  \end{equation}
  We will use it here as an example of a non-set type, i.e. a type for which not
  all paths are equal.
  This also means that it does not have decidable equality.
\end{romdefinition}
\begin{romlemma}
  The circle \(S^1\) is manifestly enumerable.
\end{romlemma}
\subsection{Kuratowski Finiteness}
Much work has already been done on Kuratowski finiteness in HoTT in
\cite{fruminFiniteSetsHomotopy2018}.
As a result, we will not needlessly repeat proofs, rather we will just give a
brief introduction to the topic and point out where our treatment differs.

The first thing we must define is a representation of subsets.
\begin{romdefinition}[Kuratowski Finite Subset]
  \(\mathcal{K}(A)\) is the type of Kuratowski-finite subsets of \(A\).
  \begin{equation}
    \begin{alignat}{2}
      \mathcal{K}(A) \coloneqq&
             \; []                &&: \mathcal{K}(A) ; \\
      \vert& \; \wc \dblcolon \wc &&: A \rightarrow \mathcal{K}(A) \rightarrow \mathcal{K}(A) ; \\
      \vert& \; \text{com}        &&: \Pi (x, y: A) , \Pi (\mathit{xs} : \mathcal{K}(A)) , x \dblcolon y \dblcolon \mathit{xs} \equiv y \dblcolon x \dblcolon \mathit{xs} ; \\
      \vert& \; \text{dup}        &&: \Pi (x : A) , \Pi (\mathit{xs} : \mathcal{K}(A)) , x \dblcolon x \dblcolon \mathit{xs} \equiv x \dblcolon \mathit{xs} ; \\
      \vert& \; \text{trunc}      &&: \Pi (\mathit{xs}, \mathit{ys}: \mathcal{K}(A)) , \Pi (p, q : \mathit{xs} \equiv \mathit{ys}) , p \equiv q ;
    \end{alignat}
  \end{equation}
  We define it as a HIT (definition~\ref{HITs}).
  The first two constructors are point constructors, giving ways to create
  values of type \(\mathcal{K}(A)\).
  They are also recognisable as the two constructors for finite lists, a type
  which represents the free monoid.

  The next two constructors add extra paths to the type: equations that usage of
  the type must obey.
  These extra paths turn the free monoid into the free \emph{commutative} (com)
  \emph{idempotent} (dup) monoid.

  The final constructor enforces that the type \(\mathcal{K}(A)\) must be a set.
\end{romdefinition}
The Kuratowski finite subset is a free join semilattice (or, equivalently, a
free commutative idempotent monoid).
More prosaically, \(\mathcal{K}\) is the abstract data type for finite sets, as
defined in the Boom hierarchy \cite{boomFurtherThoughtsAbstracto1981,
  bunkenburgBoomHierarchy1994}.
However, rather than just being a specification, \(\mathcal{K}\) is fully usable
as a data type in its own right, thanks to HITs.

Other definitions of \(\mathcal{K}\) exist (such as the one in
\cite{fruminFiniteSetsHomotopy2018}) which make the fact that \(\mathcal{K}\) is
the free join semilattice more obvious.
We have included such a definition in our formalisation, and proven it
equivalent to the one above.

Next, we need a way to say that an entire type is Kuratowski finite.
For that, we will need to define membership of \(\mathcal{K}\).
\begin{romdefinition}[Membership of \(\mathcal{K}\)]
  Membership is defined by pattern-matching on \(\mathcal{K}\).
  The two point constructors are handled like so:
  \begin{equation}
    \begin{alignedat}{2}
      x \in&& \; []                      &\coloneqq \bot \\
      x \in&& \; y \dblcolon \mathit{ys} &\coloneqq \lVert x \equiv y \uplus x \in \mathit{ys} \rVert
    \end{alignedat}
  \end{equation}
  The \(\text{com}\) and \(\text{dup}\) constructors are handled by proving that
  the truncated form of \(\uplus\) is itself commutative and idempotent.
  The type of propositions is itself a set, satisfying the \(\text{trunc}\)
  constructor.
\end{romdefinition}
Finally, we have enough background to define Kuratowski finiteness.
\begin{romdefinition}[Kuratowski Finiteness]
  \begin{equation}
    \mathcal{K}^{f}(A) = \Sigma {(\mathit{xs} : \mathcal{K}(A))} , \Pi (x : A) , x \in \mathit{xs}
  \end{equation}
\end{romdefinition}

We also have the following two lemmas, proven in both
\cite{fruminFiniteSetsHomotopy2018} and our formalisation.
\begin{romlemma}
  \(\mathcal{K}^f\) is a mere proposition.
\end{romlemma}
\begin{romlemma}
  This circle \(S^1\) is Kuratowski finite.
\end{romlemma}
The second of these in particular tells us that the ``Kuratowski-finite types''
are not necessarily sets; it also tells us that we cannot derive decidable
equality from a proof of Kuratowski finiteness.
\section{Relations Between Each Finiteness Definition} \label{relations}
We will now look at the arrows in figure~\ref{finite-classification}.
\subsection{Split Enumerability and Manifest Bishop Finiteness}
While manifest Bishop finiteness might seem stronger than split enumerability,
it turns out this is not the case.
Both types imply the other.
\begin{romlemma} \label{manifest-bishop-to-split-enum}
  Any manifest Bishop finite type is split enumerable.
\end{romlemma}
\begin{proof}
  To construct a proof of split enumerability from one of manifest Bishop
  finiteness, it suffices to convert a proof of \(x \inunique \mathit{xs}\) to
  one of \(x \in \mathit{xs}\), for all \(x\) and \(\mathit{xs}\).
  Since \(\inunique\) is defined as a contraction of \(\in\), such a conversion
  is simply the \(\text{fst}\) function.
  \qed
\end{proof}

To derive \(\mathcal{B}\) from \(\mathcal{E}!\) takes significantly more work.
The ``unique membership'' condition in \(\mathcal{B}\) means that we are not
permitted duplicates in the support list.
The first step in the proof, then, is to filter those duplicates out from the
support list of the \(\mathcal{E}!\) proof: we can do this using the decidable
equality provided by \(\mathcal{E}!\) (lemma~\ref{split-enum-discrete}).
From there, all we need to show is that the membership proof carries over
appropriately.
\begin{romlemma} \label{split-enum-to-manifest-bishop}
  Any split enumerable set is manifest Bishop finite.
\end{romlemma}
\subsection{Split Enumerability and Manifest Enumerability}
\begin{romlemma} \label{split-enum-to-manifest-enum}
  Any split enumerable type is manifestly enumerable.
\end{romlemma}
\begin{romlemma} \label{dec-trunc-refute}
  For any type \(A\), we can extract a value of type \(A\) from a decision over
  \(A\) in combination with a propositionally-truncated value of type \(\lVert A \rVert\).
  \begin{equation}
    \frac{
      \mathbf{Dec}(A) \; \; \; \lVert A \rVert
    }{
      A
    }
  \end{equation}
\end{romlemma}
\begin{proof}
  Let \(d\) be a value of type \(\mathbf{Dec}(A)\), and \(p\) be a value of type
  \(\lVert A \rVert\).
  We proceed by case analysis on \(d\).
  In the case where \(d\) is inl, we have a value of type \(A\), and our goal is
  satisfied.
  In the case of inr, we have a value of type \(\neg A\).
  Using eliminator \ref{elim-prop-prop} from definition~\ref{prop-trunc}, and
  the fact that \(\bot\) is a proposition, we can run the \(\neg A\) proof on
  \(p\), getting a contradiction.
  \qed
\end{proof}
\begin{romlemma} \label{manifest-enum-to-split-enum}
  A manifestly enumerable type with decidable equality is split enumerable.
\end{romlemma}
\begin{proof}
  Similarly to the proof of lemma~\ref{manifest-bishop-to-split-enum}, our
  obligation for this proof is to provide a conversion function between
  membership proofs.
  In this case, we need to show:
  \begin{equation}
    \Pi(x : A) , \Pi(\mathit{xs} : \mathbf{List}(A)) , \lVert x \in \mathit{xs} \rVert \rightarrow x \in \mathit{xs}
  \end{equation}
  This conversion function can be constructed from the two following functions,
  provided in the formalisation.
  First, for any type with decidable equality, decidable membership in a finite
  list is consequently decidable:
  \begin{equation}
    \text{Discrete}(A) \rightarrow \Pi(x : A) , \Pi(\mathit{xs} : \mathbf{List}(A)) , \mathbf{Dec}(x \in \mathit{xs})
  \end{equation}
  Then, we use lemma~\ref{dec-trunc-refute}, allowing us to derive \(x \in
  \mathit{xs}\) from \(\lVert x \in \mathit{xs} \rVert\).
  \qed
\end{proof}
\subsection{Manifest Bishop Finiteness and Cardinal Finiteness}
\begin{romlemma} \label{manifest-bishop-to-cardinal}
  Any manifest Bishop finite type is cardinal finite.
\end{romlemma}
\begin{romtheorem} \label{cardinal-to-manifest-bishop}
  Any cardinal finite type with a total order is Bishop finite.
\end{romtheorem}
The proof for this particular theorem is quite involved in the formalisation, so
we only give its sketch here.
First, note that we actually convert to manifest enumerability first: this can
be converted to split enumerability with decidable equality, which is provided
by cardinal finiteness.

Next, we define permutations.
\begin{romdefinition}[List Permutations]
  Two lists are permutations of each other if their membership proofs are all
  equivalent\footnotemark \cite{danielssonBagEquivalenceProofRelevant2012}.
  \begin{equation}
    \mathit{xs} \leftrightsquigarrow \mathit{ys} = \Pi {(x : A)} , x \in \mathit{xs} \simeq x \in \mathit{ys}
  \end{equation}
\end{romdefinition}

\footnotetext{
  The definition in \cite{danielssonBagEquivalenceProofRelevant2012} and our
  formalisation is slightly different: we say permutations are lists with
  \emph{isomorphic} membership proofs.
  The distinction, as it happens, does not affect our work here.
}

Next, we define a sort function which relies on the provided total order.
We further prove the following fact about this sort function:
\begin{equation}
  \Pi(\mathit{xs}, \mathit{ys} : \mathbf{List}(A)) , \mathit{xs} \leftrightsquigarrow \mathit{ys} \rightarrow \text{sort}(\mathit{xs}) \equiv \text{sort}(\mathit{ys})
\end{equation}

Next, notice that the support lists of any two proofs of manifest Bishop
finiteness must be permutations of each other.
This will allow us to sort the support list of a proof of cardinal finiteness in
a coherently constant (definition~\ref{prop-trunc},
eliminator~\ref{elim-prop-coh}) way, pulling the support list out from the
truncation.
The cover proof emerges naturally from the definition of the permutation.
\subsection{Cardinal Finiteness and Kuratowski Finiteness}
\begin{romlemma} \label{cardinal-kuratowski}
  \begin{equation}
    \mathcal{C}(A) \simeq \mathcal{K}(A) \times \text{Discrete}(A)
  \end{equation}
\end{romlemma}
This proof is constructed by providing a pair of functions: one from
\(\mathcal{C}(A)\) to \(\mathcal{K}(A) \times \text{Discrete}(A)\), and one the
other way.
This pair implies an equivalence, because both source and target are
propositions.
The actual functions themselves are proven in our formalisation, as well as in
\cite{fruminFiniteSetsHomotopy2018}.
\section{Topos} \label{topos}
In this section we will prove that decidable Kuratowski finite types form a
\(\Pi\)-pretopos.
Along the way we will provide closure proofs for a number of the other
finiteness predicates.
As we saw in theorem~\ref{cardinal-kuratowski}, decidable Kuratowski finite
types are equivalent to cardinal finite types, so we will work with the latter
from now on.
Our first task is to show that cardinal finite types are closed under several
operations.
\subsection{Closure}
For the first two closure proofs, we only consider manifest Bishop finiteness:
as it is the strongest of the finiteness predicates, we can derive the other
closure proofs from it.
\begin{romlemma}
  \(\bot\), \(\top\), and \(\mathbf{Bool}\) are manifest Bishop finite.
\end{romlemma}
\begin{romlemma}
  Split enumerability is closed under \(\Sigma\)
\end{romlemma}
To show closure under \(\Sigma\), we take the Cartesian product of the support
lists.

\begin{romlemma}
  Manifest bishop finiteness is closed over dependent functions
  (\(\prod\)-types).
  \begin{equation}
    \frac{
      \mathcal{B}(A) \; \; \; \Pi {(x : A)} , \mathcal{B}\left( U(x) \right)
    }{
      \mathcal{B}\left(\Pi {(x : A)} , U(x)\right)
    }
  \end{equation}
\end{romlemma}
\begin{proof}
  Firstly, we will simplify things slightly by working only with split
  enumerability.
  As this is equal in strength to manifest Bishop finiteness, any closure proofs
  carry over.
  Secondly, we will replace \(A\) in all places with \(\mathbf{Fin}(n)\), using
  the equivalence provided by lemma~\ref{bishop-equiv}.

  The remainder of the proof now is concerned with proving the following:
  \begin{equation} \label{given-transp-sublemma}
    \left( \Pi {(x : \mathbf{Fin}(n))} , \mathcal{E}!(U(x)) \right) \rightarrow \mathcal{E}!\left( \Pi {(x : \mathbf{Fin}(n))} , U(x) \right)
  \end{equation}

  To prove this goal, consider the following type of \(n\)-tuples.
  \begin{equation}
    \begin{alignat}{3}
      & \mathbf{Tuple}(T, 0)   &&\coloneqq \top \\
      & \mathbf{Tuple}(T, n+1) &&\coloneqq T(0) \times \mathbf{Tuple}(T \circ \text{suc}, n)
    \end{alignat}
  \end{equation}
  We have the following equivalence, proven in our formalisation.
  \begin{equation} \label{fin-equiv-sublemma}
    \mathbf{Tuple}(T, n) \simeq \Pi {(x : \mathbf{Fin}(n))} , T(x)
  \end{equation}

  By the given proof of finiteness in equation~\ref{given-transp-sublemma}, we
  know that \(\mathbf{Tuple}(T , n)\) is split enumerable, since it is made of
  products of the points of \(U\).
  We can then transport along the equivalence in
  equation~\ref{fin-equiv-sublemma}, proving our goal.
\end{proof}

The dependent cases of each of these proofs do not transfer simply to proofs on
\(\mathcal{C}\).
In order to transfer them over, we need to prove a variant of the axiom of
choice on finite sets.
\begin{romlemma}
  \begin{equation}
    \mathcal{C}(A) \rightarrow (\Pi(x : A) , \lVert U(x) \rVert) \rightarrow \lVert \Pi(x : A) , U(x) \rVert
  \end{equation}
\end{romlemma}
This is proven in our formalisation.
\subsection{The Category of Finite Sets}
HoTT and CuTT seem to be especially suitable settings for formalisations of
category theory.
The univalence axiom in particular allows us to treat categorical isomorphisms
as equalities, saving us from the dreaded ``setoid hell''.

We follow \cite[chapter 9]{hottbook} in its treatment of
categories in HoTT, and in its proof that sets do indeed form a category.
We will first briefly go through the construction of the category
\(\mathit{Set}\), as it differs slightly from the usual method in type theory.

First, the type of objects and arrows:
\begin{alignat}{3}
  &\text{Obj}_\mathit{Set}      &&\coloneqq \Sigma(x : \mathbf{Type}) , \text{isProp}(x) \\
  &\text{Hom}_\mathit{Set}(x , y) &&\coloneqq  \text{fst}(x) \rightarrow \text{fst}(y)
\end{alignat}
As the type of objects makes clear, we have already departed slightly from the
simpler \(\text{Obj}_\mathit{Set} \coloneqq \mathbf{Type}\) way of doing things:
of course we have to, as HoTT allows non-set types.
Furthermore, after proving the usual associativity and identity laws for
composition (which are definitionally true in this case), we must further show
\(\text{isSet}(\text{Hom}_\mathit{Set}(x,y))\); even then we only have a
precategory.

To show that \(\mathit{Set}\) is a category, we must show that categorical
isomorphisms are equivalent to equivalences.
In a sense, we must give a univalence rule for the category we are working in.

We have provided formal proofs that \(\mathit{Set}\) does indeed form a
category, and the following:
\begin{romtheorem}[The Category of Finite Sets]
  Finite sets form a category in HoTT when defined like so:
  \begin{equation}
    \begin{aligned}
      &\text{Obj}_\mathit{FinSet}      &&\coloneqq \Sigma(x : \mathbf{Type}) , \mathcal{C}(x) \\
      &\text{Hom}_\mathit{FinSet}(x , y) &&\coloneqq  \text{fst}(x) \rightarrow \text{fst}(y)
    \end{aligned}
  \end{equation}
\end{romtheorem}
\subsection{The \(\Pi\)-pretopos of Finite Sets}
For this proof, we follow again the proof that \(\mathit{Set}\) forms a \(\Pi
W\)-pretopos from \cite[chapter 10]{hottbook} and
\cite{rijkeSetsHomotopyType2015}.
The difference here is that clearly we do not have access to \(W\)-types, as
they would permit infinitary structures.

We first must show that \(\mathit{Set}\) has an initial object and finite,
disjoint sums, which are stable under pullback.
We also must show that \(\mathit{Set}\) is a regular category with effective
quotients.
We now have a pretopos: the presence of \(\Pi\) types make it a
\(\Pi\)-pretopos.

We have proven the above statements for both \(\mathit{Set}\) and
\(\mathit{FinSet}\).
As far as we know, this is the first formalisation of either.
\begin{romtheorem} \label{finite-topos}
  The category of finite sets, \(\mathit{FinSet}\), forms a \(\Pi\)-topos.
\end{romtheorem}
\section{Countably Infinite Types} \label{infinite}
In the previous sections we saw different flavours of finiteness which were
really just different flavours of relations to \(\mathbf{Fin}\).
In this section we will see that we can construct a similar classification of
relations to \(\mathbb{N}\), in the form of the countably infinite types.
\subsection{Two Countable Types}
The two types for countability we will consider are analogous to split
enumerability and cardinal finiteness.
The change will be a simple one: in terms of surjections and bijections, we will
swap out \(\mathbf{Fin}\) for \(\mathbb{N}\).
In terms of support lists and cover proofs, we will swap out lists for streams.
A stream can be defined many ways in type theory: we take rather a low-tech
approach here, saying that a stream is a function from the natural numbers.
\begin{romdefinition}[Stream]
  \begin{equation}
    \mathbf{Stream}(A) \coloneqq \mathbb{N} \rightarrow A
  \end{equation}
  Streams are also definable as containers:
  \begin{equation}
    \mathbf{Stream}(A) \simeq \llbracket \top , \text{const}(\mathbb{N}) \rrbracket
  \end{equation}
  However the two definitions are clearly equivalent, and furthermore it is
  simpler to work with the first.
\end{romdefinition}

From this, we can define ``split countability''.
\begin{romdefinition}[Split Countability]
  \begin{equation}
    \mathcal{E}!(A) \coloneqq \Sigma {(\mathit{xs} : \mathbf{Stream}(A))} , \Pi {(x : A)} , x \in \mathit{xs}
  \end{equation}
\end{romdefinition}
This type is definitionally equal to it surjection equivalent (\(\mathbb{N}
\twoheadrightarrow ! \; A\)).
We construct the unordered, propositional version of the predicate in much the
same way as we constructed cardinal finiteness.
\begin{romdefinition}[Countability]
  \begin{equation}
    \mathcal{E}(A) \coloneqq \lVert \mathcal{E}!(A) \rVert
  \end{equation}
\end{romdefinition}

From both of these types we can derive decidable equality.
\begin{romlemma}
  Any countable type has decidable equality.
\end{romlemma}
\subsection{Closure}
We know that countable infinity is not closed under the exponential (function
arrow), so the only closure we need to prove is \(\Sigma\) to cover all of
what's left.
\begin{romtheorem} \label{split-countability-sigma}
  Split countability is closed under \(\Sigma\).
\end{romtheorem}
This proof does not mirror the proof of \(\Sigma\) closure on finite types,
surprisingly.
A different pattern is needed to pair up the members of each support stream: a
\emph{Cantor} pairing pattern.
Using the simple finite pairing function would diverge, not properly exploring
one of the two lists.
Instead, our function works in two stages.
First, it builds a stream of non-empty lists.
From two support streams \(\mathit{xs}\) and \(\mathit{ys}\), this intermediate
stream \(\mathcal{CV}\) is defined like so:
\begin{equation}
  \mathcal{CV}_i \coloneqq \left[ (\mathit{xs}_j , \mathit{ys}_k) \mid j, k \in \mathbb{N}; j + k = i \right]
\end{equation}
This is then concatenated to give our result.

Finally, while we have lost certain closure proofs by allowing for infinite
types, we also \emph{gain} some: in particular the Kleene star.
\begin{romtheorem}
  Split countability is closed under Kleene star.
  \begin{equation}
    \mathcal{E}!(A) \rightarrow \mathcal{E}!(\mathbf{List}(A))
  \end{equation}
\end{romtheorem}
Again, this proof requires a particular pattern to ensure non divergence.
The pattern here is slightly more complicated, but works on the same basic idea,
building an intermediate stream \(\mathcal{KV}\) of non-empty lists from the
input support stream \(\mathit{xs}\).
\begin{equation}
  \mathcal{KV}_i \coloneqq \left[ \left[ \mathit{xs}_{j - 1} \mid j \in \mathit{js} \right] \mid \mathit{js} \in \mathbf{List}(\mathbb{N}) ; \text{sum}(\mathit{js}) = i ; 0 \notin \mathit{js}  \right]
\end{equation}
Again, this is subsequently flattened.
\section{Search} \label{search}
\subsection{Omniscience}
In this section we are interested in restricted forms of the limited principle
of omniscience \cite{myhillErrettBishopFoundations1972}.
\begin{romdefinition}[Limited Principle of Omniscience]
  For any type \(A\) and predicate \(P\) on \(A\), the limited principle of
  omniscience is as follows:
  \begin{equation}
    \left( \Pi {(x : A)} , \mathbf{Dec}(P(x)) \right) \rightarrow \mathbf{Dec} \left( \Sigma {(x : A)} , P(x) \right)
  \end{equation}
  In other words, for any decidable predicate the existential quantification of
  that predicate is also decidable.
\end{romdefinition}
The limited principle of omniscience is non-constructive, but individual types
can themselves satisfy omniscience.
In particular, \emph{finite} types are omniscient.

There is also a universal form of omniscience, which we call exhaustibility.
\begin{romdefinition}[Exhaustibility]
  We say a type \(A\) is exhaustible if, for any decidable predicate \(P\) on
  \(A\), the universal quantification of the predicate is decidable.
  \begin{equation}
    \left( \Pi {(x : A)} , \mathbf{Dec}(P(x)) \right) \rightarrow \mathbf{Dec} \left( \Pi {(x : A)} , P(x) \right)
  \end{equation}
\end{romdefinition}

All of the finiteness predicates we have seen justify exhaustibility.
We will only prove it once, then, for the weakest:
\begin{romtheorem}
  Kuratowski-finite types are exhaustible.
\end{romtheorem}
Omniscience is stronger than exhaustibility, as we can derive the latter from
the former:
\begin{romlemma} \label{omniscient-is-exhaustible}
  Any omniscient type is exhaustible.
\end{romlemma}
All of the ordered finiteness predicates imply omniscience.
We will again only prove it for the weakest.
\begin{romtheorem}
  Manifest enumerable types are omniscient.
\end{romtheorem}
Finally, we do have a form of omniscience for prop-valued predicates, as they do
not care about the chosen representative.
\begin{romtheorem}
  Kuratowski finite types are omniscient about prop-valued predicates.
\end{romtheorem}
\subsection{Synthesising Pattern-Matching Proofs}
In particular, they can automate large proofs by analysing every possible case.
In \cite{firsovDependentlyTypedProgramming2015}, the \(\AgdaDatatype{Pauli}\)
group is used as an example.
\ExecuteMetaData[agda/Data/Pauli.tex]{def}
As \(\AgdaDatatype{Pauli}\) has 4 constructors, \(n\)-ary functions on
\(\AgdaDatatype{Pauli}\) may require up to \(4^n\) cases, making even simple
proofs prohibitively verbose.

The alternative is to derive the things we need from \(\mathcal{E}!\).
From here we can already derive decidable equality, a function which requires 16
cases if implemented manually.

For proof search, the procedure is a well-known one in Agda
\cite{devrieseBrightSideType2011}: we ask for the result of a decision procedure
as an \emph{instance argument}, which will demand computation during
typechecking.
\subsection{Multiple Arguments}
The automation machinery above only deals with single-argument predicates.
This is not a problem, as we know that we can work with multiple arguments by
currying and uncurrying, since all of the finiteness predicates are closed under
\(\times\).
To automate away the curry/uncurry noise we will use instance search, building
on \cite{allaisGenericLevelPolymorphic2019} to develop a small interface to
generic \(n\)-ary functions and properties.
Our generic representation can handle dependent \(\Sigma\) and \(\prod\)
types (rather than their non-dependent counterparts, \(\times\) and
\(\rightarrow\)).
This extension was necessary for our use case: it is mentioned in the paper
as the obvious next step. 
We also implement the curry-uncurry combinators as (verified) isomorphisms.

A full explanation of our implementation is beyond the scope of this work, so we
only present the finished interface, which is used like so:
\ExecuteMetaData[agda/Data/Pauli.tex]{assoc-prf}
\subsection{Synthesising Functions}
Finally, thanks to extensionality provided to us by HoTT, and the computation
properties provided by CuTT, we can derive decidable equality on functions over
finite types.
We can also use functions in our proof search.
Here, for instance, is a automated procedure which finds the
\(\AgdaFunction{not}\) function on \(\mathbf{Bool}\), given a specification.
\ExecuteMetaData[agda/Data/Pauli.tex]{not-spec}
\section{Related Work}
The univalent foundations program is the main basis for this work
\cite{hottbook}.
In particular, our formalisation in section~\ref{topos} relied heavily on
\cite[chapter 10]{hottbook}, and \cite{rijkeSetsHomotopyType2015}, a paper which
contains much of the same material.

In \cite{fruminFiniteSetsHomotopy2018} the topic of Kuratowski finite sets in
HoTT is studied extensively: we have focused more on the non-truncated versions
of finiteness (the ``manifest'' predicates), and we have provided the missing
\(\Pi\)-pretopos proof of decidable Kuratowski finite sets.

\cite{iversenUnivalentCategoriesFormalization2018} provided a starting point for
our categorical formalisation: it contains a proof, for instance, that homotopy
sets form a category.

Finite sets in a constructive setting has been studied extensively before:
In \cite{coquandConstructivelyFinite2010} four separate predicates for
finiteness were considered (split-enumerable being the only one explored in this
work), and \cite{firsovVariationsNoetherianness2016} explores Noetherianness.
\cite{firsovDependentlyTypedProgramming2015} explored what we have called split
enumerability and manifest Bishop finiteness (although they are stated slightly
differently), and they use these to build a library for proof search.

Our formalisation is made possible by Cubical Type Theory
\cite{cohenCubicalTypeTheory2016} and Cubical Agda
\cite{vezzosiCubicalAgdaDependently2019}.
\section*{Acknowledgement}
This work has been supported by the Science Foundation Ireland under the
following grant: 13/RC/2D94 to Irish Software Research Centre.
\bibliographystyle{splncs04}
\bibliography{bibliography.bib}
\end{document} 