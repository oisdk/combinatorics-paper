\input{preamble}
\title{Finiteness, Cardinality, and Combinatorics in Homotopy Type Theory}
\author{Donnacha Oisín Kidney}
\authorrunning{D. O. Kidney}
\institute{University College Cork \and
  \email{o.kidney@cs.ucc.ie}}
\begin{document}
\maketitle
\begin{abstract}
  We explore five notions of finiteness in Homotopy Type Theory \cite{hottbook}.
  We prove closure properties about all of these notions, culminating in a proof
  that decidable Kuratowski-finite sets form a topos.

  We extend the definitions to include infinite types, developing a similar
  classification of countable types.

  We use the definition of finiteness to formalise \emph{species}, in much
  the same way as in \cite{yorgeyCombinatorialSpeciesLabelled2014}.
  A clear duality with containers
  \cite{abbottContainersConstructingStrictly2005} falls out naturally from our
  definition.

  We formalise our work in Cubical Agda
  \cite{vezzosiCubicalAgdaDependently2019}, and we implement a library for proof
  search (including combinators for level-polymorphic fully generic currying),
  and demonstrate how it can be used to both prove properties and synthesise
  full functions given desired properties.
\end{abstract}
% \section{Introduction}
% Proofs in a constructive setting are more substantial things than their
% classical counterparts.
% Rather than just evidence for some fact, they are objects in their own right,
% which we can manipulate and extract information from.

% Sometimes, the extra detail can reveal interesting subtleties: fissures which
% divide homogeneous-seeming definitions into a variety of related concepts.
% Finiteness is a prime example of this phenomenon: in classical set theory, a
% finite set is a finite set, and there's not much else that we can say.
% In constructive type theory, we start the bidding at no fewer than \emph{four}
% different predicates representing finiteness
% \cite{spiwackConstructivelyFinite2010}, upped to eight in
% \cite{firsovVariationsNoetherianness2016a}: all of which differ in significant
% and interesting ways.

% Other times, the extra baggage is unwanted.
% Maybe we want to enforce that a particular piece of information should be
% hidden, or treated as irrelevant: ``yes, I have proven that there is a
% particular number with this property, but I don't want to reveal \emph{which}
% number.''

% This is where Homotopy Type Theory \cite{hottbook} can step in.
% Through primarily a generalisation of equality, we gain access to a number of
% exotic types which can, among other things, allow us to perform this ``hiding''.
% In the context of finiteness, the act of hiding is worth studying in its own
% right, and further delineates several new finiteness predicates which collapse
% even in standard Martin-Löf type theory
% \cite{martin-lofIntuitionisticTypeTheory1980}.

% The other headline feature of HoTT's generalised equality is univalence: put
% simply, it allows us to treat isomorphic types as equal, giving us in the
% constructive world access to a technique that is commonplace classically.
% It turns out that finite types have a lot to say about isomorphisms, and we will
% rely heavily on this aspect of HoTT to work with them.
% \subsection{Contributions}
% In this work, we will explore finite types in Cubical Type Theory
% \cite{cohenCubicalTypeTheory2016}, and expose their relationship to infinite
% types, species, and demonstrate their practical uses for proofs in dependently
% typed programming languages.
% \subsubsection{Strong Finiteness Predicates}
% We will first explore the ``strong'' notions of finiteness (i.e. those at least
% as strong as Kuratowski finiteness \cite{kuratowskiNotionEnsembleFini1920}),
% with a special focus on cardinal finiteness (section~\ref{cardinal}), and
% manifest enumerability (section~\ref{manifest-enumerability}), which is new, to
% our knowledge.

% \input{figures/finite-classification}
% Figure~\ref{finite-classification} organises the predicates according to
% their ``strength''; i.e. how much information they provide about a conforming
% type.
% For instance, a proof that some type \(A\) is manifestly Bishop finite (the
% strongest of the notions, explored in section~\ref{manifest-bishop}) also tells
% us that \(A\) is discrete (has decidable equality), and gives us a linear order
% on the type.
% A type that is Kuratowski finite (section~\ref{kuratowski}) has no such extra
% features: indeed, we will see examples of Kuratowski finite types which are not
% even sets, never mind discrete ones.

% We will go through each of the predicates, proving how to weaken each (i.e. we
% will provide a proof that every cardinally finite type is Kuratowski finite),
% and how to strengthen them, given the required property.
% In terms of figure~\ref{finite-classification}, this amounts to providing proofs
% for each arrow.

% We will---through the use of containers
% \cite{abbottContainersConstructingStrictly2005}---formally prove the equivalence
% these predicates have with the usual function relations i.e. we will show that a
% proof of manifest enumerability is precisely equivalent to a surjection from a
% finite prefix of the natural numbers.

% For each predicate, we will also prove its closure over sums and products in
% both dependent and non-dependent forms, if such a closure exists.
% This will culminate in our main result for this section: the formal proof that
% decidable Kuratowski finite sets form a topos. \todo[noline]{reference for this}
% More specifically, we show that cardinal finite sets form a topos, that
% decidable Kuratowski finite sets are equivalent in strength to cardinal finite
% sets, and carry the proof over.
% This result relies on proofs on each of the other finiteness predicates.
% \subsubsection{Species}
% \todo[inline]{Redo this next paragraph}
% In section~\ref{species-and-containers}, we will redefine our finiteness
% predicates using \emph{containers}, and prove that the new definitions are
% equivalent to the old.
% Using this, we will prove much stronger relationships between our finiteness
% predicates and relation-based definitions of finiteness.
% Finally, We will show how the species-container duality falls out naturally from
% these new definitions.

% \subsubsection{Infinite Types}
% In section~\ref{infinite-cardinalities}, we will extend our study of finite
% types to infinite but countable types.
% We will see that the finiteness predicates are mirrored with countable
% counterparts, and we will prove closure under the Kleene star and plus.

% \subsubsection{Practical Uses of Finiteness}
% Proofs of finiteness have well-known practical applications in
% constructive mathematics \cite{firsovDependentlyTypedProgramming2015}.
% In section~\ref{practical}, we build a library which exploits these uses in
% Cubical Agda \cite{vezzosiCubicalAgdaDependently2019}, allowing automation of
% complex proofs over finite types.
% We frame this in terms of the principle of omniscience for finite types.
% Thanks to the flexibility afforded to us by Cubical Type Theory, we are able to
% go further than the usual examples of this kind of proof automation: as well as
% proving properties about functions, we can synthesise functions whole-cloth from
% their desired properties.
% Through the unified interface for finite and countable types, we can
% reuse the automation machinery for \emph{partial} proof search over infinite
% search spaces.
% Along the way, we extend the work in \cite{allaisGenericLevelPolymorphic2019} to
% prove isomorphisms between the curried and uncurried forms of \(n\)-ary
% dependent functions.
\section{Split Enumerability} \label{split-enumerable}
We will start with the simplest definition of finiteness: we say a set is
enumerable if there is a list of its elements which contains every element in
the set.
More formally:
\begin{rm-definition}[Split Enumerable Set]
  \begin{equation}
    \mathcal{E}!(A) = \sum_{(\mathit{xs} : \textbf{List}(A))} , \prod_{(x : A)} , x \in xs
  \end{equation}
  We call the first component of this pair the ``support'' list, and the second
  component the ``cover'' proof.
\end{rm-definition}

We will at this point take a moment to define some of the types we used to
define \(\mathcal{E}!\).
Lists, and membership thereof, are defined using \emph{containers}.
\begin{rm-definition}[Container] \label{container-def}
  A container \cite{abbottContainersConstructingStrictly2005} is a pair
  \(S \triangleright P\) where \(S\) is a type, the elements of which are called
  the \emph{shapes} of the container, and \(P\) is a type family on \(S\), where
  the elements of \(P(s)\) are called the \emph{positions} of a container.
  \begin{equation}
    \begin{aligned}
      S : \text{Type}, P : S \rightarrow \text{Type} \\
      \mathbf{Container} = S \triangleright P
    \end{aligned}
  \end{equation}
  We ``interpret'' a container into a functor defined like so:
  \begin{equation}
    \llbracket S \triangleright P \rrbracket = \prod_{(X : \text{Type})} , \sum_{(s : S)} , \left( P(s) \rightarrow X \right)
  \end{equation}
  Membership of a container can be defined like so:
  \begin{equation}
    x \in \mathit{xs} = \text{fiber}(\text{snd}(\mathit{xs}), x)
  \end{equation}
\end{rm-definition}
Containers can be used to define a wide variety of functors (streams, trees,
etc.): lists are all that interest us now.
\begin{rm-definition}[\mathbf{Fin}]
  \(\mathbf{Fin}\)(n) is the type of natural numbers smaller than \(n\).
  It is defined inductively, as follows:
  \begin{equation}
    \begin{aligned}
      \mathbf{Fin}(0) &= \bot \\
      \mathbf{Fin}(n + 1) &= \top + \mathbf{Fin}(n)
    \end{aligned}
  \end{equation}
\end{rm-definition}
\begin{rm-definition}[Lists]
  The ``shape'' of lists is \(\mathbb{N}\), indicating the length of the list in
  question.
  \begin{equation}
    \mathbf{List} = \llbracket \mathbb{N} , \mathbf{Fin} \rrbracket
  \end{equation}
\end{rm-definition}

Internally, in our formalisation, we actually use the standard
inductive definition of lists more often (it tends to work better in more
complex algorithms, and functions on it seems to satisfy the termination
checker more readily).
However, since both types are equivalent, univalence allows us to transport to
whichever representation is more convenient in a given situation.
For the higher-level proofs we present here, though, the container-based
definition greatly simplifies certain steps, which is why we have chosen it as
our representation.
\subsection{Split Surjections}
Another, equivalent way to define ``finiteness'' is via a (split) surjection
from a finite prefix of the natural numbers.
In this section, we will prove that equivalence, formally.

\begin{rm-theorem} \label{split-enum-surj}
  Split enumerability is equivalent to a split surjection from a finite prefix
  of the natural numbers.
  \begin{equation}
    \mathcal{E}!(A) \simeq \sum_{(n : \mathbb{N})} , \left( \mathbf{Fin}(n) \twoheadrightarrow ! \; A \right)
  \end{equation}
\end{rm-theorem}
\begin{proof}
  The proof is surprisingly short: after sufficient inlining, it emerges that
  our goal is simply a reassociation.
  \ExecuteMetaData[agda/Cardinality/Container/Finite.tex]{split-surj}
\end{proof}
\subsection{Decidable Equality}
\begin{rm-lemma} \label{split-enum-discrete}
  Any split enumerable type has decidable equality (is discrete).
\end{rm-lemma}
\begin{proof}
  We use a corollary that if there is a split-surjection from \(A\) to \(B\),
  and \(A\) is discrete, then \(B\) is also discrete.
\end{proof}
\begin{rm-lemma}
  Any split enumerable type is a set.
\end{rm-lemma}
\begin{proof}
  By Hedberg's theorem \cite{hedbergCoherenceTheoremMartinLof1998}, since split
  enumerable types have decidable equality
  (proposition~\ref{split-enum-discrete}), they are sets.
\end{proof}
\subsection{Closure}
In this section we will prove closure under various operations for split
enumerable sets.
We are working towards a topos proof, which requires us to prove closure under
a variety of operations: for now, we only have enough machinery to demonstrate
the semiring operations, and dependent sums.
in order to show closure under exponentials (function arrows), we will need an
equivalence with \(\mathbf{Fin}\), which will be provided in
section~\ref{manifest-bishop}.
\begin{rm-lemma}
  \(\bot\), \(\top\), and \(\mathbf{Bool}\) are all split enumerable.
\end{rm-lemma}
\begin{proof}
  These non-recursive types have similar, simple proofs.
  For each we first provide the support list: they are \([]\), \([\text{tt}]\),
  and \([\text{false}, \text{true}]\) respectively.
  The cover proof should return an index which points at the given element: for
  \(\bot\) this function is present via the principle of explosion, for \(\top\)
  we always return a \(0\), and for \(\mathbf{Bool}\) we return a \(0\) for
  \(\text{false}\), and a \(1\) for \(\text{true}\).
  \begin{multicols}{3}
    \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{bool}
    \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{unit}
    \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{empty}
  \end{multicols}
\end{proof}
Next, we will look into how to combine proofs of split enumerability.
\begin{rm-theorem}
  Split-enumerability is closed under \(\sum\).
\end{rm-theorem}
\begin{proof}
  Let \(E_A\) be a proof of split enumerability for some type \(A\), and \(E_U\)
  be a function of the type:
  \begin{equation}
    E_U : \prod_{(x : A)} , \mathcal{E}!(U(x))
  \end{equation}
  In other words, a function which returns a proof of split enumerability for
  each member of the family \(U\).

  To obtain the support list, we concatenate the support lists of all the proofs
  of split-finiteness for \(U\) over the support list of \(E_A\).
  In Agda:
  \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{sigma-enum}
  ``do-notation'' is available to us as we're working in the list monad.
\end{proof}
\begin{rm-lemma}
  Split-enumerability is closed under disjoint union (non-dependent sum) and
  Cartesian product (non-dependent product).
\end{rm-lemma}
\begin{proof}
  Both of these closures can be derived from closure of the \(\sum\) type.
  The non-dependent product is equivalent to a special case of \(\sum\):
  \begin{equation}
    A \times B \simeq \sum_{(x : A)} , B
  \end{equation}
  And disjoint union between two types \(A\) and \(B\) can be represented by the
  following type:
  \begin{equation}
    A + B = \sum_{(x : \mathbf{Bool})} , \text{if} \; x \; \text{then} \; A \; \text{else} \; B
  \end{equation}
  Then, since all of \(\mathbf{Bool}\), \(A\), and \(B\) are split enumerable,
  the type \(A + B\) is split enumerable.
\end{proof}
\section{Manifest Bishop Finiteness} \label{manifest-bishop}
\begin{rm-definition}[Manifest Bishop Finiteness]
  \begin{equation}
    \mathcal{B}(A) = \sum_{(\mathit{xs} : \textbf{List}(A))} , \prod_{(x : A)} , x \inunique xs
  \end{equation}
\end{rm-definition}
The only difference between this predicate and split enumerability is the list
membership term: we use \(\inunique\) here, where \(x \inunique \mathit{xs}\) is
to be read as ``\(x\) occurs exactly once in \(\mathit{xs}\)''.
\begin{rm-definition}[Unique Membership]
  We say an item \(x\) is ``uniquely in'' some container \(\mathit{xs}\) if its
  membership in that list is a \emph{contraction}; i.e. its membership proof
  exists, and all such proofs are equal.
  \begin{equation}
    x \inunique \mathit{xs} = \text{isContr}(x \in \mathit{xs})
  \end{equation}
\end{rm-definition}

A nice consequence of prohibiting duplicates is that now the length of the
support list is the same as the cardinality of the set.
\subsection{Equivalence}
Where split enumerability was the enumeration form of a surjection from
\(\mathbf{Fin}\), we see here that manifest Bishop finiteness is the enumeration
form of an \emph{equivalence} with \(\mathbf{Fin}\).
\begin{rm-lemma} \label{bishop-equiv}
  A proof of manifest Bishop finiteness is equivalent to an equivalence with a
  finite prefix of the natural numbers.
  \begin{equation}
    \mathcal{B}(A) \simeq \sum_{(n : \mathbb{N})} , \left( \mathbf{Fin}(n) \simeq A \right)
  \end{equation}
\end{rm-lemma}
\begin{proof}
  There are many equivalent definitions of equivalence in HoTT.
  Here we take the version preferred in the Cubical Agda library: contractible
  maps \cite{hottbook}.
  Because of the parallels between contractible maps and split surjections,
  the proof proceeds much the same as \ref{split-enum-surj}.
  In other words, the definition of Bishop finiteness is itself a reassociation
  of a contractible map.
\end{proof}
\subsection{Relationship to Split Enumerability}
We now show that manifest Bishop finiteness has equal strength to split
enumerability.
\begin{rm-lemma}
  Any manifest Bishop finite set is split enumerable.
\end{rm-lemma}
\begin{proof}
  The support set carries over simply, and the cover proof can be taken from the
  first component of the cover proof from the proof of manifest Bishop
  finiteness.
\end{proof}
\begin{rm-theorem} \label{split-enum-to-manifest-bishop}
  Any split enumerable set is manifest Bishop finite.
\end{rm-theorem}
\begin{proof}
  Let \(E\) be a proof of split enumerability for some set \(A\).
  From proposition~\ref{split-enum-discrete} we can derive decidable equality on
  \(A\), and using this we can define a function \(\text{uniques}\) which filters
  out duplicates from lists of \(A\)s.
  \begin{equation}
    \text{uniques} : \textbf{List}(A) \rightarrow \textbf{List}(A)
  \end{equation}
  This gives us our support list.

  It suffices now to prove the following:
  \begin{equation}
    \prod_{(x : A)} , \prod_{(\mathit{xs} : \textbf{List}(A))} , x \in \mathit{xs} \rightarrow x \inunique \text{uniques}(\mathit{xs})
  \end{equation}
  And from that we can generate our cover proof.
\end{proof}
Note that while manifest Bishop finiteness as split enumerability are equivalent
in ``strength'', the two types are not equivalent.
In particular, there are infinitely many inhabitants of \(\mathcal{E}!\), while
for a type \(A\) with \(n\) inhabitants, there are only \(n!\) inhabitants of
\(\mathcal{B}(A)\).
\subsection{Closure}
Proving equal strength of split enumerability and manifest Bishop finiteness
allows us to carry all of the previous proofs of closure over to manifest Bishop
finite sets (and vice-versa).
Missing from our previous proofs was a proof of closure of functions.
We remedy that here.
\begin{rm-theorem}
  Manifest bishop finiteness is closed over dependent functions (\(\prod\)-types).

  Formally, given a type \(A\) and a type family \(U\) on \(A\), when \(A\) is
  manifestly Bishop finite:
  \begin{equation}
    \mathcal{B}\left( A \right)
  \end{equation}
  And \(U\) is manifestly Bishop finite over all points of \(A\):
  \begin{equation}
    \prod_{(x : A)} , \mathcal{B}\left( U(x) \right)
  \end{equation}
  Then we have the following:
  \begin{equation}
    \mathcal{B}\left(\prod_{(x : A)} , U(x)\right)
  \end{equation}
\end{rm-theorem}
\begin{proof}
  This proof is essentially the composition of two transport operations, made
  available to us via univalence.
  
  First, we will simplify things slightly by working only with split
  enumerability.
  As this is equal in strength to manifest Bishop finiteness, any closure proofs
  carry over.

  Secondly, we will replace \(A\) in all places with \(\mathbf{Fin}(n)\).
  Since we have already seen an equivalence between these two types, we are
  permitted to transport along these lines.
  This is the first transport operation.

  The bulk of the proof now is concerned with proving the following:
  \begin{equation}
    \left( \prod_{(x : \mathbf{Fin}(n))} , \mathcal{E}!(A(x)) \right) \rightarrow \mathcal{E}!\left( \prod_{(x : \mathbf{Fin}(n))} , A(x) \right)
  \end{equation}
  Our strategy to accomplish this will be to consider functions from
  \(\mathbf{Fin}(n)\) as \(n\)-tuples over some type family \(T : \mathbb{N}
  \rightarrow \text{Type}\).
  \begin{equation}
    \begin{aligned}
      \mathbf{Tuple}(T, 0)   &= \top \\
      \mathbf{Tuple}(T, n+1) &= T(0) \times \mathbf{Tuple}(T \circ \text{suc}, n)
    \end{aligned}
  \end{equation}
  This type is manifestly Bishop finite, as it is constructed only from products
  and the unit type.
  
  We then prove an isomorphism between this representation and \(\Pi\)-types.
  \begin{equation}
    \mathbf{Tuple}(T, n) \iff \prod_{(x : \mathbf{Fin}(n))} , T(x)
  \end{equation}
  This allows us to transport our proof of finiteness on tuples to one on
  functions from \(\mathbf{Fin}\) (our second transport operation), proving our
  goal.
  
  \ExecuteMetaData[agda/Cardinality/Finite/ManifestBishop.tex]{pi-clos}
\end{proof}
\section{Manifest Enumerability} \label{manifest-enumerability}
A defining feature of split enumerability and Bishop finiteness is decidability:
both predicates imply a decidable equality function on the underlying type.
To find a predicate for finiteness which doesn't imply this, and therefore
works with types other than just sets, we \emph{truncate} the membership proof.
\begin{rm-definition}[Manifest Enumerability]
  \begin{equation}
    \mathcal{E}(A) = \sum_{(\mathit{xs} : \mathbf{List}(A))} , \prod_{(x : A)} , \lVert x \in \mathit{xs} \rVert
  \end{equation}
\end{rm-definition}
\subsection{Propositional Truncation}
\begin{rm-definition}[Propositional Truncation]
  The type \(\lVert A \rVert\) on some type \(A\) is a propositionally truncated
  proof of \(A\).
  In other words, it is a proof that some \(A\) exists, but it does not tell you
  \emph{which} \(A\).

  It is defined as a Higher Inductive Type:
  \begin{equation}
    \begin{aligned}
      \lVert A \rVert &= \\
        &| \; \lvert \cdot \rvert : A \rightarrow \lVert A \rVert ; \\
        &| \; \text{squash} : \prod_{(x, y : \lVert A \rVert)} , x \equiv y  ; \\
    \end{aligned}
  \end{equation}

  To eliminate from \(\lVert A \rVert\) we need to prove that we don't ``care''
  about the specific choice of \(A\).
  In other words, given a function \(f : A \rightarrow B\), to construct a
  function \(\lVert A \rVert \rightarrow B\), \(f\) needs to satisfy the following:
  \begin{equation}
    \prod_{(x , y : A)} , f(x) \equiv f(y)
  \end{equation}
  Formally speaking, \(f\) needs to be ``coherently constant''
  \cite{krausGeneralUniversalProperty2015}.
\end{rm-definition}
\subsection{Higher Homotopy Levels}
By hiding the position, we have essentially removed the ``decidable'' component
from split enumerability.
Our predicate now becomes general enough to work with non-sets: we will show
here that the circle is manifestly enumerable.
\begin{rm-theorem}
  The circle \(S^1\) is manifestly enumerable.
\end{rm-theorem}
\begin{proof}
  As the cover proof is a truncated proposition, we need only consider the point
  constructors, making this poof the same as the proof of split enumerability on
  \(\top\).

  The support list will be a singleton list containing the single point in the
  type, and the cover proof will be an index pointing at the first element in
  the support list.

  \ExecuteMetaData[agda/Cardinality/Finite/ManifestEnumerable.tex]{circ-inst}
\end{proof}
\subsection{Surjections}
This predicates relation to surjectivity is much the same as split
enumerability's relation to \emph{split} surjectivity.
Deriving a surjection from \(\mathbf{Fin}\) is straightforward:
\begin{rm-lemma}
  A proof of manifest enumerability is equivalent to a surjection from a finite
  prefix of the natural numbers.
\end{rm-lemma}
\begin{proof}
  \todo[inline]{Proof}
\end{proof}
\subsection{Relation to Split Enumerability}
As split enumerability is stronger than manifest enumerability, we can convert
from one to the other easily.
\begin{rm-lemma}
  Any split enumerable type is also manifestly enumerable.
\end{rm-lemma}
\begin{proof}
  The proof carries over via truncation of the cover proof.
\end{proof}
The main missing piece from manifest enumerability is decidable equality: by
truncating the membership proof, we have removed the ability to distinguish
(decidably) between members of the type.
Indeed, resupplying decidable equality is precisely sufficient to recover split
enumerability.

\begin{rm-theorem} \label{manifest-enum-to-split}
  A manifestly enumerable type with decidable equality is split enumerable.
\end{rm-theorem}
\begin{proof}
  The support list stays the same between both enumerability proofs.

  For the cover proof, we need a way to get the contents out of a truncated
  value.
  We can do exactly that with the following lemma, called recompute:
  Given a decision procedure for some type \(A\), and a truncation for the
  proposition \(A\), we can discount the possibility of \(A\) being false, and
  therefore extract the true decision.

  For the cover proof, our obligation now becomes constructing a decision for
  membership of the support list.
  This is straightforward given decidable equality.

  \ExecuteMetaData[agda/Cardinality/Finite/ManifestEnumerable.tex]{to-split-enum}
\end{proof}
By theorem~\ref{split-enum-to-manifest-bishop}, we also can derive that any
manifestly enumerable type with decidable equality is Bishop finite.
\subsection{Closure}
\begin{rm-lemma}
  Manifest enumerability is closed under dependent sum, disjoint union
  (non-dependent sum), and Cartesian product (non-dependent product).
\end{rm-lemma}
\begin{proof}
  For these three closures, the proofs on split enumerability consisted of a
  list manipulation followed by a proof that membership was preserved by the
  list manipulation.
  Because we separate these two concerns, the proofs carry over onto manifest
  enumerability: the support list manipulation stays the same, and the
  cover proofs are performed ``under'' the truncation.
\end{proof}
Notice that we do not have closure under functions: without decidability,
manifest enumerability is not closed under function arrows.
\section{Cardinal Finiteness} \label{cardinal}
We now turn our attention to notions of finiteness which do not induce a linear
order.
\begin{rm-definition}[Cardinal Finiteness]
  A type \(A\) is cardinally finite, \(\mathcal{C}\), if it has a
  propositionally-truncated proof of bishop finiteness.
  \begin{equation}
    \mathcal{C}(A) = \lVert \mathcal{B}(A) \rVert
  \end{equation}
\end{rm-definition}
\subsection{Closure}
The closure proofs for cardinal finiteness are especially easy.
In contrast to manifest enumerability, under the propositional truncation we
have a full proof of bishop finiteness, meaning that all of the closure proofs
carry over.
\begin{rm-lemma}
  Cardinal finiteness is closed under dependent and non-dependent sums,
  products, and functions.
\end{rm-lemma}
\begin{proof}
  All closure functions can be lifted under propositional truncation.
  Therefore, cardinal finiteness has the same closure properties as manifest
  bishop finiteness.
\end{proof}
\subsection{Strength}
We can eliminate from cardinal finiteness in a coherently constant way:
effectively, anything which doesn't ``notice'' the order of the internal support
list is usable.

First, even though the cardinality of the type is hidden under the truncation,
we can pull it out, as it is constant through permutations of the list.
\begin{rm-theorem}
  Given a cardinally finite type, we can derive the type's cardinality, as well
  as a propositionally truncated proof of equivalence with \(\textbf{Fin}\)s of
  the same cardinality.
  \begin{equation}
    \mathcal{C}(A) \rightarrow \sum_{(n : \mathbb{N})} , \lVert \textbf{Fin}(n) \simeq A \rVert
  \end{equation}
\end{rm-theorem}
\begin{proof}
  We eliminate from the proof of cardinal finiteness via the eliminator
  described in proposition~\ref{elim-non-prop}.
  We pass a function \(\text{alg}\) which preserves the first part of the pair,
  and truncates the second.
  In Agda:
  \ExecuteMetaData[agda/Cardinality/Finite/Cardinal.tex]{trunc-alg}

  It remains only to show that this function is coherently constant.
  \begin{equation}
    \prod_{(x : \sum_{(n : \mathbb{N})} , \textbf{Fin}(n) \simeq A)} ,
    \prod_{(y : \sum_{(m : \mathbb{N})} , \textbf{Fin}(m) \simeq A)} ,
    \text{alg}(x) \equiv \text{alg}(y)
  \end{equation}

  We will first address the first component of the output.
  To show that \(n\) and \(m\) are equal, we first observe that
  \begin{equation}
    \textbf{Fin}(n) \equiv \textbf{Fin}(m)
  \end{equation}
  since both are equivalent to \(A\).
  Relying on the fact that \(\textbf{Fin}\) is injective
  (proposition~\ref{fin-inj}), we can derive that \(n\) and \(m\) are equal.

  Since the second components of the output are propositions, they are
  definitionally equal.
  \ExecuteMetaData[agda/Cardinality/Finite/Cardinal.tex]{const-alg}
\end{proof}

\begin{rm-lemma} \label{fin-inj}
  \(\textbf{Fin}\) is injective.
\end{rm-lemma}
\begin{proof}
  Let \(n\) and \(m\) be natural numbers.
  We want to derive a proof of \(n \equiv m\) from \(\textbf{Fin}(n) \equiv
  \textbf{Fin}(m)\).

  We prove by contradiction (since the property we are interested in is
  decidable, this is valid constructively).
  When \(n\) does not equal \(m\), there are two possible cases.
  \begin{equation}
    \neg (n \equiv m) \implies
    \begin{cases}
      m \equiv 1 + n + k, n < m  \\
      n \equiv 1 + m + k, m < n
    \end{cases}
  \end{equation}
  Take the first case, without loss of generality.
  \todo[inline]{Finish prose for this proof}

  The Agda version of this proof is in the appendix (\ref{agda-fin}).
\end{proof}

Another property which does not rely on an internal order is decidable equality.
\begin{rm-theorem} \label{cardinal-finite-discrete}
  Any cardinal-finite set has decidable equality.
\end{rm-theorem}
\begin{proof}
  We first show that decidable equality is a proposition itself.
  We know that if a type \(A\) is a proposition, then the decision over that
  type is also a proposition.
  Then, via Hedberg's theorem, we know that any type with decidable equality is
  a set, meaning that paths in that type are themselves propositions.
  Therefore we can derive that a decision of equality on elements with decidable
  equality is a proposition, and by function extensionality we see that
  decidable equality is itself a proposition.

  That is enough to pull it out of the truncation: since any Bishop-finite type
  has decidable equality, and decidable equality is a proposition, we conclude
  that cardinal-finite types have decidable equality.
\end{proof}
\subsection{Relation to Manifest Bishop Finiteness}
Cardinal finiteness tells us that there is an isomorphism between a type and
\(\mathbf{Fin}\); it just doesn't tell us \emph{which} isomorphism.
To take a simple example, \(\mathbf{Bool}\) has 2 possible isomorphisms with the
set \(\mathbf{Fin}(2)\): one where false maps to 0, and true to 1; and another
where false maps to 1 and true to 0.

To convert from Cardinal finiteness to Bishop finiteness, then, requires that we
supply enough information to identity a particular isomorphism.
A total order is sufficient here: it will give us enough to uniquely order the
support list invariant under permutations.
This tells us what we already knew in the introduction: manifest Bishop
finiteness is cardinal finiteness plus an order.

\begin{rm-theorem}
  Any cardinal finite type with a (decidable) total order is manifestly Bishop
  finite.
\end{rm-theorem}
\begin{proof}
  This proof is quite involved, and will rely on several subsequent lemmas, so
  we will give only its outline here.
  \begin{itemize}
    \item First, we will convert to manifest enumerability: knowing that the
      underlying type is discrete (theorem~\ref{cardinal-finite-discrete}) we can
      go from manifest enumerability to split enumerability
      (lemma~\ref{manifest-enum-to-split}), and subsequently to manifest Bishop
      finiteness (lemma~\ref{split-enum-to-manifest-bishop}).
    \item To convert to manifest enumerability, we need to provide a support
      list: this cannot simply be the support list hidden under the truncation,
      since that would violate the hiding promised by the truncation.
      Instead, we sort the list (using insertion sort).
      We must, therefore, prove that insertion sort is invariant under all
      support lists in cardinal finiteness proofs.
    \item We show that all support lists in cardinal finiteness proofs are
      permutations of each other.
    \item And then we show that insertion sort is invariant under permutations.
  \end{itemize} 
\end{proof}
Now we will build up the toolkit we need to perform the above steps.
First, permutations.
\begin{rm-definition}[List Permutations]
  We say that two lists are permutations of each other if there is an
  isomorphism between membership proofs
  \cite{danielssonBagEquivalenceProofRelevant2012}.
  \begin{equation}
    \mathit{xs} \leftrightsquigarrow \mathit{ys} = \prod_{(x : A)} , x \in \mathit{xs} \iff x \in \mathit{ys}
  \end{equation}
\end{rm-definition}
We also prove some of the identities you might expect with regards to
permutations, all in the appendix.
In particular, we prove that they form an equivalence relation.
\begin{rm-lemma}
  Insertion sort is invariant under permutations.
  \begin{equation}
    \mathit{xs} \leftrightsquigarrow \mathit{ys} \implies \text{sort}(\mathit{xs}) \equiv \text{sort}(\mathit{ys})
  \end{equation}
\end{rm-lemma}
\begin{proof}
  We first prove that insertion sort does indeed sort its input: i.e. it returns
  a sorted list that is a permutation of its input.
  Then we show that any two sorted lists which are permutations of each other
  are equal.
\end{proof}
\todo[inline]{Agda code for proofs}
\section{Kuratowski Finiteness} \label{kuratowski}
Finally we arrive at Kuratowski finiteness
\cite{kuratowskiNotionEnsembleFini1920}.
\subsection{The Kuratowski Set as a Higher Inductive Type}
We start with the Kuratowski finite sets, which are free join semilattices (or,
equivalently, free commutative idempotent monoids).
HITs are required to define this type
\cite{altenkirchDefinableQuotientsType2011}; however we have two possible
candidates for the definition.
The first is a direct translation of ``free commutative idempotent monoid'' into
a type:
\begin{equation}
\begin{aligned}
  \mathcal{K}(A) &=  \\
    &\left\vert \; \text{singleton} : A \rightarrow \mathcal{K}(A) \right; \\
    &\left\vert \; \cdot \cup \cdot : \mathcal{K}(A) \times \mathcal{K}(A) \rightarrow \mathcal{K}(A) \right; \\
    &\left\vert \; \emptyset : \mathcal{K}(A) \right; \\
    &\left\vert \; \cup \text{-assoc} : \Pi \left( \mathit{xs}, \mathit{ys}, \mathit{zs}:\mathcal{K}(A)\right) , (\mathit{xs} \cup \mathit{ys}) \cup \mathit{zs} \equiv \mathit{xs} \cup (\mathit{ys} \cup \mathit{zs}) \right; \\
    &\left\vert \; \cup \text{-commutative} : \Pi (\mathit{xs}, \mathit{ys}: \mathcal{K}(A)) , \mathit{xs} \cup \mathit{ys} \equiv \mathit{ys} \cup \mathit{xs} \right; \\
    &\left\vert \; \cup \text{-idempotent} : \Pi (\mathit{xs}: \mathcal{K}(A)) , \mathit{xs} \cup \mathit{xs} \equiv \mathit{xs} \right; \\
    &\left\vert \; \cup \text{-identity} : \Pi (\mathit{xs}: \mathcal{K}(A)) , \emptyset \cup \mathit{xs} \equiv \mathit{xs} \right; \\
    &\left\vert \; \text{trunc} : \Pi (\mathit{xs}, \mathit{ys}: \mathcal{K}(A)) , \Pi (p, q : \mathit{xs} \equiv \mathit{ys}) , p \equiv q \right;
\end{aligned}
\end{equation}
\todo[inline]{Have we already described the trunc constructor?}

However this proves cumbersome to work with.
Instead, we build on the free monoid (the list), and add the required equations
we need.
\begin{equation}
\begin{aligned}
  \mathcal{K}(A) &=  \\
    &\left\vert \; \cdot \dblcolon \cdot : A \times \mathcal{K}(A) \rightarrow \mathcal{K}(A) \right; \\
    &\left\vert \; [] : \mathcal{K}(A) \right; \\
    &\left\vert \; \text{com} : \Pi (x, y: A) , \Pi (\mathit{xs}: \mathcal{K}(A)) , x \dblcolon y \dblcolon \mathit{xs} \equiv y \dblcolon x \dblcolon \mathit{xs} \right; \\
    &\left\vert \; \text{dup} : \Pi (\mathit{x}: A) , \Pi (\mathit{xs}: \mathcal{K}(A)) , x \dblcolon x \dblcolon \mathit{xs} \equiv x \dblcolon \mathit{xs} \right; \\
    &\left\vert \; \text{trunc} : \Pi (\mathit{xs}, \mathit{ys}: \mathcal{K}(A)) , \Pi (p, q : \mathit{xs} \equiv \mathit{ys}) , p \equiv q \right;
\end{aligned}
\end{equation}
Since associativity and identity (the monoid laws) are automatically satisfied
by the list structure, we do not need to specify them as paths.
Furthermore, it is simpler to specify the rest of the paths on the heads of the
lists, rather than on the whole structure.
That said, the two definitions are equivalent.
\todo[inline]{Maybe add sketch of proof here?}
\subsection{Elimination}
With Agda's dependent pattern matching, we get an eliminator automatically from
the definition of an inductive type.
We will define two further eliminators here.

\begin{equation}
  \begin{aligned}
    \phi &: \mathcal{K}(A) \rightarrow \text{Type} \\
    \text{trunc}^\phi &: \pifun{x}{\mathcal{K}(A)} , \text{isSet}(\phi(x)) \\
    []^\phi &: \phi([]) \\
    \dblcolon^\phi &: \pifun{x}{A} , \pifun{xs}{\mathcal{K}(A)} , \pifun{p}{\phi(\mathit{xs})} , \phi(x \dblcolon \mathit{xs}) \\
    \text{com}^\phi &: \prod_{(x , y : A)} , \pifun{xs}{\mathcal{K}(A)} , \pifun{p}{\phi(\matit{xs})} , x \dblcolon^\phi (y \dblcolon \mathit{xs}) (y \dblcolon^\phi \mathit{xs} \; p) \equiv y \dblcolon^\phi (x \dblcolon \mathit{xs}) (x \dblcolon^\phi \mathit{xs} \; p) \\
    \text{dup}^\phi &: \pifun{x}{A} , \pifun{xs}{\mathcal{K}(A)} , \pifun{p}{\phi(\mathit{xs})} , x \dblcolon^\phi (x \dblcolon \mathit{xs}) (x \dblcolon^\phi \mathit{xs} \; p) \equiv x \dblcolon^\phi \mathi{xs} \; p
  \end{aligned}
\end{equation}

\begin{equation} \label{kuratowski-rec}
  \text{rec} \left\{ \begin{aligned}
    \phi &: \text{Type} \\
    \text{trunc}^\phi &: \text{isSet}(\phi) \\
    []^\phi &: \phi \\
    \dblcolon^\phi &: \pifun{x}{A} , \pifun{xs}{\mathcal{K}(A)} , \phi \\
    \text{com}^\phi &: \prod_{(x , y : A)} , \pifun{xs}{\mathcal{K}(A)} , x \dblcolon^\phi (y \dblcolon^\phi \mathit{xs}) \equiv y \dblcolon^\phi (x \dblcolon^\phi \mathit{xs}) \\
    \text{dup}^\phi &: \pifun{x}{A} , \pifun{xs}{\mathcal{K}(A)} , x \dblcolon^\phi (x \dblcolon^\phi \mathit{xs}) \equiv x \dblcolon^\phi \mathit{xs}
  \end{aligned} \right.
\end{equation}

\todo[inline]{Expand on these eliminators}

\subsection{Membership}
We can define membership of a Kuratowski set using these eliminators.
First we define the \(\Diamond\) type, described in the appendix.
\begin{equation}
  \Diamond P = \left\{ \begin{aligned}
    \phi &= \sum_{(x : \text{Type})} , \text{isProp}(x) \\
    \text{trunc}^\phi &= \text{isSetHProp} \\
    []^\phi &= \bot , \text{isProp}\bot \\
    x \dblcolon^\phi \mathit{xs} &= \lVert P(x) \uplus \text{fst}(\mathit{xs}) \rVert , \text{squash} \\
    \text{com}^\phi &= \dots \\
    \text{dup}^\phi &= \dots
  \end{aligned} \right.
\end{equation}
We can define membership then in terms of this.
\begin{rm-definition}[Kuratowski Membership]
  \begin{equation}
    x \in \mathit{xs} = \Diamond (\equiv x) \mathit{xs}
  \end{equation}
\end{rm-definition}

From this we can define Kuratowski finiteness.
\begin{rm-definition}[Kuratowski Finiteness]
  A type is Kuratowski finite iff there exists a Kuratowski Set which contains
  all of its elements.
  \begin{equation}
    \mathcal{K}^{f}(A) = \sum_{(\text{support} : \mathcal{K}(A))} , \pifun{x}{A} , x \in \text{support}
  \end{equation}
\end{rm-definition}

\subsection{Strength}
Since the Kuratowski set is a departure in structure from our previous
list-based notions of finiteness, it makes sense to first look for the closest
list-based analogue.
As it turns out, that analogue is manifestly enumerable finiteness, with the
order removed.
\begin{rm-theorem}
  A proof of Kuratowski finiteness is equivalent to a propositionally truncated
  proof of enumerability.
  \begin{equation}
    \mathcal{K}^f(A) \simeq \lVert \mathcal{E}(A) \rVert
  \end{equation}
\end{rm-theorem}
\begin{proof}
  We prove by way of an isomorphism.
  In the first direction (from \(\mathcal{K}\) to \(\mathcal{E}\)), we use the
  eliminator in \ref{kuratowski-rec}.
  Because we are eliminating into a proposition, we need not prove that the
  function obeys the path constructors.
  The remaining cases to deal with involve converting the Kuratowski set to a
  list, and the cover proof to its equivalent cover proof on lists.
  \ExecuteMetaData[agda/Cardinality/Finite/Kuratowski.tex]{to-enum}

  To go the other direction, we first need to prove that a proof of Kuratowski
  finiteness is a proposition.
  \todo[inline]{Explain rest of this proof}
\end{proof}
Based on previous proofs, we can derive that if we add decidability to a
Kuratowski finite type we retrieve cardinal finiteness.
\begin{rm-lemma}
  Any Kuratowski finite set with decidable equality is cardinally finite.
\end{rm-lemma}
\begin{proof}
  \todo[inline]{Proof}
\end{proof}
\begin{rm-lemma}
  Kuratowski finiteness is equivalent to a truncated surjection from some prefix
  of the natural numbers.
  \begin{equation}
    \mathcal{K}^f(A) \simeq \left\Vert \sum_{(n : \mathbb{N})} , \left(  \mathbf{Fin}(n) \twoheadrightarrow A \right) \right\Vert
  \end{equation}
\end{rm-lemma}
\begin{proof}
  \todo[inline]{Prose for proof}
\end{proof}
\subsection{Topos}
At this point, we see that a ``decidable Kuratowski finite set'' is precisely
equivalent to a cardinal finite set.
From this, we can lift over all of the properties of cardinal finite sets.
In particular, we see that decidable Kuratowski finite sets form a \emph{topos}.
\todo[inline]{Fill in rest}
\subsection{Closure}
\begin{rm-theorem}
  Kuratowski finite sets are closed under \(\sum\).
\end{rm-theorem}
\begin{proof}
  \todo[inline]{Proof}
\end{proof}
\section{Species and Containers} \label{species-and-containers}
\subsection{Containers For Finiteness}
The definition for the container-based finiteness predicates are almost
identical to their list-based counterparts.
\ExecuteMetaData[agda/Cardinality/Container/Finite.tex]{split-enum}
One advantage that they have, however, is that conversion back and forth between
the relation-based finiteness predicates is very straightforward.
This allows us to prove the following.
\begin{rm-theorem}
  Manifest bishop finiteness is equivalent to an equivalence with some \(\mathbf{Fin}\).
  \begin{equation}
    \mathcal{B}(A) \simeq \sum_{(n : \mathbb{N})} , \mathbf{Fin}(n) \simeq A
  \end{equation}
\end{rm-theorem}
\begin{proof}
  This proof is the composition of two equivalences.
  First, we must show that the list-based manifest Bishop finiteness is
  equivalent to the container-based definition, and then we must show that the
  container-based definition of manifest Bishop finiteness is equivalent to the
  equivalence.
  \todo[inline]{proof}
\end{proof}

\begin{rm-lemma}
  Manifest enumerability is equivalent to a surjection from some \(\mathbf{Fin}\).
  \begin{equation}
    \mathcal{E}(A) \simeq \sum_{(n : \mathbb{N})} , \left(  \mathbf{Fin}(n) \twoheadrightarrow A \right)
  \end{equation}
\end{rm-lemma}
\begin{proof}
\end{proof}

\begin{rm-lemma}
  Split enumerability is equivalent to a split surjection from some \(\mathbf{Fin}\).
  \begin{equation}
    \mathcal{E}!(A) \simeq \sum_{(n : \mathbb{N})} , \left(  \mathbf{Fin}(n) \twoheadrightarrow ! A \right)
  \end{equation}
\end{rm-lemma}
\begin{proof}
\end{proof}

\section{Infinite Cardinalities} \label{infinite-cardinalities}
While the previous section purported to be about finite sets, we can now see
that it was really only studying surjections and isomorphisms of different
flavours between types and \(\mathbf{Fin}\).
The natural next question which arises, then, is if we can extend that work to
surjections and isomorphisms with \(\mathbb{N}\).
In more standard language, what we're referring to here is of course
countable infinity and related concepts.
However, as with finite types, the ``countably infinite'' types have more
varieties in constructive mathematics than their classical counterparts.
\subsection{Split Countable Types}
Our first foray into the world of countable types will be a straightforward
analogue to the split enumerable types.
We need change only one element: instead of a support \emph{list}, we instead
have a support \emph{stream}, which is its infinite, coinductive counterpart.
\begin{rm-definition}[Stream]
  We will work with two isomorphic definitions of streams.
  The first is the following:
  \begin{equation}
    \mathbf{Stream}(A) = \mathbb{N} \rightarrow A
  \end{equation}
  Conceptually, a stream is like a list without an end.
  Of course, such a type can not be defined in the same way as a list: it would
  be impossible to construct a value, as inductive types do not admit
  infinitely-sized inhabitants.
\end{rm-definition}
We can now define the split countable types.
\begin{rm-definition}[Split Countability]
  \begin{equation}
    \mathcal{E}!(A) = \sum_{(\mathit{xs} : \mathbf{Stream}(A))} , \prod_{(x : A)} , x \in \mathit{xs}
  \end{equation}
\end{rm-definition}
\subsubsection{\(\Sigma\) Closure}
We know that countable infinity is not closed under the exponential (function
arrow), so the only closure we need to prove is \(\Sigma\) to cover all of
what's left.
To do this we have to take a slightly different approach to the functions we
defined before.
Figure~\ref{pairings} illustrates the reason why: previously, we used the
``Cartesian'' product pairing for each support list.
This diverges if the first list is infinite, never exploring anything other than
the first element in the second list.
Instead, we use here the cantor pairing function, which performs a breadth-first
search of the pairings of both lists.
\begin{figure}
  \centering
  \begin{subfigure}[b]{.5\linewidth}
    \begin{tikzcd}[sep=tiny,font=\footnotesize]
      (1,e) \ar[rdddd, out=-45, in=135] & (2,e) \ar[rdddd, out=-45, in=135] & (3,e) \ar[rdddd, out=-45, in=135] & (4,e) \ar[rdddd, out=-45, in=135] & (5,e)        \\
      (1,d) \ar[u]     & (2,d) \ar[u]    & (3,d) \ar[u]    & (4,d) \ar[u]    & (5,d) \ar[u] \\
      (1,c) \ar[u]     & (2,c) \ar[u]    & (3,c) \ar[u]    & (4,c) \ar[u]    & (5,c) \ar[u] \\
      (1,b) \ar[u]     & (2,b) \ar[u]    & (3,b) \ar[u]    & (4,b) \ar[u]    & (5,b) \ar[u] \\
      (1,a) \ar[u]     & (2,a) \ar[u]    & (3,a) \ar[u]    & (4,a) \ar[u]    & (5,a) \ar[u]
    \end{tikzcd}
    \caption{Cartesian}
    \label{cartesian}
  \end{subfigure}%
  \begin{subfigure}[b]{.5\linewidth}
    \begin{tikzcd}[sep=tiny,font=\footnotesize]
      (1,e) \ar[dr] & (2,e) \ar[dr]  & (3,e) \ar[dr]    & (4,e) \ar[dr] & (5,e) \\
      (1,d) \ar[dr] & (2,d) \ar[dr]  & (3,d) \ar[dr]    & (4,d) \ar[dr] & (5,d) \ar[u] \\
      (1,c) \ar[dr] & (2,c) \ar[dr]  & (3,c) \ar[dr]    & (4,c) \ar[dr] & (5,c) \ar[uul] \\
      (1,b) \ar[dr] & (2,b) \ar[dr]  & (3,b) \ar[dr]    & (4,b) \ar[dr] & (5,b) \ar[uuull, out=130, in=-50] \\
      (1,a) \ar[u]  & (2,a) \ar[uul, out=130, in=-50] & (3,a) \ar[uuull, out=130, in=-50] & (4,a) \ar[uuuulll, out=130, in=-50] & (5,a) \ar[uuuulll, out=130, in=-50]
    \end{tikzcd}
    \caption{Cantor}
    \label{cantor}
  \end{subfigure}
  \caption{Two possible products for the sets \(\left[ 1 \dots 5 \right]\) and
    \(\left[  a \dots e \right]\)}
  \label{pairings}
\end{figure}
\begin{rm-theorem} \label{split-countability-sigma}
  Split countability is closed under \(\Sigma\).
\end{rm-theorem}
\begin{proof}
  Let \(\mathcal{X}\) be the proof of split countability on \(A\), and
  \(\mathcal{Y}\) be a function of the following type:
  \begin{equation}
    \mathcal{Y} : \prod_{(x : A)} , \mathcal{E}!(U(x))
  \end{equation}
  Where \(U\) is a type family on \(A\).
  Our task is to provide the following:
  \begin{equation}
    \mathcal{E}!\left(\sum_{(x : A)} , U(x)\right)
  \end{equation}

  This final proof consists of the support stream, and the proof that the
  support stream covers the input.

  As mentioned, we will have to use a more sophisticated pairing function than
  the Cartesian product we used before.
  We instead will mirror the pattern in figure~\ref{cantor}.
  To greatly simplify the algorithm, we will produce an intermediate stream of
  lists which consists of the diagonals in the diagram.
  We then concatenate these streams into the final support stream.

  Here is the algorithm in Agda:
  \ExecuteMetaData[agda/Cardinality/Container/Infinite.tex]{conv}
  \todo[inline]{Finish prose for this proof}
\end{proof}
\begin{rm-lemma}
  Split countability is closed under non-dependent product and sum.
\end{rm-lemma}
\begin{proof}
  Follows from theorem~\ref{split-countability-sigma}.
\end{proof}
\subsubsection{Kleene Star and Plus}
While we lose some closures with the inclusion of infinite types, we gain some
others.
In particular, we have the Kleene star and plus.
These allow us to introduce recursion into countable types, by way of lists.
\begin{rm-definition}[Kleene Lists]
  It is often useful to have two mutually-defined list types (one for
  possibly-empty lists and one for nonempty lists).
  Such a definition closely mirrors the Kleene star and plus.
  \begin{equation}
    \begin{aligned}
      A^+ &= \\
          &\left\vert \; \text{head} : A^+ \rightarrow A \right; \\
          &\left\vert \; \text{tail} : A^+ \rightarrow A^\star \right; \\
      A^\star &= \\
          &\left\vert \; [] : A^\star \right; \\
          &\left\vert \; [\cdot] : A^+ \rightarrow A^\star \right;
    \end{aligned}
  \end{equation}
\end{rm-definition}
Our definition of split countability is closed under these types in particular.
\begin{rm-theorem}
  Split countability is closed under Kleene star and plus.
\end{rm-theorem}
\begin{proof}
  \tot[inline]{Proof}
\end{proof}
\subsection{Manifest Countability}
As we can quotient out the position information with finite types, so can we with
countable types.
\todo[inline]{fill in rest here}
\section{Practical Uses} \label{practical}
\todo[inline]{%
\begin{itemize}
  \item Synthesize functions according to specifications.
  \item Nonexhaustive search for the infinite types.
  \item Lift quantifiers over types other than bishop (i.e. K). Show that
    quantifiers have to be different (i.e. existence has to be unique).
  \item Big operators\cite{gustafssonCountingTypeIsomorphisms}
    \cite{gustafssonFoldableContainersDependent}
\end{itemize}
}
The theory of finite types in constructive mathematics, and in HoTT in
particular, is rich and interesting, as we hope we have demonstrated thus far.
As well as being theoretically interesting, however, the proofs and combinators
we have defined here are \emph{practically} useful.
\subsection{Omniscience}
In this section we are interested in restricted forms of the limited principle
of omniscience \cite{myhillErrettBishopFoundations1972}.
\begin{rm-definition}[Limited Principle of Omniscience]
  For any type \(A\) and predicate \(P\) on \(A\), the limited principle of
  omniscience is as follows:
  \begin{equation}
    \left( \prod_{(x : A)} , \mathbf{Dec}(P(x)) \right) \rightarrow \mathbf{Dec} \left( \sum_{(x : A)} , P(x) \right)
  \end{equation}
  In other words, for any decidable predicate the existential quantification of
  that predicate is also decidable.
\end{rm-definition}
The limited principle of omniscience is non-constructive, but individual types
can themselves satisfy omniscience.
In particular, \emph{finite} types are omniscient.
Omniscience is defined in Agda like so:
\ExecuteMetaData[agda/Relation/Nullary/Omniscience.tex]{omniscient}

There is also a universal form of omniscience, which we call exhaustibility.
\begin{rm-definition}[Exhaustibility]
  We say a type \(A\) is exhaustible if, for any decidable predicate \(P\) on
  \(A\), the universal quantification of the predicate is decidable.
  \begin{equation}
    \left( \prod_{(x : A)} , \mathbf{Dec}(P(x)) \right) \rightarrow \mathbf{Dec} \left( \prod_{(x : A)} , P(x) \right)
  \end{equation}
  \ExecuteMetaData[agda/Relation/Nullary/Omniscience.tex]{exhaustible}
\end{rm-definition}
Omniscience is stronger than exhaustibility, as we can derive the latter from
the former:
\begin{rm-lemma} \label{omniscient-is-exhaustible}
  Any omniscient type is exhaustible.
\end{rm-lemma}
\begin{proof}
  \todo[inline]{Proof}
  \ExecuteMetaData[agda/Relation/Nullary/Omniscience.tex]{weaken}
  \todo[noline]{stability in appendix}
\end{proof}
We cannot derive, however, that any exhaustible type is omniscient: to do so
would require us to choose a representative from an arbitrary type, which is not
possible constructively.

\subsubsection{Split Enumerability}
We now show that split enumerable types are omniscient.
\begin{rm-theorem}
  Any split enumerable type is omniscient.
\end{rm-theorem}
\begin{proof}
  Let \(E_A\) be a proof of split enumerability on a type \(A\), and \(P\) be a
  decidable predicate on the type \(A\).
  First, we lift the decidable predicate onto one on lists, using the
  \(\Diamond\) type described earlier.
  Then, we run the predicate on the support list of \(E_A\).

  In the case that it is true for any member of the list, we return that element
  along with its proof.

  If the predicate fails for every member of the list, we say that the whole
  test has failed.
  To support this conclusion, we reason that if a predicate is false for every
  item in a list \(\mathit{xs}\), and some element \(x\) is in that list, then
  the predicate must be false for that item.

  In Agda:
  \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{exists-quant}
\end{proof}
\begin{rm-theorem}
  Any manifestly enumerable type is omniscient.
\end{rm-theorem}
\begin{proof}
  \todo[inline]{Proof}
\end{proof}
\begin{rm-theorem}
  Any cardinal finite type is exhaustible.
\end{rm-theorem}
\begin{proof}
  \todo[inline]{Proof}
\end{proof}
\begin{rm-theorem}
  Cardinally finite types are omniscient about prop-valued predicates.
\end{rm-theorem}
\begin{rm-theorem}
  Kuratowski finite types have the same omniscience properties as cardinal
  finite types.
\end{rm-theorem}

\subsection{Synthesising Pattern-Matching Proofs}
In particular, they can automate large proofs by analysing every possible case.
In \cite{firsovDependentlyTypedProgramming2015}, the \(\AgdaDatatype{Pauli}\)
group is used as an example.
\ExecuteMetaData[agda/Data/Pauli.tex]{def}
For this type, there are several practical tasks we hope to achieve with the
help of our finiteness combinators:
\begin{itemize}
  \item Define decidable equality on the type
  \item Define the group operation on the type
  \item Prove properties about the group operation
\end{itemize}
Unfortunately, the simple pattern-matching way to do many of these tasks is
prohibitively verbose.
As \(\AgdaDatatype{Pauli}\) has 4 constructors, \(n\)-ary functions on
\(\AgdaDatatype{Pauli}\) may require up to \(4^n\) cases.
A proof of decidable equality is one such function: it can be seen fully
worked-through in the appendix.

The alternative is to derive the things we need from \(\Enum\) somehow.
First, then, we need an instance for \(\AgdaDatatype{Pauli}\):
\ExecuteMetaData[agda/Data/Pauli.tex]{inst}
From here we can already derive decidable equality:
\ExecuteMetaData[agda/Data/Pauli.tex]{good-eq}

Next, we want to prove some things about the group operation itself:
\ExecuteMetaData[agda/Data/Pauli.tex]{group-op}
The first property is the following:
\ExecuteMetaData[agda/Data/Pauli.tex]{cancel}
Tough the proof is simple enough to write by hand, it's a good place to start
for demonstrating the automation technique.

First, we will witness the fact that if a property is true for every element in
a finite type's support list, it is true for every element in the type (and vice
versa).
\ExecuteMetaData[agda/Cardinality/Finite/Search.tex]{all-comb}
We can also lift a decidable property on elements of the type to a decidable
property on \emph{lists} of elements of the type.
\ExecuteMetaData[agda/Data/List/Relation/Unary.tex]{dec-all}
Combining these, we can turn a decidable predicate on a set into a decidable
\emph{universal property} on the set.
\ExecuteMetaData[agda/Cardinality/Finite/Search.tex]{lift-forall}

To use this as a proof, we can run the decision procedure at type checking,
using the following:
\ExecuteMetaData[agda/Cardinality/Finite/Search.tex]{auto}
This function uses the \(\AgdaDatatype{True}\) type, defined like so:
\ExecuteMetaData[agda/Relation/Nullary.tex]{true-def}
For a decision \(d\), \(\AgdaDatatype{True}\; d\) will resolve to \(\top\) when
the decision is \(\AgdaInductiveConstructor{yes}\) (i.e. when the proposition is
true), or \(\bot\) if the decision is \(\AgdaInductiveConstructor{no}\).
Then, we require an instance of the resulting type to be in scope: this
requirement can only be satisfied for \(\top\), thereby providing a proof that
the decision was indeed \(\AgdaInductiveConstructor{yes}\).

And finally we can prove the property we wanted to on \(\AgdaDatatype{Pauli}\)
like so:
\ExecuteMetaData[agda/Data/Pauli.tex]{noninst-prf} 

As a quick aside, when the property is \emph{not} true, for instance:
\ExecuteMetaData[agda/Data/Pauli.tex]{contra}
Agda will fail by not finding an instance of \(\bot\).
The error message specifically is:
\begin{displayquote}
  \verb+No instance of type ⊥ was found in scope.+
\end{displayquote}
We can actually display a counterexample, by defining a custom empty type
parameterised by the counterexample itself.
\ExecuteMetaData[agda/Cardinality/Finite/Search.tex]{counterexample-def}
Combined with some other changes to the combinators, this will give the
following more helpful error message:
\begin{displayquote}
  \verb+No instance of type Counterexample X was found in scope.+
\end{displayquote}
\subsection{Instances}
Running decision procedures during typechecking isn't the only use of instances:
we can also use them similarly to how typeclasses are used in Haskell, to
automate simple derivation procedures.
For instance, in Haskell we can define a class for generating textual
representations of data:
\ExecuteMetaData[haskell/Introduction.tex]{show-cls}
With instances that look like this:
\ExecuteMetaData[haskell/Introduction.tex]{show-inst}
We can have instances \emph{depend} on other instances, like the following:
\ExecuteMetaData[haskell/Introduction.tex]{show-deriv}
In this way, it gets rid of a tremendous about of boilerplate for more complex
types, automatically picking out the correct instance when it can.

In Agda, as in Haskell, the problem of overlapping instances often presents
itself when more complex typeclass-based machinery is used.
While there are ways to deal with overlapping instances, it is usually better to
avoid them altogether, which is precisely what we do in our approach.
We provide instances for the semiring-based combinators we defined in
\todo[noline]{reference here}
, and require the user to provide an instance for their own type.
We don't, for example, provide an instance that itself searches for surjections
from other instances: this instance is not uniquely determined.

After all of that, the change to our \(\AgdaFunction{∀↯}\) is simple: we just
change the first parameter from explicit to an instance.
\ExecuteMetaData[agda/Cardinality/Finite/Search.tex]{auto-inst}

The change to the \(\AgdaDatatype{Pauli}\) proof of cancellation isn't
groundbreaking at first:
\ExecuteMetaData[agda/Data/Pauli.tex]{cancel-auto}
But the real benefit is now we can automate proofs over \emph{tuples}, allowing
us to prove, for instance, commutativity.
\ExecuteMetaData[agda/Data/Pauli.tex]{comm-uncurried}
\subsection{Generic Currying and Uncurrying}
While we have arguably removed the bulk of the boilerplate from the automated
proofs, there is still the case of the ugly noise of currying and uncurrying.
In this section, we take inspiration from
\cite{allaisGenericLevelPolymorphic2019} to develop a small interface to generic
\(n\)-ary functions and properties.
What we provide here differs from that work in the following ways:
\begin{itemize}
  \item Our generic representation can handle dependent \(\sum\) and \(\prod\)
    types (rather than their non-dependent counterparts, \(\times\) and
    \(\rightarrow\)).
    This extension was necessary for our use case: it is mentioned in the paper
    as the obvious next step. 
  \item We implement the curry-uncurry combinators as (verified) isomorphisms.
    Since we are in a cubical setting, this gives us equivalences between the
    types, a feature not available in standard Agda.
  \item We deal with implicit and instance arguments generically.
\end{itemize}
A full explanation of our implementation is beyond the scope of this work, but
we will mention the key parts here.
First, we define a function arrow generic over the application method:
\ExecuteMetaData[agda/Data/Product/N-ary.tex]{fun-arr}
Then, we prove that it is isomorphic to the normal function arrow:
\ExecuteMetaData[agda/Data/Product/N-ary.tex]{fun-iso}
This step will allow us to write the curry-uncurry proofs once, and then extend
them to the three different argument forms without difficulty.

We do the same with dependent function types:
\ExecuteMetaData[agda/Data/Product/N-ary.tex]{pi-iso}

Next, we need to make our machinery for multiple arguments.
Here we will define a generic tuple, indexed by some \(\Nat\).
As observed in \cite{allaisGenericLevelPolymorphic2019}, it's important to
\emph{not} implement this as an inductively defined vector, e.g.
\ExecuteMetaData[agda/Data/Vec.tex]{def}
As this will not give us the correct \(\eta\)-equality we need for unification.
\todo[noline]{Stick reference to iterated Vec definition}
Once we have a unification-friendly vector type, we can use it to implement our
generic (and level-polymorphic) tuples.
\ExecuteMetaData[agda/Data/Product/N-ary.tex]{tuple}
We decided against \(\top\)-terminated tuples, as the actual contents of the
tuple type are exposed in the interface.

Finally, we can prove isomorphisms between the curried and uncurried versions of
functions:
\ExecuteMetaData[agda/Data/Product/N-ary.tex]{curry-n-iso}
And dependent functions:
\ExecuteMetaData[agda/Data/Product/N-ary.tex]{curry-n-pi-iso}
With these combinators, we can implement the search functions in an
arity-generic way:
\ExecuteMetaData[agda/Cardinality/Finite/Search.tex]{all-nary}
And automate away our proofs:
\ExecuteMetaData[agda/Data/Pauli.tex]{prf-curried}
\bibliographystyle{splncs04}
\bibliography{bibliography.bib}
\end{document}