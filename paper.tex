\input{preamble}
\acmConference[TyDe 2020]{Workshop on Type-driven Development}{23 Aug
  2020}{Jersey City, USA}

\author{Donnacha Oisín Kidney}
\affiliation{University College Cork}
\email{o.kidney@cs.ucc.ie}
\author{Gregory Provan}
\affiliation{University College Cork}
\email{g.provan@cs.ucc.ie}
\author{Nicolas Wu}
\affiliation{Imperial College London}
\email{n.wu@imperial.ac.uk}

\title{Finiteness in Cubical Type Theory}

\keywords{Agda, Homotopy Type Theory, Cubical Type Theory,
  Dependent Types, Finiteness, Topos, Kuratowski finite}

\begin{abstract}
  We study five different notions of finiteness in Cubical Type Theory and prove
  the relationship between them.
  In particular we show that any totally ordered Kuratowski finite type is
  manifestly Bishop finite.

  We also prove closure properties for each finite type, and classify them
  topos-theoretically.
  This includes a proof that the category of decidable Kuratowski finite sets
  (also called the category of cardinal finite sets) form a \(\Pi\)-pretopos.

  We then develop a parallel classification for the countably infinite types, as
  well as a proof of the countability of \(A^\star\) for a countable type \(A\).

  We formalise our work in Cubical Agda, where we implement a library for proof
  search (including combinators for level-polymorphic fully generic currying).
  Through this library we demonstrate a number of uses for the computational
  content of the univalence axiom, including searching for and synthesising
  functions.
\end{abstract}


\begin{document}
\maketitle
\section{Introduction}
\subsection{Foreword}
In constructive mathematics we are often preoccupied with \emph{why} something
is true.
Take finiteness, for example.
There are a handful of ways to demonstrate some type is finite: we could provide
a surjection to it from another finite type; we could show that any collection
of its elements larger than some bound contains duplicates; or we could show
that any stream of its elements contain duplicates.

Classically, all of these proofs end up proving the same thing: that our type is
finite.
Constructively (in Martin-Löf Type Theory (MLTT)
\cite{martin-lofIntuitionisticTypeTheory1980} at least), however, all three
of the statements above construct a different version of finiteness.
\emph{How} we show that some type is finite has a significant impact on the
type of finiteness we end up dealing with.

Homotopy Type Theory (HoTT) \cite{hottbook} adds another wrinkle to the story.
Firstly, in HoTT we cannot assume that every type is a (homotopy) set: this
means that the finiteness predicates above can be further split into versions
which apply to sets only, and those that apply to all types.
Secondly, HoTT gives us a principled and powerful way to construct quotients,
allowing us to regain some of the flexibility of classical definitions by
``forgetting'' the parts of a proof we would be forced to remember in MLTT.

Finally, for a computer scientist constructive mathematics has one invaluable
feature missing from classical mathematics: computation.
Cubical Type Theory (CuTT) \cite{cohenCubicalTypeTheory2016}, and its
implementation in Cubical Agda \cite{vezzosiCubicalAgdaDependently2019}, realise
this property even in the presence of univalence, giving computational content
to programs written in HoTT.
\subsection{Contributions}
The finiteness predicates we are interested in are organised in
figure~\ref{finite-classification}, and defined in
section~\ref{finiteness-predicates}.
We will explore two aspects of each predicate: its relation to the other
predicates, and its topos-theoretic classification.

\input{figures/finite-classification}

When we say ``relation'' we are referring to the arrows in
figure~\ref{finite-classification}.
In section~\ref{relations} we will provide a function which inhabits each arrow.
Each unlabelled arrow is an unconditional implication: every manifest Bishop
finite set is cardinal finite (lemma~\ref{manifest-bishop-to-cardinal}), for
instance.
The labelled arrows are strengthening proofs: every manifest enumerable set
\emph{with decidable equality} is split enumerable
(lemma~\ref{manifest-enum-to-split-enum}).
Our most significant result here is the proof that a cardinal finite set with a
decidable total order is manifestly Bishop finite.

We will then examine the closure properties of each predicate in
section~\ref{topos}, culminating in a proof that decidable Kuratowski finite
sets form a \(\Pi\)-pretopos (theorem~\ref{finite-topos}).
Our proofs follow the structure of \cite[Chapters 9, 10]{hottbook} and
\cite{rijkeSetsHomotopyType2015}.

After the finite predicates, we will briefly look at the infinite countable
types, and classify them in a parallel way to the finite predicates
(section~\ref{infinite}).

All of our work is formalised in Cubical Agda
\cite{vezzosiCubicalAgdaDependently2019}.
We will make mention of the few occasions where the formalisation of some proof
is of interest, but the main place where we will discuss the code is in
section~\ref{search}, where we implement a library for proof search, based on
omniscience and exhaustibility.
This library relies directly on the computational content of univalence, which
allows us to (for instance) have \(\Pi\) types in the domain of the search
space.

The full code of the formalisation is available at
\url{https://github.com/oisdk/finiteness-in-cubical-type-theory}.
\subsection{Notation and Background}
\subsubsection{Notation}
We work in Cubical Type Theory \cite{cohenCubicalTypeTheory2016}.
For the various type formers we use the following notation:
\begin{description}
  \item[Type] We use \(\mathbf{Type}\) to denote the universe of (small) types.
    ``Type families'' are functions into \(\mathbf{Type}\).
  \item[0 , 1 , 2] We call the \(\mathbf{0}\), \(\mathbf{1}\), and
    \(\mathbf{2}\) types \(\bot\), \(\top\), and \(\mathbf{Bool}\) respectively.
    The single inhabitant of \(\top\) is tt, and the two inhabitants of
    \(\mathbf{Bool}\) are false and true.
    The ``negation'' of a type, written \(\neg A\), means \(A \rightarrow
    \bot\).
  \item[Dependent Sum and Product] We use \(\Sigma\) and \(\Pi\) for the
    dependent sum and product, respectively.
    The two projections from \(\Sigma\) are called fst and snd.
    In the non-dependent case, \(\Sigma\) can be written as \(\times\), and
    \(\Pi\) as \(\rightarrow\).
  \item[Disjoint Union] We define disjoint union as an inductive type.
    \begin{equation}
      \begin{aligned}
        A \uplus B \coloneqq & \;
        \text{inl} &: A \rightarrow A \uplus B \\
        | & \;  \text{inr} &: B \rightarrow A \uplus B
      \end{aligned}
    \end{equation}
    It is also expressible with only \(\Sigma\):
    \(A \uplus B \simeq \Sigma(x : \mathbf{Bool}) , \text{if } x \text{ then
    } A \text{ else } B \).
  \item[Equalities, equivalences, and paths] We use the symbol \(\coloneqq\)
    for definitions.
    \(\simeq\) will be used for equivalences, and \(\equiv\) for equalities.
    Of course, we know that \((A \simeq B) \simeq (A \equiv B)\) by univalence,
    so the distinction isn't terribly important in usage: we will only use one
    or the other as a suggestion of how we constructed it or how it is to be
    used.
\end{description}
\subsubsection{Cubical Type Theory}
Cubical Type Theory \cite{cohenCubicalTypeTheory2016} is a constructive type
theory with an implementation in Cubical Agda
\cite{vezzosiCubicalAgdaDependently2019}.
It allows us to do much of the same theory as in HoTT, but crucially the
univalence ``axiom'' is a \emph{theorem}, giving it computational content.
\begin{romdefinition}[Path Types] \label{path-types}
  The equality type (which we denote with \(\equiv\)) in CuTT is the type of
  Paths\footnotemark.
  The internal structure of paths is largely irrelevant to us here, as we will
  generally treat \(\equiv\) as a black-box equivalence relation with
  substitution and congruence.
\end{romdefinition}

\footnotetext{
  Actually, CuTT does have an identity type with similar semantics to the
  identity type in MLTT.
  We do not use this type anywhere in our work, however, so we will not consider
  it here.
}
\begin{romdefinition}[Homotopy Levels] \label{homotopy-types}
  Types in HoTT and CuTT are not necessarily sets, as they are in MLTT.
  Some have higher homotopies (paths which aren't unique).
  We actually have a hierarchy of complexity of structure of path spaces in
  types, starting with the contractions \cite[definition 3.11.1]{hottbook}, then
  the mere propositions \cite[definition 3.3.1]{hottbook}, and the sets
  \cite[definition 3.1.1]{hottbook}.
  \begin{alignat}{2}
    &\text{isContr}(A)    &&\coloneqq \Sigma(x : A) , \Pi(y : A) , (x \equiv y) \\
    &\text{isProp}(A)     &&\coloneqq \Pi(x, y : A) , (x \equiv y) \\
    &\text{isSet}(A)      &&\coloneqq \Pi(x, y : A) , \text{isProp}(x \equiv y)
  \end{alignat}
\end{romdefinition}
\begin{romdefinition}[Fibres] \label{fibres}
  A fibre \cite[definition 4.2.4]{hottbook} is defined over some function \(f :
  A \rightarrow B\).
  \begin{equation}
    \text{fib}_f(y) \coloneqq \Sigma(x : A) , (f (x) \equiv y)
  \end{equation}
\end{romdefinition}
\begin{romdefinition}[Equivalences] \label{equivalences}
  We will take contractible maps \cite[definition 4.4.1]{hottbook} as our
  ``default'' definition of equivalences.
  \begin{alignat}{2}
    &\text{isEquiv}(f) &&\coloneqq \Pi(y : B) , \text{isContr}(\text{fib}_f(y)) \label{is-equiv-def} \\
    &A \simeq B        &&\coloneqq \Sigma(f : A \rightarrow B) , \text{isEquiv}(f)
  \end{alignat}
\end{romdefinition}
\begin{romdefinition}[Decidable Types]
  \begin{equation}
    \mathbf{Dec}(A) \coloneqq A \uplus \neg A
  \end{equation}
\end{romdefinition}
\begin{romdefinition}[Discrete Types]
  A discrete type is one with decidable equality.
  \begin{equation}
    \text{Discrete}(A) \coloneqq \Pi(x, y : A) , \mathbf{Dec}(x \equiv y)
  \end{equation}
  By Hedberg's theorem \cite{hedbergCoherenceTheoremMartinLof1998} any discrete
  type is a set.
\end{romdefinition}
\begin{romdefinition}[Higher Inductive Types] \label{HITs}
  Normal inductive types have \emph{point} constructors: constructors which
  construct values of the type.
  Higher Inductive Types (HITs) also have \emph{path} constructors: ways to
  construct paths in the type.
\end{romdefinition}
\begin{romdefinition}[Propositional Truncation] \label{prop-trunc}
  The type \(\lVert A \rVert\) on some type \(A\) is a propositionally truncated
  proof of \(A\) \cite[3.7]{hottbook}.
  In other words, it is a proof that some \(A\) exists, but it does not tell you
  \emph{which} \(A\).

  It is defined as a Higher Inductive Type:
  \begin{equation} {
    \begin{alignat*}{3}
      \lVert A \rVert \coloneqq & \; \lvert \wc \rvert &&: A \rightarrow \lVert A \rVert ; \\
                              | & \; \text{squash}     &&: \Pi {(x, y : \lVert A \rVert)} , x \equiv y  ; 
    \end{alignat*} }
  \end{equation}
  We will use two eliminators from \(\lVert A \rVert\) in this paper.
  \begin{enumerate}
  \item \label{elim-prop-prop} For any function \(A \rightarrow B\), where
    \(\text{isProp}(B)\), we have a function \(\lVert A \rVert \rightarrow B\).
  \item \label{elim-prop-coh} We can eliminate from \(\lVert A \rVert\) with a
    function \(f : A \rightarrow B\) iff \(f\) ``doesn't care'' about the
    choice of \(A\) (\(\Pi {(x , y : A)} , f(x) \equiv f(y) \)).
    Formally speaking, \(f\) needs to be ``coherently constant''
    \cite{krausGeneralUniversalProperty2015}, and \(B\) needs to be an
    \(n\)-type for some finite \(n\).
  \end{enumerate}
\end{romdefinition}
\section{Finiteness Predicates} \label{finiteness-predicates}
In this section, we will define and briefly describe each of the five predicates
in Figure~\ref{finite-classification}.
The reason we explore predicates other than our focus (decidable Kuratowski
finiteness) is that we can often prove things like closure much more readily on
the simpler predicates.
The relations (which we will prove in the next section) then allow us to
transfer those proofs.
\subsection{Split Enumerability}
\begin{romdefinition}[Split Enumerable Set] \label{split-enum-def}
  \begin{equation} \label{split-enum-def-eqn}
    \mathcal{E}!(A) \coloneqq \Sigma {(\mathit{xs} : \textbf{List}(A))} , \Pi {(x : A)} , x \in \mathit{xs}
  \end{equation}
  We call the first component of this pair the ``support'' list, and the second
  component the ``cover'' proof.
  An equivalent version of this predicate was called \verb+Listable+ in
  \cite{firsovDependentlyTypedProgramming2015}.
\end{romdefinition}

We used some extra types in the above definition, which we will define here:
\begin{romdefinition}[Containers] \label{container-def}
  A container \cite{abbottContainersConstructingStrictly2005} is a pair
  \(S , P\) where \(S\) is a type, the elements of which are called
  the \emph{shapes} of the container, and \(P\) is a type family on \(S\), where
  the elements of \(P(s)\) are called the \emph{positions} of a container.
  We ``interpret'' a container into a functor defined like so:
  \begin{equation} \label{container-interp}
    \llbracket S , P \rrbracket(A) \coloneqq \Sigma {(s : S)} , \left( P(s) \rightarrow A \right)
  \end{equation}
  Membership of a container can be defined like so:
  \begin{equation} \label{container-membership}
    x \in \mathit{xs} \coloneqq \text{fib}_{\text{snd}(\mathit{xs})}(x)
  \end{equation}
\end{romdefinition}
\begin{romdefinition}[\(\mathbf{List}\)] \label{List}
  \begin{equation}
    \mathbf{List} \coloneqq \llbracket \mathbb{N} , \mathbf{Fin} \rrbracket
  \end{equation}
\end{romdefinition}
\begin{romdefinition}[\(\mathbf{Fin}\)] \label{Fin}
  \(\mathbf{Fin}(n)\) is the type of natural numbers smaller than \(n\). We
  define it the standard way, where \(\mathbf{Fin}(0) \coloneqq \bot\) and
  \(\mathbf{Fin}(n + 1) &\coloneqq \top \uplus \mathbf{Fin}(n)\).
\end{romdefinition}

We tend to prefer list-based definitions of finiteness, rather than ones based
on bijections or surjections.
This is purely a matter of perspective, however: the definition above is
precisely equivalent to a split surjection from a finite prefix of the natural
numbers.
\begin{romdefinition}[Surjections] \label{surjections}
  We define both surjections and \emph{split} surjections here \cite[definition
  4.6.1]{hottbook}.
  \begin{alignat}{3}
    &\text{surj}(f)             &&\coloneqq \Pi(y : B) , \lVert \text{fib}_f(y) \rVert \\
    &A \twoheadrightarrow B     &&\coloneqq \Sigma (f : A \rightarrow B) , \text{surj}(f) \label{surj-arrow-eqn} \\
    &\text{sp-surj}(f)          &&\coloneqq \Pi(y : B) , \text{fib}_f(y) \label{sp-surj-eqn} \\
    &A \twoheadrightarrow! \; B &&\coloneqq \Sigma (f : A \rightarrow B) , \text{sp-surj}(f) \label{sp-surj-arrow-eqn}
  \end{alignat}
\end{romdefinition}
\begin{romlemma} \label{split-enum-is-split-surj}
  \begin{equation}
    \mathcal{E}!(A) \simeq \Sigma (n : \mathbb{N}) , \left( \mathbf{Fin}(n) \twoheadrightarrow ! \; A \right)
  \end{equation}
\end{romlemma}
\begin{proof}
  \begin{align*}
    \mathcal{E}!(A)
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , x \in \mathit{xs}
    && \text{def.~\ref{split-enum-def} }(\mathcal{E}!)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \text{fib}_{\text{snd}(\mathit{xs})}(x)
    && \text{eqn.~\ref{container-membership} } (\in)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \text{sp-surj}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{sp-surj-eqn} (sp-surj)}
    \\
    & \simeq \Sigma (\mathit{xs} : \llbracket \mathbb{N} , \mathbf{Fin} \rrbracket (A)) , \text{sp-surj}(\text{snd}(\mathit{xs}))
    && \text{def.~\ref{List} } (\mathbf{List})
    \\
    & \simeq \Sigma (\mathit{xs} : \Sigma (n : \mathbb{N}) , \Pi (i : \mathbf{Fin}(n)) , A) , \text{sp-surj}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{container-interp} } (\llbracket \wc \rrbracket)
    \\
    & \simeq \Sigma (n : \mathbb{N}) , \Sigma (f : \mathbf{Fin}(n) \rightarrow A) , \text{sp-surj}(f)
    && \text{Reassociation of } \Sigma
    \\
    & \simeq \Sigma (n : \mathbb{N}) , ( \mathbf{Fin}(n) \twoheadrightarrow ! \; A )
    && \text{eqn.~\ref{sp-surj-arrow-eqn} } (\twoheadrightarrow!)
  \end{align*}
  \qed
\end{proof}

In our formalisation, the proof is a single line: most of the steps above are
simple expansion of definitions.
The only step which isn't definitional equality is the reassociation of
\(\Sigma\).

Split enumerability implies decidable equality on the underlying type.
To prove this, we will make use of the following lemma, proven in the
formalisation:
\begin{romlemma} \label{discrete-surj}
  \begin{equation}
    \frac{
        A \twoheadrightarrow! \; B \; \; \; \text{Discrete}(A)
      }{
       \text{Discrete}(B) 
      }
  \end{equation}
\end{romlemma}
\begin{romlemma} \label{split-enum-discrete}
  Every split enumerable type is discrete.
\end{romlemma}
\begin{proof}
  Let \(A\) be a split enumerable type.
  By lemma~\ref{split-enum-is-split-surj}, there is a surjection from
  \(\mathbf{Fin}(n)\) for some \(n\).
  Also, we know that \(\mathbf{Fin}(n)\) is discrete (proven in our
  formalisation).
  Therefore, by lemma~\ref{discrete-surj}, \(A\) is discrete.
  \qed
\end{proof}
\subsection{Manifest Bishop Finiteness}
\begin{romdefinition}[Manifest Bishop Finiteness]
  \begin{equation} \label{bish-def}
    \mathcal{B}(A) \coloneqq \Sigma {(\mathit{xs} : \textbf{List}(A))} , \Pi {(x : A)} , x \inunique xs
  \end{equation}
\end{romdefinition}
The only difference between manifest Bishop finiteness and split enumerability
is the membership term: here we require unique membership (\(\inunique\)),
rather than simple membership (\(\in\)).
\begin{romdefinition}[Unique Membership] \label{uniq-memb-def}
  \begin{equation}
    x \inunique \mathit{xs} \coloneqq \text{isContr}(x \in \mathit{xs})
  \end{equation}
\end{romdefinition}

We use the word ``manifest'' here to distinguish from another common
interpretation of Bishop finiteness, which we have called cardinal finiteness in
this paper.
The ``manifest'' refers to the fact that we have a concrete, non-truncated list
of the elements in the proof.

Where split enumerability was the enumeration form of a split surjection from
\(\mathbf{Fin}\), manifest Bishop finiteness is the enumeration form of an
\emph{equivalence} with \(\mathbf{Fin}\).
\begin{romlemma} \label{bishop-equiv}
  \begin{equation}
    \mathcal{B}(A) \simeq \Sigma {(n : \mathbb{N})} , \left( \mathbf{Fin}(n) \simeq A \right)
  \end{equation}
\end{romlemma}
This proof is effectively the same as that of
lemma~\ref{split-enum-is-split-surj}.
\subsection{Cardinal Finiteness}
Each finiteness predicate so far has contained an \emph{ordering} of the
underlying type.
For our purposes, this is too much information: it means that when constructing
the ``category of finite sets'' later on, instead of each type having one
canonical representative, it will have \(n!\), where \(n\) is the cardinality of
the type\footnotemark.

\footnotetext{
  We actually do get a category (a groupoid, even) from manifest Bishop
  finiteness \cite{yorgeyCombinatorialSpeciesLabelled2014}: it's the groupoid of
  finite sets equipped with a linear order, whose morphisms are order-preserving
  bijections.
  We do not explore this particular construction in any detail.
}

To remedy the problem, we will use propositional truncation
(def.~\ref{prop-trunc}).
\begin{romdefinition}[Cardinal Finiteness]
  \begin{equation}
    \mathcal{C}(A) \coloneqq \lVert \mathcal{B}(A) \rVert \simeq \lVert \Sigma(n : \mathbb{N}) , (\mathbf{Fin}(n) \simeq A) \rVert
  \end{equation}
\end{romdefinition}
At first glance, it might seem that we lose any useful properties we could
derive from \(\mathcal{B}\).
Luckily, this is not the case: by eliminator \ref{elim-prop-coh} of
def.~\ref{prop-trunc}, we need only show that the output is uniquely determined.

The following two lemmas are proven in
\cite{yorgeyCombinatorialSpeciesLabelled2014} (Proposition 2.4.9 and 2.4.10,
respectively), in much the same way as we have done here.
Our contribution for this section is simply the formalisation.
\begin{romlemma}
  Given a cardinally finite type, we can derive the type's cardinality, as well
  as a propositionally truncated proof of equivalence with \(\textbf{Fin}\)s of
  the same cardinality.
  \begin{equation}
    \mathcal{C}(A) \rightarrow \Sigma {(n : \mathbb{N})} , \lVert \textbf{Fin}(n) \simeq A \rVert
  \end{equation}
\end{romlemma}
\begin{romlemma} \label{cardinal-finite-discrete}
  Any cardinal-finite set has decidable equality.
\end{romlemma}
\subsection{Manifest Enumerability}
\begin{romdefinition}[Manifest Enumerability]
  \begin{equation}
    \mathcal{E}(A) \coloneqq \Sigma {(\mathit{xs} : \mathbf{List}(A))} , \Pi {(x : A)} , \lVert x \in \mathit{xs} \rVert
  \end{equation}
\end{romdefinition}
As with manifest Bishop finiteness, the only difference with this type and split
enumerability is the membership proof: here we have propositionally truncated
it.
This has two effects.
First, it means that this proof represents a true surjection (rather than a
split surjection) from \(\mathbf{Fin}\).
\begin{romlemma}
  \begin{equation}
    \mathcal{E}(A) \simeq \Sigma(n : \mathbb{N}) , (\mathbf{Fin}(n) \twoheadrightarrow A)
  \end{equation}
\end{romlemma}
The proof for this lemma is similar in structure to
lemma~\ref{split-enum-is-split-surj} and lemma~\ref{bishop-equiv}.

Secondly, it means the predicate does not imply decidable equality.
More significantly, it allows the predicate to be defined over non-set types,
like the circle.
\begin{romdefinition}[\(S^1\)] \label{circle-def}
  The circle, \(S^1\), can be represented in HoTT as a higher inductive type.
  \begin{equation}
    \begin{alignat}{5}
      S^1 \coloneqq & \; \text{base} &&: S^1 ; \\
      | & \; \text{loop} &&: \text{base} \equiv \text{base} ; 
    \end{alignat}
  \end{equation}
  We will use it here as an example of a non-set type, i.e. a type for which not
  all paths are equal.
  This also means that it does not have decidable equality.
\end{romdefinition}
\begin{romlemma}
  The circle \(S^1\) is manifestly enumerable.
\end{romlemma}
\subsection{Kuratowski Finiteness}
The first thing we must define is a representation of subsets.
\begin{romdefinition}[Kuratowski Finite Subset]
  \(\mathcal{K}(A)\) is the type of Kuratowski-finite subsets of \(A\).
  \begin{equation}
    \begin{alignat}{2}
      \mathcal{K}(A) \coloneqq&
             \; []                &&: \mathcal{K}(A) ; \\
      \vert& \; \wc \dblcolon \wc &&: A \rightarrow \mathcal{K}(A) \rightarrow \mathcal{K}(A) ; \\
      \vert& \; \text{com}        &&: \Pi (x, y: A) , \Pi (\mathit{xs} : \mathcal{K}(A)) , x \dblcolon y \dblcolon \mathit{xs} \equiv y \dblcolon x \dblcolon \mathit{xs} ; \\
      \vert& \; \text{dup}        &&: \Pi (x : A) , \Pi (\mathit{xs} : \mathcal{K}(A)) , x \dblcolon x \dblcolon \mathit{xs} \equiv x \dblcolon \mathit{xs} ; \\
      \vert& \; \text{trunc}      &&: \Pi (\mathit{xs}, \mathit{ys}: \mathcal{K}(A)) , \Pi (p, q : \mathit{xs} \equiv \mathit{ys}) , p \equiv q ;
    \end{alignat}
  \end{equation}
  We define it as a HIT (definition~\ref{HITs}).
  The first two constructors are point constructors, giving ways to create
  values of type \(\mathcal{K}(A)\).
  They are also recognisable as the two constructors for finite lists, a type
  which represents the free monoid.

  The next two constructors add extra paths to the type: equations that usage of
  the type must obey.
  These extra paths turn the free monoid into the free \emph{commutative} (com)
  \emph{idempotent} (dup) monoid.

  The final constructor enforces that the type \(\mathcal{K}(A)\) must be a set.
\end{romdefinition}
The Kuratowski finite subset is a free join semilattice (or, equivalently, a
free commutative idempotent monoid).
More prosaically, \(\mathcal{K}\) is the abstract data type for finite sets, as
defined in the Boom hierarchy \cite{boomFurtherThoughtsAbstracto1981,
  bunkenburgBoomHierarchy1994}.
However, rather than just being a specification, \(\mathcal{K}\) is fully usable
as a data type in its own right, thanks to HITs.

Other definitions of \(\mathcal{K}\) exist (such as the one in
\cite{fruminFiniteSetsHomotopy2018}) which make the fact that \(\mathcal{K}\) is
the free join semilattice more obvious.
We have included such a definition in our formalisation, and proven it
equivalent to the one above.

Next, we need a way to say that an entire type is Kuratowski finite.
For that, we will need to define membership of \(\mathcal{K}\).
\begin{romdefinition}[Membership of \(\mathcal{K}\)]
  Membership is defined by pattern-matching on \(\mathcal{K}\).
  The two point constructors are handled like so:
  \begin{equation}
    \begin{alignedat}{2}
      x \in&& \; []                      &\coloneqq \bot \\
      x \in&& \; y \dblcolon \mathit{ys} &\coloneqq \lVert x \equiv y \uplus x \in \mathit{ys} \rVert
    \end{alignedat}
  \end{equation}
  The \(\text{com}\) and \(\text{dup}\) constructors are handled by proving that
  the truncated form of \(\uplus\) is itself commutative and idempotent.
  The type of propositions is itself a set, satisfying the \(\text{trunc}\)
  constructor.
\end{romdefinition}
Finally, we have enough background to define Kuratowski finiteness.
\begin{romdefinition}[Kuratowski Finiteness]
  \begin{equation}
    \mathcal{K}^{f}(A) = \Sigma {(\mathit{xs} : \mathcal{K}(A))} , \Pi (x : A) , x \in \mathit{xs}
  \end{equation}
\end{romdefinition}

We also have the following two lemmas, proven in both
\cite{fruminFiniteSetsHomotopy2018} and our formalisation.
\begin{romlemma}
  \(\mathcal{K}^f\) is a mere proposition.
\end{romlemma}
\begin{romlemma}
  This circle \(S^1\) is Kuratowski finite.
\end{romlemma}
\section{Relations Between Each Finiteness Definition} \label{relations}
We will now look at the arrows in figure~\ref{finite-classification}.
\subsection{Split Enumerability and Manifest Bishop Finiteness}
While manifest Bishop finiteness might seem stronger than split enumerability,
it turns out this is not the case.
Both predicates imply the other.
\begin{romlemma} \label{manifest-bishop-to-split-enum}
  Any manifest Bishop finite type is split enumerable.
\end{romlemma}
\begin{proof}
  To construct a proof of split enumerability from one of manifest Bishop
  finiteness, it suffices to convert a proof of \(x \inunique \mathit{xs}\) to
  one of \(x \in \mathit{xs}\), for all \(x\) and \(\mathit{xs}\).
  Since \(\inunique\) is defined as a contraction of \(\in\), such a conversion
  is simply the \(\text{fst}\) function.
  \qed
\end{proof}

\begin{romlemma} \label{split-enum-to-manifest-bishop}
  Any split enumerable set is manifest Bishop finite.
\end{romlemma}
This proof takes significantly more work.
The ``unique membership'' condition in \(\mathcal{B}\) means that we are not
permitted duplicates in the support list.
The first step in the proof, then, is to filter those duplicates out from the
support list of the \(\mathcal{E}!\) proof: we can do this using the decidable
equality provided by \(\mathcal{E}!\) (lemma~\ref{split-enum-discrete}).
From there, all we need to show is that the membership proof carries over
appropriately.
\subsection{Split Enumerability and Manifest Enumerability}
\begin{romlemma} \label{split-enum-to-manifest-enum}
  Any split enumerable type is manifestly enumerable.
\end{romlemma}
This lemma is proven by truncating the membership proof in split enumerability.

\begin{romlemma} \label{manifest-enum-to-split-enum}
  A manifestly enumerable type with decidable equality is split enumerable.
\end{romlemma}

\subsection{Manifest Bishop Finiteness and Cardinal Finiteness}
\begin{romlemma} \label{manifest-bishop-to-cardinal}
  Any manifest Bishop finite type is cardinal finite.
\end{romlemma}
\begin{romtheorem} \label{cardinal-to-manifest-bishop}
  Any cardinal finite type with a total order is Bishop finite.
\end{romtheorem}
The proof for this particular theorem is quite involved in the formalisation, so
we only give its sketch here.
First, note that we actually convert to manifest enumerability first: this can
be converted to split enumerability with decidable equality, which is provided
by cardinal finiteness.

Next, we define permutations.
\begin{romdefinition}[List Permutations]
  Two lists are permutations of each other if their membership proofs are all
  equivalent\footnotemark \cite{danielssonBagEquivalenceProofRelevant2012}.
  \begin{equation}
    \mathit{xs} \leftrightsquigarrow \mathit{ys} = \Pi {(x : A)} , x \in \mathit{xs} \simeq x \in \mathit{ys}
  \end{equation}
\end{romdefinition}

\footnotetext{
  The definition in \cite{danielssonBagEquivalenceProofRelevant2012} and our
  formalisation is slightly different: we say permutations are lists with
  \emph{isomorphic} membership proofs.
  The distinction, as it happens, does not affect our work here.
}

Next, we define a sort function which relies on the provided total order.
We further prove the following fact about this sort function:
\begin{equation}
  \Pi(\mathit{xs}, \mathit{ys} : \mathbf{List}(A)) , \mathit{xs} \leftrightsquigarrow \mathit{ys} \rightarrow \text{sort}(\mathit{xs}) \equiv \text{sort}(\mathit{ys})
\end{equation}

Next, notice that the support lists of any two proofs of manifest Bishop
finiteness must be permutations of each other.
This will allow us to sort the support list of a proof of cardinal finiteness in
a coherently constant (definition~\ref{prop-trunc},
eliminator~\ref{elim-prop-coh}) way, pulling the support list out from the
truncation.
The cover proof emerges naturally from the definition of the permutation.
\subsection{Cardinal Finiteness and Kuratowski Finiteness}
\begin{romlemma} \label{cardinal-kuratowski}
  \begin{equation}
    \mathcal{C}(A) \simeq \mathcal{K}^f(A) \times \text{Discrete}(A)
  \end{equation}
\end{romlemma}
This proof is constructed by providing a pair of functions: one from
\(\mathcal{C}(A)\) to \(\mathcal{K}^f(A) \times \text{Discrete}(A)\), and one the
other way.
This pair implies an equivalence, because both source and target are
propositions.
The actual functions themselves are proven in our formalisation, as well as in
\cite{fruminFiniteSetsHomotopy2018}.
\section{Topos} \label{topos}
In this section we will prove that decidable Kuratowski finite types form a
\(\Pi\)-pretopos.
Along the way we will provide closure proofs for a number of the other
finiteness predicates.
As we saw in theorem~\ref{cardinal-kuratowski}, decidable Kuratowski finite
types are equivalent to cardinal finite types, so we will work with the latter
from now on.
Our first task is to show that cardinal finite types are closed under several
operations.
\subsection{Closure}
For the first three closure proofs, we only consider split enumerability:
as it is the strongest of the finiteness predicates, we can derive the other
closure proofs from it.

\begin{romlemma}
  \(\bot\), \(\top\), and \(\mathbf{Bool}\) are split enumerable.
\end{romlemma}
\begin{romlemma} \label{split-enum-sigma}
  Split enumerability is closed under \(\Sigma\).
  \begin{equation}
    \frac{
      \mathcal{E}!(A) \; \; \; \Pi(x : A) , \mathcal{E}!(U(x))
    }{
      \mathcal{E}!(\Sigma(x : A) , U(x))
    }
  \end{equation}
\end{romlemma}
From this we can derive split enumerability of non-dependent sums and products,
as both are definable in terms of \(\Sigma\).

\begin{romlemma}
  Split enumerability is closed under dependent functions.
  (\(\Pi\)-types).
  \begin{equation}
    \frac{
      \mathcal{E}!(A) \; \; \; \Pi {(x : A)} , \mathcal{E}!\left( U(x) \right)
    }{
      \mathcal{E}!\left(\Pi {(x : A)} , U(x)\right)
    }
  \end{equation}
\end{romlemma}
\begin{proof}
  Let \(A\) be a split enumerable type, and \(U\) be a type family from \(A\),
  which is split enumerable over all points of \(A\).

  As \(A\) is split enumerable, we know that it is also manifestly Bishop finite
  (lemma~\ref{split-enum-to-manifest-bishop}), and consequently we know \(A
  \simeq \mathbf{Fin}(n)\), for some \(n\) (lemma~\ref{bishop-equiv}).
  We can therefore replace all occurrences of \(A\) with \(\mathbf{Fin}(n)\),
  changing our goal to:
  \begin{equation}
    \frac{
      \mathcal{E}!(\mathbf{Fin}(n)) \; \; \; \Pi (x : \mathbf{Fin}(n)) , \mathcal{E}!\left( U(x) \right)
    }{
      \mathcal{E}!\left(\Pi (x : \mathbf{Fin}(n)) , U(x)\right)
    }
  \end{equation}
  
  We then define the type of \(n\)-tuples over some type family \(T :
  \mathbf{Fin}(n) \rightarrow \mathbf{Type}\).
  \begin{equation}
    \begin{alignat}{3}
      & \mathbf{Tuple}(0, T)   &&\coloneqq \top \\
      & \mathbf{Tuple}(n+1, T) &&\coloneqq T(0) \times \mathbf{Tuple}(n, T \circ \text{suc})
    \end{alignat}
  \end{equation}
  We can show that this type is equivalent to functions (proven in our formalisation):
  \begin{equation}
    \Pi(x : \mathbf{Fin}(n)) , U(x) \simeq \mathbf{Tuple}(n, U)
  \end{equation}
  And therefore we can simplify again our goal to the following:
  \begin{equation}
    \frac{
      \mathcal{E}!(\mathbf{Fin}(n)) \; \; \; \Pi (x : \mathbf{Fin}(n)) , \mathcal{E}!\left( U(x) \right)
    }{
      \mathcal{E}!\left(\mathbf{Tuple}(n, U)\right)
    }
  \end{equation}
  
  We can prove this goal by showing that \(\mathbf{Tuple}(n, U)\) is split
  enumerable: it is made up of finitely many products of points of \(U\), which
  are themselves split enumerable, and \(\top\), which is also split enumerable.
  Lemma~\ref{split-enum-sigma} shows us that the product of finitely many split
  enumerable types is itself split enumerable, proving our goal.
  \qed
\end{proof}

Lifting the above closure proofs to work on proofs of \(\mathcal{C}\) is not
necessarily straightforward.
\(\lVert \wc \rVert\) forms a monad, giving us access to a powerful syntax for
combining proofs.
From this, we can derive closure under \(\bot\), \(\top\), \(\mathbf{Bool}\),
\(\times\), \(\uplus\), and \(\rightarrow\).
The dependent case is not so straightforward.
We need the following lemma, a version of the axiom of choice on finite sets,
to prove closure under \(\Sigma\) and \(\Pi\).
\begin{romlemma}
  \begin{equation}
    \mathcal{C}(A) \rightarrow (\Pi(x : A) , \lVert U(x) \rVert) \rightarrow \lVert \Pi(x : A) , U(x) \rVert
  \end{equation}
\end{romlemma}
\subsection{The Category of Finite Sets}
HoTT and CuTT seem to be especially suitable settings for formalisations of
category theory.
The univalence axiom in particular allows us to treat categorical isomorphisms
as equalities, saving us from the dreaded ``setoid hell''.

We follow \cite[chapter 9]{hottbook} in its treatment of
categories in HoTT, and in its proof that sets do indeed form a category.
We will first briefly go through the construction of the category
\(\mathit{Set}\), as it differs slightly from the usual method in type theory.

First, the type of objects and arrows:
\begin{alignat}{3}
  &\text{Obj}_\mathit{Set}      &&\coloneqq \Sigma(x : \mathbf{Type}) , \text{isSet}(x) \\
  &\text{Hom}_\mathit{Set}(x , y) &&\coloneqq  \text{fst}(x) \rightarrow \text{fst}(y)
\end{alignat}
As the type of objects makes clear, we have already departed slightly from the
simpler \(\text{Obj}_\mathit{Set} \coloneqq \mathbf{Type}\) way of doing things:
of course we have to, as HoTT allows non-set types.
Furthermore, after proving the usual associativity and identity laws for
composition (which are definitionally true in this case), we must further show
\(\text{isSet}(\text{Hom}_\mathit{Set}(x,y))\); even then we only have a
precategory.

To show that \(\mathit{Set}\) is a category, we must show that categorical
isomorphisms are equivalent to equivalences.
In a sense, we must give a univalence rule for the category we are working in.

We have provided formal proofs that \(\mathit{Set}\) does indeed form a
category, and the following:
\begin{romtheorem}[The Category of Finite Sets]
  Finite sets form a category in HoTT when defined like so:
  \begin{equation}
    \begin{aligned}
      &\text{Obj}_\mathit{FinSet}      &&\coloneqq \Sigma(x : \mathbf{Type}) , \mathcal{C}(x) \\
      &\text{Hom}_\mathit{FinSet}(x , y) &&\coloneqq  \text{fst}(x) \rightarrow \text{fst}(y)
    \end{aligned}
  \end{equation}
\end{romtheorem}
\subsection{The \(\Pi\)-pretopos of Finite Sets}
For this proof, we follow again the proof that \(\mathit{Set}\) forms a \(\Pi
W\)-pretopos from \cite[chapter 10]{hottbook} and
\cite{rijkeSetsHomotopyType2015}.
The difference here is that clearly we do not have access to \(W\)-types, as
they would permit infinitary structures.

We first must show that \(\mathit{Set}\) has an initial object and finite,
disjoint sums, which are stable under pullback.
We also must show that \(\mathit{Set}\) is a regular category with effective
quotients.
We now have a pretopos: the presence of \(\Pi\) types make it a
\(\Pi\)-pretopos.

We have proven the above statements for both \(\mathit{Set}\) and
\(\mathit{FinSet}\).
As far as we know, this is the first formalisation of either.
\begin{romtheorem} \label{finite-topos}
  The category of finite sets, \(\mathit{FinSet}\), forms a \(\Pi\)-pretopos.
\end{romtheorem}
\section{Countably Infinite Types} \label{infinite}
In the previous sections we saw different flavours of finiteness which were
really just different flavours of relations to \(\mathbf{Fin}\).
In this section we will see that we can construct a similar classification of
relations to \(\mathbb{N}\), in the form of the countably infinite types.
\subsection{Two Countable Types}
The two types for countability we will consider are analogous to split
enumerability and cardinal finiteness.
The change will be a simple one: we will swap out lists for streams.
\begin{romdefinition}[Streams]
  \begin{equation}
    \mathbf{Stream}(A) \coloneqq (\mathbb{N} \rightarrow A)
    \simeq \llbracket \top , \text{const}(\mathbb{N}) \rrbracket
  \end{equation}
\end{romdefinition}
\begin{romdefinition}[Split Countability]
  \begin{equation}
    \mathcal{E}!(A) \coloneqq \Sigma {(\mathit{xs} : \mathbf{Stream}(A))} , \Pi {(x : A)} , x \in \mathit{xs}
  \end{equation}
\end{romdefinition}
This type is definitionally equal to it surjection equivalent (\(\mathbb{N}
\twoheadrightarrow ! \; A\)).
We construct the unordered, propositional version of the predicate in much the
same way as we constructed cardinal finiteness.
\begin{romdefinition}[Countability]
  \begin{equation}
    \mathcal{E}(A) \coloneqq \lVert \mathcal{E}!(A) \rVert
  \end{equation}
\end{romdefinition}

From both of these types we can derive decidable equality.
\begin{romlemma}
  Any countable type has decidable equality.
\end{romlemma}
\subsection{Closure}
We know that countable infinity is not closed under the exponential (function
arrow), so the only closure we need to prove is \(\Sigma\) to cover all of
what's left.
\begin{romtheorem} \label{split-countability-sigma}
  Split countability is closed under \(\Sigma\).
\end{romtheorem}
This proof does not mirror the proof of \(\Sigma\) closure on finite types.
The pattern we used to pair up the relevant support lists for the finite types
would diverge for infinite types: instead, we need a \emph{pairing} function.

Finally, while we have lost certain closure proofs by allowing for infinite
types, we also \emph{gain} some: in particular the Kleene star.
\begin{romtheorem}
  Split countability is closed under Kleene star.
  \begin{equation}
    \mathcal{E}!(A) \rightarrow \mathcal{E}!(\mathbf{List}(A))
  \end{equation}
\end{romtheorem}
Again, this proof requires a particular pattern to ensure productivity.
The pattern here builds an intermediate stream \(\mathcal{KV}\) of non-empty
lists from the input support stream \(\mathit{xs}\), which is subsequently
flattened.
\begin{equation}
  \mathcal{KV}_i \coloneqq \left[ \left[ \mathit{xs}_{j - 1} \mid j \in \mathit{js} \right] \mid \mathit{js} \in \mathbf{List}(\mathbb{N}) ; \text{sum}(\mathit{js}) = i ; 0 \notin \mathit{js}  \right]
\end{equation}
\section{Search} \label{search}
\subsection{Omniscience}
\begin{romdefinition}[Limited Principle of Omniscience]
  For any type \(A\) and predicate \(P\) on \(A\), the limited principle of
  omniscience \cite{myhillErrettBishopFoundations1972} is as follows:
  \begin{equation}
    \left( \Pi {(x : A)} , \mathbf{Dec}(P(x)) \right) \rightarrow \mathbf{Dec} \left( \Sigma {(x : A)} , P(x) \right)
  \end{equation}
  In other words, for any decidable predicate the existential quantification of
  that predicate is also decidable.
\end{romdefinition}
The limited principle of omniscience is non-constructive, but individual types
can themselves satisfy omniscience.
In particular, cardinal finite types are omniscient.

There is also a universal form of omniscience, which we call exhaustibility.
\begin{romdefinition}[Exhaustibility]
  We say a type \(A\) is exhaustible if, for any decidable predicate \(P\) on
  \(A\), the universal quantification of the predicate is decidable.
  \begin{equation}
    \left( \Pi {(x : A)} , \mathbf{Dec}(P(x)) \right) \rightarrow \mathbf{Dec} \left( \Pi {(x : A)} , P(x) \right)
  \end{equation}
\end{romdefinition}

All of the finiteness predicates we have seen imply exhaustibility.
Omniscience is stronger than exhaustibility, as we can derive the latter from
the former.
All of the ordered finiteness predicates imply omniscience.
For the unordered finiteness definitions, we have omniscience for prop-valued
predicates.
\subsection{Automating Proofs}
One use for above constructions is the automation of certain proofs.
In \cite{firsovDependentlyTypedProgramming2015}, which uses a similar approach
to ours, the \(\AgdaDatatype{Pauli}\) group is used as an example.
\ExecuteMetaData[agda/Data/Pauli.tex]{def}
As \(\AgdaDatatype{Pauli}\) has 4 constructors, \(n\)-ary functions on
\(\AgdaDatatype{Pauli}\) may require up to \(4^n\) cases, making even simple
proofs prohibitively verbose.

The alternative is to derive the things we need from omniscience, itself derived
from a finiteness predicate.
For proof search, the procedure is a well-known one in Agda
\cite{devrieseBrightSideType2011}: we ask for the result of a decision procedure
as an \emph{instance argument}, which will demand computation during
typechecking.
Our addition to this technique is a way to handle multiple arguments based on
fully level-polymorphic dependent currying and uncurrying, building on 
\cite{allaisGenericLevelPolymorphic2019}.
\ExecuteMetaData[agda/Data/Pauli.tex]{assoc-prf}

Finally, we can derive decidable equality on functions over finite types.
We can also use functions in our proof search.
Here, for instance, is an automated procedure which finds the
\(\AgdaFunction{not}\) function on \(\mathbf{Bool}\), given a specification.
\ExecuteMetaData[agda/Data/Pauli.tex]{not-spec}
\section{Related Work}
The univalent foundations program is the main basis for this work
\cite{hottbook}.
In particular, our formalisation in section~\ref{topos} relied heavily on
\cite[chapter 10]{hottbook}, and \cite{rijkeSetsHomotopyType2015}, a paper which
contains much of the same material.

Finite sets in a constructive setting has been studied extensively before:
In \cite{coquandConstructivelyFinite2010} four separate predicates for
finiteness were considered (split-enumerable being the only one explored in this
work), and \cite{firsovVariationsNoetherianness2016} explores Noetherianness.
\cite{firsovDependentlyTypedProgramming2015} explored what we have called split
enumerability and manifest Bishop finiteness (although they are stated slightly
differently), and they use these to build a library for proof search.
In \cite{fruminFiniteSetsHomotopy2018} the topic of Kuratowski finite sets in
HoTT is studied extensively: we have focused more on the non-truncated versions
of finiteness (the ``manifest'' predicates), and we have provided the missing
\(\Pi\)-pretopos proof of decidable Kuratowski finite sets.

\cite{iversenUnivalentCategoriesFormalization2018} provided a starting point for
our categorical formalisation: it contains a proof, for instance, that homotopy
sets form a category.
\begin{acks}
  This work has been supported by the Science Foundation Ireland under the
  following grant: 13/RC/2D94 to Irish Software Research Centre.
\end{acks}
\printbibliography
\end{document} 