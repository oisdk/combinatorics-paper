\input{preamble}
\title{Finiteness in Cubical Type Theory}
\author{
  Donnacha Oisín Kidney \inst{1} \and
  Gregory Provan \inst{2}
}
\institute{
  University College Cork \email{o.kidney@cs.ucc.ie} \and
  University College Cork \email{g.provan@cs.ucc.ie}
}
\begin{document}
\maketitle
\begin{abstract}
  We study five different notions of finiteness in Cubical Type Theory and prove
  the relationship between them.
  In particular we show that any totally ordered Kuratowski finite type is
  manifestly Bishop finite.

  We also prove closure properties for each finite type, and classify them
  topos-theoretically.
  This includes a proof that the category of decidable Kuratowski finite sets
  (also called the category of cardinal finite sets) form a \(\Pi\)-pretopos.

  We then develop a parallel classification for the countably infinite types, as
  well as a proof of the countability of \(A^\star\) for a countable type \(A\).

  We formalise our work in Cubical Agda, where we implement a library for proof
  search (including combinators for level-polymorphic fully generic currying).
  Through this library we demonstrate a number of uses for the computational
  content of the univalence axiom, including searching for and synthesising
  functions.
  \keywords{Agda \and Homotopy Type Theory \and Cubical Type Theory \and
    Dependent Types \and Finiteness \and Topos \and Kuratowski finite}
\end{abstract}

\section{Introduction}
\subsection{Foreword}
In constructive mathematics we are often preoccupied with \emph{why} something
is true.
Take finiteness, for example.
There are a handful of ways to demonstrate some type is finite: we could provide
a surjection from another finite type; we could show that any collection of its
elements larger than some bound contains duplicates; or that any stream of its
elements contain duplicates.

Classically, all of these proofs end up proving the same thing: that our type is
finite.
Constructively (in Martin-Löf Type Theory
\cite{martin-lofIntuitionisticTypeTheory1980} at least), however, all three
of the statements above construct a different version of finiteness.
\emph{How} we show that some type is finite has a significant impact on the
type of finiteness we end up dealing with.

Homotopy Type Theory \cite{hottbook} adds another wrinkle to the story.
Firstly, in HoTT we cannot assume that every type is a (homotopy) set: this
means that the finiteness predicates above can be further split into versions
which apply to sets only, and those that apply to all types.
Secondly, HoTT gives us a principled and powerful way to construct quotients,
allowing us to regain some of the flexibility of classical definitions by
``forgetting'' the parts of a proof we would be forced to remember in MLTT.

Finally, the other important property of constructive mathematics is that we can
actually \emph{compute} with proofs.
Cubical Type Theory \cite{cohenCubicalTypeTheory2016}, and its implementation in
Cubical Agda \cite{vezzosiCubicalAgdaDependently2019}, realise this property
even in the presence of univalence, giving computational content to programs
written in HoTT.
\subsection{Contributions}
In this work we will examine five notions of finiteness in Homotopy Type Theory,
the relationships between them, and their topos-theoretic characterisation.
We also briefly examine a predicate for countable sets, comparing it to the
finiteness predicates.
Our work is formalised in Cubical Agda, where we also develop a library for
proof search based on the finiteness predicates.

\input{figures/finite-classification}

The finiteness predicates we are interested in are organised in
Figure~\ref{finite-classification}.
We will explore two aspects of each predicate: its relation to the other
predicates, and its topos-theoretic classification.

When we say ``relation'' we are referring to the arrows in
Figure~\ref{finite-classification}.
The proofs, then, amount to a function which inhabits each arrow.
Each unlabelled arrow is a weakening: i.e., every manifest Bishop finite set
is manifest enumerable.
The labelled arrows are strengthening proofs: i.e., every manifest enumerable set
\emph{with decidable equality} is manifest Bishop finite.
Our most significant result here is the proof that a cardinal finite set with a
decidable total order is manifestly Bishop finite.

We will then characterise each predicate as some form of topos.
Our proofs follow the structure of \cite[Chapters 9, 10]{hottbook} and
\cite{rijkeSetsHomotopyType2015}.
This means we will define first the precategory of sets, and then the category
of sets, and prove the required closures and limits to get us to a topos.
We say ``some form of'' topos here because of course the category of sets in
HoTT do \emph{not}, in fact, form a topos, rather a \(\Pi W\)-pretopos.
Our main result here is that the category of decidable Kuratowski finite sets
forms a \(\Pi\)-pretopos.

After the finite predicates, we will briefly look at the infinite countable
types, and classify them in a parallel way to the finite predicates.
We here show that countably finite sets form a \(W\)-pretopos.

All of our work is formalised in Cubical Agda
\cite{vezzosiCubicalAgdaDependently2019}.
We will make mention of the few occasions where the formalisation of some proof
is of interest, but the main place where we will discuss the code is in the
final section, where we implement a library for proof search, based on
omniscience and exhaustibility.
While proof search based on finiteness is not new, implementing it here does
give us an opportunity to demonstrate some actual \emph{computation} in a
univalent setting.
Many of the finiteness predicates are built using univalence, so for the proof
search functionality to work at all we require computational content in the
univalence axiom.
Furthermore, the extensionality afforded to us by HoTT means that we can have
\(\Pi\) types in the domain of the search, meaning we can synthesise full
functions from specifications alone.
\subsection{Related Work}
\subsection{Notation and Background}
\subsubsection{Notation}
We work in Cubical Type Theory \cite{cohenCubicalTypeTheory2016}.
For the various type formers we use the following notation:
\begin{description}
  \item[Type] We use \(\mathbf{Type}\) to denote the universe of (small) types.
    ``Type families'' are functions into type.
  \item[Universes]
    Implicitly, types will exist at some point in a universe hierarchy,
    beginning with \(\mathbf{Type}\) (\(\mathbf{Type} : \mathbf{Type}_1\),
    \(\mathbf{Type}_1 : \mathbf{Type}_2\), and so on).
    In our formalisation, every proof is done in the most universe polymorphic
    way possible: the proof that the cardinally finite sets form a
    \(\Pi\)-pretopos, for instance, is defined over any universe level.
  \item[0 , 1 , 2] We call the \(\mathbf{0}\), \(\mathbf{1}\), and
    \(\mathbf{2}\) types \(\bot\), \(\top\), and \(\mathbf{Bool}\) respectively.
    The single inhabitant of \(\top\) is tt, and the two inhabitants of
    \(\mathbf{Bool}\) are false and true.
  \item[Dependent Sum and Product] We use \(\Sigma\) and \(\Pi\) for the
    dependent sum and product, respectively.
    The two projections from \(\Sigma\) are called fst and snd.
    In the non-dependent case, \(\Sigma\) can be written as \(\times\), and
    \(\Pi\) as \(\rightarrow\).
  \item[Disjoint Union] Disjoint union can be defined in terms of \(\Sigma\):
    \begin{equation}
      A \uplus B \coloneqq \Sigma(x : \mathbf{Bool}) , \text{if } x \text{ then } A \text{ else } B
    \end{equation}
    However, we prefer to use it as an inductively defined type (though the two
    are equivalent).
    \begin{equation}
      \begin{aligned}
        A \uplus B \coloneqq & \;
        \text{inl} &: A \rightarrow A \uplus B \\
        | & \;  \text{inr} &: B \rightarrow A \uplus B
      \end{aligned}
    \end{equation}
  \item[Equalities, equivalences, and paths] We use the symbol \(\coloneqq\)
    for definitions.
    \(\simeq\) will be used for equivalences, and \(\equiv\) for equalities.
    Of course, we know that \((A \simeq B) \simeq (A \equiv B)\) by univalence,
    so the distinction isn't terribly important in usage.
\end{description}
\subsubsection{Cubical Type Theory}
Cubical Type Theory \cite{cohenCubicalTypeTheory2016} is a constructive type
theory with an implementation in Cubical Agda
\cite{vezzosiCubicalAgdaDependently2019}.
It allows us to do much of the same theory as in HoTT, but crucially the
univalence ``axiom'' is a \emph{theorem}, rather than an axiom.
This allows us to actually compute with univalent proofs, a capability missing
from HoTT.
\begin{romdefinition}[Path Types] \label{path-types}
  The equality type (which we denote with \(\equiv\)) in CuTT is the type of
  Paths\footnotemark.
  The internal structure of paths is largely irrelevant to us here, as we will
  generally treat \(\equiv\) as a black-box equivalence relation with
  substitution and congruence.
\end{romdefinition}

\footnotetext{
  Actually, CuTT does have an identity type with similar semantics to the
  identity type in MLTT.
  We do not use this type anywhere in our work, however, so we will not consider
  it here.
}
\begin{romdefinition}[Homotopy Levels] \label{homotopy-types}
  Types in HoTT and CuTT are not necessarily sets, as they are in MLTT.
  This means that equalities are not necessarily unique.
  In fact, we have an entire hierarchy of homotopy levels, of which sets are
  level 2.
  \begin{alignat}{2}
    &\text{isContr}(A)    &&\coloneqq \Sigma(x : A) , \Pi(y : A) , (x \equiv y) \\
    &\text{isProp}(A)     &&\coloneqq \Pi(x, y : A) , (x \equiv y) \\
    &\text{isSet}(A)      &&\coloneqq \Pi(x, y : A) , \text{isProp}(x \equiv y) \\
    &\text{isGroupoid}(A) &&\coloneqq \Pi(x, y : A) , \text{isSet}(x \equiv y)
  \end{alignat}
  We can define the above types inductively like so:
  \begin{alignat}{2}
    &\text{isOfHLevel}(0 , A)   &&\coloneqq \text{isContr}(A) \\
    &\text{isOfHLevel}(n+1 , A) &&\coloneqq \Pi(x , y : A) , \text{isOfHLevel}(n , x \equiv y)
  \end{alignat}
\end{romdefinition}
\begin{romdefinition}[Fibers] \label{fibres}
  A fibre is defined over some function \(f : A \rightarrow B\).
  \begin{equation}
    \text{fib}_f(y) = \Sigma(x : A) , (f x \equiv y)
  \end{equation}
\end{romdefinition}
\begin{romdefinition}[Equivalences] \label{equivalences}
  We will take contractible maps \cite[definition 4.4.1]{hottbook} as our
  ``default'' definition of equivalences.
  \begin{alignat}{2}
    &\text{isEquiv}(f) &&\coloneqq \Pi(y : B) , \text{isContr}(\text{fib}_f(y)) \label{is-equiv-def} \\
    &A \simeq B        &&\coloneqq \Sigma(f : A \rightarrow B) , \text{isEquiv}(f)
  \end{alignat}
\end{romdefinition}
\begin{romlemma}
  Univalence
  \begin{equation}
    (A \simeq B) \simeq (A \equiv B)
  \end{equation}
\end{romlemma}
\begin{romdefinition}[Isomorphism] \label{isomorphism}
  We say two types \(A\) and \(B\) are isomorphic, denoted with \(A \iff B\), if
  there is a pair of functions \(f : A \rightarrow B\), \(g : B \rightarrow A\)
  such that
  \begin{equation}
    \begin{aligned}
      \Pi(x : A) , (g(f(x)) \equiv x) \\
      \Pi(x : B) , (f(g(x)) \equiv x)
    \end{aligned}
  \end{equation}
  While we can derive an equivalence from an isomorphism:
  \begin{equation}
    \text{isoToEquiv} : (A \iff B) \rightarrow (A \simeq B)
  \end{equation}
  It is not the case that an isomorphism is the \emph{same} as an equivalence in
  all cases.
  In other words, we do not have:
  \begin{equation}
    (A \iff B) \simeq (A \simeq B)
  \end{equation}
  However, if one of \(A\) or \(B\) is a set, then the above holds.
\end{romdefinition}
\begin{romdefinition}[Higher Inductive Types] \label{HITs}
  \todo[inline]{define}
\end{romdefinition}
\begin{romdefinition}[Surjections] \label{surjections}
  \begin{alignat}{3}
    &\text{surj}(f)             &&\coloneqq \Pi(y : B) , \lVert \text{fib}_f(y) \rVert \\
    &A \twoheadrightarrow B     &&\coloneqq \Sigma (f : A \rightarrow B) , \text{surj}(f) \label{surj-arrow-eqn} \\
    &\text{sp-surj}(f)          &&\coloneqq \Pi(y : B) , \text{fib}_f(y) \label{sp-surj-eqn} \\
    &A \twoheadrightarrow! \; B &&\coloneqq \Sigma (f : A \rightarrow B) , \text{sp-surj}(f) \label{sp-surj-arrow-eqn}
  \end{alignat}
\end{romdefinition}
\begin{romdefinition}[Containers] \label{container-def}
  A container \cite{abbottContainersConstructingStrictly2005} is a pair
  \(S , P\) where \(S\) is a type, the elements of which are called
  the \emph{shapes} of the container, and \(P\) is a type family on \(S\), where
  the elements of \(P(s)\) are called the \emph{positions} of a container.
  We ``interpret'' a container into a functor defined like so:
  \begin{equation} \label{container-interp}
    \llbracket S , P \rrbracket(A) \coloneqq \Sigma {(s : S)} , \left( P(s) \rightarrow A \right)
  \end{equation}
  Membership of a container can be defined like so:
  \begin{equation} \label{container-membership}
    x \in \mathit{xs} \coloneqq \text{fib}_{\text{snd}(\mathit{xs})}(x)
  \end{equation}
\end{romdefinition}
\begin{romdefinition}[\(\mathbf{List}\)] \label{List}
  \begin{equation}
    \mathbf{List} \coloneqq \llbracket \mathbb{N} , \mathbf{Fin} \rrbracket
  \end{equation}
\end{romdefinition}
\begin{romdefinition}[\(\mathbf{Fin}\)] \label{Fin}
  \(\mathbf{Fin}(n)\) is the type of natural numbers smaller than \(n\). We
  define it the standard way, where \(\mathbf{Fin}(0) \coloneqq \bot\) and
  \(\mathbf{Fin}(n + 1) &\coloneqq \top \uplus \mathbf{Fin}(n)\).
\end{romdefinition}
\begin{romdefinition}[Propositional Truncation] \label{prop-trunc}
  The type \(\lVert A \rVert\) on some type \(A\) is a propositionally truncated
  proof of \(A\) \cite[3.7]{hottbook}.
  In other words, it is a proof that some \(A\) exists, but it does not tell you
  \emph{which} \(A\).

  It is defined as a Higher Inductive Type:
  \begin{equation} {
    \begin{alignat*}{3}
      \lVert A \rVert \coloneqq & \; \lvert \wc \rvert &&: A \rightarrow \lVert A \rVert ; \\
                              | & \; \text{squash}     &&: \Pi {(x, y : \lVert A \rVert)} , x \equiv y  ; 
    \end{alignat*} }
  \end{equation}
  We will use three eliminators from \(\lVert A \rVert\) in this paper.
  \begin{enumerate}
  \item \label{elim-prop-prop} For any function \(A \rightarrow B\), where
    \(\text{isProp}(B)\), we have a function \(\lVert A \rVert \rightarrow B\).
  \item \label{elim-prop-monad} A special case of \ref{elim-prop-prop} implies
    that \(\lVert \cdot \rVert\) forms a monad: this means that we get the usual
    Monadic operators on \(\lVert \cdot \rVert\) (bind, pure, fmap, etc.).
    \item \label{elim-prop-coh} We can eliminate from \(\lVert A \rVert\) with a
      function \(f : A \rightarrow B\) iff \(f\) ``doesn't care'' about the
      choice of \(A\) (\(\Pi {(x , y : A)} , f(x) \equiv f(y) \)).
      Formally speaking, \(f\) needs to be ``coherently constant''
      \cite{krausGeneralUniversalProperty2015}, and \(B\) needs to be an
      \(n\)-type for some finite \(n\).
  \end{enumerate}
\end{romdefinition}
\begin{romdefinition}[\(S^1\)] \label{circle-def}
  The circle, \(S^1\), can be represented in HoTT as a higher inductive type.
  \begin{equation}
    \begin{alignat}{5}
      S^1 \coloneqq & \; \text{base} &&: S^1 ; \\
                  | & \; \text{loop} &&: \text{base} \equiv \text{base} ; 
    \end{alignat}
  \end{equation}
  We will use it here as an example of a non-set type, i.e. a type for which not
  all paths are equal.
  This also means that it does not have decidable equality.
\end{romdefinition}
\section{Finiteness Predicates}
In this section, we will define and briefly describe each of the five predicates
in Figure~\ref{finite-classification}.
The reason we explore predicates other than our focus (cardinal finiteness) is
that we can often prove things like closure much more readily on the simpler
predicates.
The relations (which we will prove in the next section) then allow us to
transfer those proofs onto Kuratowski finiteness.
\subsection{Split Enumerability}
\begin{romdefinition}[Split Enumerable Set] \label{split-enum-def}
  \begin{equation} \label{split-enum-def-eqn}
    \mathcal{E}!(A) \coloneqq \Sigma {(\mathit{xs} : \textbf{List}(A))} , \Pi {(x : A)} , x \in \mathit{xs}
  \end{equation}
  We call the first component of this pair the ``support'' list, and the second
  component the ``cover'' proof.
  An equivalent version of this predicate was called \verb+Listable+ in
  \cite{firsovDependentlyTypedProgramming2015}.
\end{romdefinition}

We tend to prefer list-based definitions of finiteness, rather than ones based
on bijections or surjections.
This is purely a matter of perspective, however: the definition above is
precisely equivalent to a split surjection from a finite prefix of the natural
numbers.
\begin{romlemma} \label{split-enum-is-split-surj}
  \begin{equation}
    \mathcal{E}!(A) \simeq \Sigma (n : \mathbb{N}) , \left( \mathbf{Fin}(n) \twoheadrightarrow ! \; A \right)
  \end{equation}
\end{romlemma}
\begin{proof}
  \begin{align*}
    \mathcal{E}!(A)
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , x \in \mathit{xs}
    && \text{def.~\ref{split-enum-def} }(\mathcal{E}!)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \text{fib}_{\text{snd}(\mathit{xs})}(x)
    && \text{eqn.~\ref{container-membership} } (\in)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \text{sp-surj}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{sp-surj-eqn} (sp-surj)}
    \\
    & \simeq \Sigma (\mathit{xs} : \llbracket \mathbb{N} , \mathbf{Fin} \rrbracket (A)) , \text{sp-surj}(\text{snd}(\mathit{xs}))
    && \text{def.~\ref{List} } (\mathbf{List})
    \\
    & \simeq \Sigma (\mathit{xs} : \Sigma (n : \mathbb{N}) , \Pi (i : \mathbf{Fin}(n)) , A) , \text{sp-surj}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{container-interp} } (\llbracket \wc \rrbracket)
    \\
    & \simeq \Sigma (n : \mathbb{N}) , \Sigma (f : \mathbf{Fin}(n) \rightarrow A) , \text{sp-surj}(f)
    && \text{Reassociation of } \Sigma
    \\
    & \simeq \Sigma (n : \mathbb{N}) , ( \mathbf{Fin}(n) \twoheadrightarrow ! \; A )
    && \text{eqn.~\ref{sp-surj-arrow-eqn} } (\twoheadrightarrow!)
  \end{align*}
  \qed
\end{proof}

In our formalisation, the proof is a single line: most of the steps above are
simple expansion of definitions.
The only step which isn't definitional equality is the reassociation of
\(\Sigma\).

Split enumerability implies decidable equality on the underlying type.
To prove this, we will make use of the following lemma, proven in the
formalisation:
\begin{romlemma} \label{discrete-surj}
  \begin{equation}
    \frac{
        A \twoheadrightarrow! \; B \; \; \; \text{Discrete}(A)
      }{
       \text{Discrete}(B) 
      }
  \end{equation}
\end{romlemma}
\begin{romlemma} \label{split-enum-discrete}
  Every split enumerable type is discrete.
\end{romlemma}
\begin{proof}
  Let \(A\) be a split enumerable type.
  By lemma~\ref{split-enum-is-split-surj}, there is a surjection from
  \(\mathbf{Fin}(n)\) for some \(n\).
  Also, we know that \(\mathbf{Fin}(n)\) is discrete (proven in our
  formalisation).
  Therefore, by lemma~\ref{discrete-surj}, \(A\) is discrete.
  \qed
\end{proof}
\subsection{Manifest Bishop Finiteness}
\todo[noline]{Add explanation for word ``manifest''}
\begin{romdefinition}[Manifest Bishop Finiteness]
  \begin{equation} \label{bish-def}
    \mathcal{B}(A) \coloneqq \Sigma {(\mathit{xs} : \textbf{List}(A))} , \Pi {(x : A)} , x \inunique xs
  \end{equation}
\end{romdefinition}
The only difference between manifest Bishop finiteness and split enumerability
is the membership term: here we require unique membership (\(\inunique\)),
rather than simple membership (\(\in\)).
\begin{romdefinition}[Unique Membership] \label{uniq-memb-def}
  \begin{equation}
    x \inunique \mathit{xs} \coloneqq \text{isContr}(x \in \mathit{xs})
  \end{equation}
\end{romdefinition}

Where split enumerability was the enumeration form of a split surjection from
\(\mathbf{Fin}\), manifest Bishop finiteness is the enumeration form of an
\emph{equivalence} with \(\mathbf{Fin}\).
\begin{romlemma} \label{bishop-equiv}
  \begin{equation}
    \mathcal{B}(A) \simeq \Sigma {(n : \mathbb{N})} , \left( \mathbf{Fin}(n) \simeq A \right)
  \end{equation}
\end{romlemma}
\begin{proof}
  \begin{align*}
    \mathcal{B}(A)
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , x \inunique \mathit{xs}
    && \text{def.~\ref{bish-def} } (\mathcal{B})
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \Pi {(x : A)} , \text{isContr} \left(\text{fib}_{\text{snd}(\mathit{xs})}(x)\right)
    && \text{def.~\ref{uniq-memb-def} } (\inunique)
    \\
    & \simeq \Sigma (\mathit{xs} : \textbf{List}(A)) , \text{isEquiv}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{is-equiv-def} (isEquiv)}
    \\
    & \simeq \Sigma (\mathit{xs} : \llbracket \mathbb{N} , \mathbf{Fin} \rrbracket (A)) , \text{isEquiv}(\text{snd}(\mathit{xs}))
    && \text{def.~\ref{List} } (\mathbf{List})
    \\
    & \simeq \Sigma (\mathit{xs} : \Sigma (n : \mathbb{N}) , \Pi (i : \mathbf{Fin}(n)) , A) , \text{isEquiv}(\text{snd}(\mathit{xs}))
    && \text{eqn.~\ref{container-interp} } (\llbracket \wc \rrbracket)
    \\
    & \simeq \Sigma (n : \mathbb{N}) , \Sigma (f : \mathbf{Fin}(n) \rightarrow A) , \text{isEquiv}(f)
    && \text{Reassociation of } \Sigma
    \\
    & \simeq \Sigma (n : \mathbb{N}) , ( \mathbf{Fin}(n) \simeq \; A )
    && \text{eqn.~\ref{surj-arrow-eqn} } (\twoheadrightarrow)
  \end{align*}
  \qed
\end{proof}
\subsection{Cardinal}
Each finiteness predicate so far has contained an \emph{ordering} of the
underlying type.
For our purposes, this is too much information: it means that when constructing
the ``category of finite sets'' later on, instead of each type having one
canonical representative, it will have \(n!\), where \(n\) is the cardinality of
the type.

To remedy the problem, we will use propositional truncation
(def.~\ref{prop-trunc}).
\begin{romdefinition}[Cardinal Finiteness]
  \begin{equation}
    \mathcal{C}(A) \coloneqq \lVert \mathcal{B}(A) \rVert
  \end{equation}
\end{romdefinition}
At first glance, it might seem that we lose any useful properties we could
derive from \(\mathcal{B}\).
Luckily, this is not the case: by eliminator \ref{elim-prop-coh} of
def.~\ref{prop-trunc}, we need only show that the output is uniquely determined.

The following two lemmas are proven in
\cite{yorgeyCombinatorialSpeciesLabelled2014} (Proposition 2.4.9 and 2.4.10,
respectively), in much the same way as we have done here.
Our contribution for this section is simply the formalisation.
\begin{romlemma}
  Given a cardinally finite type, we can derive the type's cardinality, as well
  as a propositionally truncated proof of equivalence with \(\textbf{Fin}\)s of
  the same cardinality.
  \begin{equation}
    \mathcal{C}(A) \rightarrow \Sigma {(n : \mathbb{N})} , \lVert \textbf{Fin}(n) \simeq A \rVert
  \end{equation}
\end{romlemma}
\begin{romlemma} \label{cardinal-finite-discrete}
  Any cardinal-finite set has decidable equality.
\end{romlemma}
\subsection{Manifest Enumerability}
\begin{romdefinition}[Manifest Enumerability]
  \begin{equation}
    \mathcal{E}(A) \coloneqq \Sigma {(\mathit{xs} : \mathbf{List}(A))} , \Pi {(x : A)} , \lVert x \in \mathit{xs} \rVert
  \end{equation}
\end{romdefinition}
As with manifest Bishop finiteness, the only difference with this type and split
enumerability is the membership proof: here we have propositionally truncated
it.
This has two effects.
First, it means that this proof represents a true surjection (rather than a
split surjection) from \(\mathbf{Fin}\).
\begin{romlemma}
  \begin{equation}
    \mathcal{E}(A) \simeq \Sigma(n : \mathbb{N}) , (\mathbf{Fin}(n) \twoheadrightarrow A)
  \end{equation}
\end{romlemma}

Secondly, it means the predicate does not imply decidable equality.
More significantly, it allows the predicate to be defined over non-set types,
like the circle (def.~\ref{circle-def}).
\begin{romlemma}
  The circle \(S^1\) is manifestly enumerable.
\end{romlemma}
\subsection{Kuratowski Finiteness}
Much work has already been done on Kuratowski finiteness in HoTT in
\cite{fruminFiniteSetsHomotopy2018}.
As a result, we will not needlessly repeat proofs, rather we will just give a
brief introduction to the topic and point out where our treatment differs.

The first thing we must define is a representation of subsets.
\begin{romdefinition}[Kuratowski Finite Subset]
  \(\mathcal{K}(A)\) is the type of Kuratowski-finite subsets of \(A\).
  \begin{equation}
    \begin{alignat}{2}
      \mathcal{K}(A) \coloneqq&
             \; []                &&: \mathcal{K}(A) ; \\
      \vert& \; \wc \dblcolon \wc &&: A \rightarrow \mathcal{K}(A) \rightarrow \mathcal{K}(A) ; \\
      \vert& \; \text{com}        &&: \Pi (x, y: A) , \Pi (\mathit{xs} : \mathcal{K}(A)) , x \dblcolon y \dblcolon \mathit{xs} \equiv y \dblcolon x \dblcolon \mathit{xs} ; \\
      \vert& \; \text{dup}        &&: \Pi (x : A) , \Pi (\mathit{xs} : \mathcal{K}(A)) , x \dblcolon x \dblcolon \mathit{xs} \equiv x \dblcolon \mathit{xs} ; \\
      \vert& \; \text{trunc}      &&: \Pi (\mathit{xs}, \mathit{ys}: \mathcal{K}(A)) , \Pi (p, q : \mathit{xs} \equiv \mathit{ys}) , p \equiv q ;
    \end{alignat}
  \end{equation}

  The first two constructors are point constructors, giving ways to create
  values of type \(\mathcal{K}(A)\).
  They are also recognisable as the two constructors for finite lists, a type
  which represents the free monoid.

  The next two constructors add extra paths to the type: equations that usage of
  the type must obey.
  These extra paths turn the free monoid into the free \emph{commutative} (com)
  \emph{idempotent} (dup) monoid.

  The final constructor enforces that the type \(\mathcal{K}(A)\) must be a set.
\end{romdefinition}
The Kuratowski finite subset is a free join semilattice (or, equivalently, a
free commutative idempotent monoid).
More prosaically, \(\mathcal{K}\) is the abstract data type for finite sets, as
defined in the Boom hierarchy \cite{boomFurtherThoughtsAbstracto1981,
  bunkenburgBoomHierarchy1994}.
However, rather than just being a specification, \(\mathcal{K}\) is fully usable
as a data type in its own right, thanks to HITs.

Other definitions of \(\mathcal{K}\) exist (such as the one in
\cite{fruminFiniteSetsHomotopy2018}) which make the fact that \(\mathcal{K}\) is
the free join semilattice more obvious.
We have included such a definition in our formalisation, and proven it
equivalent to the one above.

Next, we need a way to say that an entire type is Kuratowski finite.
For that, we will need to define membership of \(\mathcal{K}\).
\begin{romdefinition}[Membership of \(\mathcal{K}\)]
  Membership is defined by pattern-matching on \(\mathcal{K}\).
  The two point constructors are handled like so:
  \begin{equation}
    \begin{alignedat}{2}
      x \in&& \; []                      &\coloneqq \bot \\
      x \in&& \; y \dblcolon \mathit{ys} &\coloneqq \lVert x \equiv y \uplus x \in \mathit{ys} \rVert
    \end{alignedat}
  \end{equation}
  The \(\text{com}\) and \(\text{dup}\) constructors are handled by proving that
  the truncated form of \(\uplus\) is itself commutative and idempotent.
  The type of propositions is itself a set, satisfying the \(\text{trunc}\)
  constructor.
\end{romdefinition}
Finally, we have enough background to define Kuratowski finiteness.
\begin{romdefinition}[Kuratowski Finiteness]
  \begin{equation}
    \mathcal{K}^{f}(A) = \Sigma {(\mathit{xs} : \mathcal{K}(A))} , \Pi (x : A) , x \in \mathit{xs}
  \end{equation}
\end{romdefinition}

We also have the following two lemmas, proven in both
\cite{fruminFiniteSetsHomotopy2018} and our formalisation.
\begin{romlemma}
  \(\mathcal{K}^f\) is a mere proposition.
\end{romlemma}
\begin{romlemma}
  This circle \(S^1\) is Kuratowski finite.
\end{romlemma}
The second of these in particular tells us that the ``Kuratowski-finite types''
are not necessarily sets; it also tells us that we cannot derive decidable
equality from a proof of Kuratowski finiteness.
\section{Relations Between Each Finiteness Definition}
We now look at under what conditions a given finiteness predicate satisfies
another.
\subsection{Split Enumerability and Manifest Bishop Finiteness}
While manifest Bishop finiteness might seem stronger than split enumerability,
it turns out this is not the case.
Both types imply the other.
\begin{romlemma}
  Any manifest Bishop finite type is split enumerable.
\end{romlemma}
\begin{proof}
  The only difference between \(\mathcal{B}\) and \(\mathcal{E}!\) is the
  membership term.
  To derive \(\mathcal{E}!\) from \(\mathcal{B}\), then, we need to derive
  \(\in\) from \(\inunique\).
  We can do this with fst.
  \begin{alignat*}{4}
    &\text{fst} : && \; \Sigma(x : A) , U(x) \rightarrow A \\
    && \simeq      & \; \text{isContr}(A) \rightarrow A \\
    && \simeq      & \; (x \in \mathit{xs}) \rightarrow (x \inunique \mathit{xs})
  \end{alignat*}
  \qed
\end{proof}

To derive \(\mathcal{B}\) from \(\mathcal{E}!\) takes significantly more work.
The ``unique membership'' condition in \(\mathcal{B}\) means that we are not
permitted duplicates in the support list.
The first step in the proof, then, is to filter those duplicates out from the
support list of the \(\mathcal{E}!\) proof: we can do this using the decidable
equality provided by \(\mathcal{E}!\) (lemma~\ref{split-enum-discrete}).
From there, all we need to show is that the membership proof carries over
appropriately.
\begin{romlemma} \label{split-enum-to-manifest-bishop}
  Any split enumerable set is manifest Bishop finite.
\end{romlemma}
\subsection{Manifest Bishop Finiteness and Manifest Enumerability}
\begin{romlemma}
  Any manifestly Bishop finite type is manifestly enumerable.
\end{romlemma}
\begin{romlemma}
  A manifestly enumerable type with decidable equality is manifest Bishop
  finite.
\end{romlemma}
\subsection{Manifest Bishop Finiteness and Cardinal Finiteness}
\begin{romlemma}
  Any manifest Bishop finite type is cardinal finite.
\end{romlemma}
\begin{romtheorem}
  Any cardinal finite type with a total order is Bishop finite.
\end{romtheorem}
\section{Topos}
Our main result in this section is the formal proof that decidable Kuratowski
finite types form a \(Pi\)-pretopos.
As we saw in theorem~\ref{kuratowski-cardinal}, decidable Kuratowski finite
types are equivalent to cardinal finite types, so we will work with the latter
from now on.
Our first task is to show that cardinal finite types are closed under several
operations.
\subsection{Closure}
For the first two closure proofs, we only consider manifest Bishop finiteness:
as it is the strongest of the finiteness predicates, we can derive the other
closure proofs from it.
\begin{romlemma}
  \(\bot\) is manifest Bishop finite.
\end{romlemma}
\begin{proof}
  From lemma~\ref{bishop-equiv} we can prove the goal by constructing a term of
  the type:
  \begin{equation}
    \Sigma(n : \mathbb{N}) , (\mathbf{Fin}(n) \simeq \bot)
  \end{equation}
  To do so, we take \(n\) to be 0, and by definition~\ref{Fin},
  \(\mathbf{Fin}(0) = \bot\).
  The equivalence is simply the identity equivalence.
\end{proof}
\begin{romlemma}
  \(\top\) is manifest Bishop finite.
\end{romlemma}
\begin{proof}
  Again, we need only provide a suitable cardinality (in this case 1), and an
  equivalence with \(\mathbf{Fin}(1)\) to prove our goal.
  \begin{align*}
    \top &\simeq \mathbf{Fin}(1) \\
          &\simeq \top \uplus \mathbf{Fin}(0) \\
          &\simeq \top \uplus \bot \\
          &\simeq \top
  \end{align*}
  \qed
\end{proof}
\begin{romlemma}
  \(\mathbf{Bool}\) is manifest Bishop finite.
\end{romlemma}

\begin{romlemma}
  Split enumerability is closed under \(\Sigma\),
\end{romlemma}
\begin{romlemma}
  Manifest bishop finiteness is closed over dependent functions
  (\(\prod\)-types).
  \begin{equation}
    \frac{
      \mathcal{B}(A) \; \; \; \Pi {(x : A)} , \mathcal{B}\left( U(x) \right)
    }{
      \mathcal{B}\left(\Pi {(x : A)} , U(x)\right)
    }
  \end{equation}
\end{romlemma}
\begin{proof}
  This proof is essentially the composition of two transport operations, made
  available to us via univalence.
  
  First, we will simplify things slightly by working only with split
  enumerability.
  As this is equal in strength to manifest Bishop finiteness, any closure proofs
  carry over.

  Secondly, we will replace \(A\) in all places with \(\mathbf{Fin}(n)\).
  Since we have already seen an equivalence between these two types, we are
  permitted to transport along these lines.
  This is the first transport operation.

  The bulk of the proof now is concerned with proving the following:
  \begin{equation}
    \left( \Pi {(x : \mathbf{Fin}(n))} , \mathcal{E}!(A(x)) \right) \rightarrow \mathcal{E}!\left( \Pi {(x : \mathbf{Fin}(n))} , A(x) \right)
  \end{equation}
  Our strategy to accomplish this will be to consider functions from
  \(\mathbf{Fin}(n)\) as \(n\)-tuples over some type family \(T : \mathbb{N}
  \rightarrow \text{Type}\).
  \begin{equation}
    \begin{aligned}
      \mathbf{Tuple}(T, 0)   &= \top \\
      \mathbf{Tuple}(T, n+1) &= T(0) \times \mathbf{Tuple}(T \circ \text{suc}, n)
    \end{aligned}
  \end{equation}
  This type is manifestly Bishop finite, as it is constructed only from products
  and the unit type.
  
  We then prove an isomorphism between this representation and \(\Pi\)-types.
  \begin{equation}
    \mathbf{Tuple}(T, n) \iff \Pi {(x : \mathbf{Fin}(n))} , T(x)
  \end{equation}
  This allows us to transport our proof of finiteness on tuples to one on
  functions from \(\mathbf{Fin}\) (our second transport operation), proving our
  goal.
\end{proof}
\subsection{The Category of Finite Sets}
HoTT and CuTT seem to be especially suitable settings for formalisations of
category theory.
The univalence axiom in particular allows us to treat categorical isomorphisms
as the important, useful objects that they are, upgrading them to full
equalities.

We follow \cite[chapter 9]{hottbook} in its treatment of
categories in HoTT, and in its proof that sets do indeed form a category.
We will first briefly go through the construction of the category
\(\mathit{Set}\), as it differs slightly from the usual method in type theory.

First, the type of objects and arrows:
\begin{alignat}{3}
  &\text{Obj}_\mathit{Set}      &&\coloneqq \Sigma(x : \mathbf{Type}) , \text{isProp}(x) \\
  &\text{Hom}_\mathit{Set}(x , y) &&\coloneqq  \text{fst}(x) \rightarrow \text{fst}(y)
\end{alignat}
As is plain in the type of objects, we have already departed slightly from the
simpler \(\text{Obj}_\mathit{Set} \coloneqq \mathbf{Type}\) way of doing things:
of course we have to, as HoTT allows non-set types.
Furthermore, after proving the usual associativity and identity laws for
composition (which are definitionally true in this case), we must further show
\(\text{isSet}(\text{Hom}_\mathit{Set}(x,y))\); even then we only have a
precategory.

To show that \(\mathit{Set}\) is a category, we must show that categorical
isomorphisms are equivalent to equivalences.
In a sense, we must give a univalence rule for the category we are working in.

We have provided formal proofs that \(\mathit{Set}\) does indeed form a
category, and the following:
\begin{romtheorem}[The Category of Finite Sets]
  Finite sets form a category in HoTT when defined like so:
  \begin{equation}
    \begin{aligned}
      &\text{Obj}_\mathit{FinSet}      &&\coloneqq \Sigma(x : \mathbf{Type}) , \mathcal{C}(x) \\
      &\text{Hom}_\mathit{FinSet}(x , y) &&\coloneqq  \text{fst}(x) \rightarrow \text{fst}(y)
    \end{aligned}
  \end{equation}
\end{romtheorem}
\subsection{The \(\Pi\)-pretopos of Finite Sets}
For this proof, we follow again the proof that \(\mathit{Set}\) forms a \(\Pi
W\)-pretopos from \cite[chapter 10]{hottbook} and
\cite{rijkeSetsHomotopyType2015}.
\section{Countably Infinite Types}
In the previous sections we saw different flavours of finiteness which were
really just different flavours of relations to \(\mathbf{Fin}\).
In this section we will see that we can construct a similar classification of
relations to \(\mathbb{N}\), in the form of the countably infinite types.
\subsection{Split Countable Types}
Our first foray into the world of countable types will be a straightforward
analogue to the split enumerable types.
We need change only one element: instead of a support \emph{list}, we instead
have a support \emph{stream}, which is its infinite.
\begin{romdefinition}[Stream]
  \begin{equation}
    \mathbf{Stream}(A) = \llbracket \top \triangleright \text{const} (\mathbb{N}) \rrbracket(A) \simeq \mathbb{N} \rightarrow A
  \end{equation}
\end{romdefinition}
\begin{romdefinition}[Split Countability]
  \begin{equation}
    \mathcal{E}!(A) = \Sigma {(\mathit{xs} : \mathbf{Stream}(A))} , \Pi {(x : A)} , x \in \mathit{xs}
  \end{equation}
\end{romdefinition}
This type is definitionally equal to it surjection equivalent (\(\mathbb{N}
\twoheadrightarrow ! \; A\)).
\subsubsection{Closure}
We know that countable infinity is not closed under the exponential (function
arrow), so the only closure we need to prove is \(\Sigma\) to cover all of
what's left.
\input{figures/pairing-functions.tex}
\begin{romtheorem} \label{split-countability-sigma}
  Split countability is closed under \(\Sigma\).
\end{romtheorem}
\begin{proof}
  The main task here is to figure out a pattern which will pair elements of the
  two support streams without diverging.
  Figure~\ref{cartesian} illustrates why the pairing function we used for lists
  won't work: it needs to exhaust one of the input lists before inspecting
  anything other than the first element of the other.
  Of course, we can't exhaust a stream, so this diverges.

  Instead, we will use the pattern in figure~\ref{cantor}.
  We will produce a stream of lists (where each list is a diagonal), which is
  then concatenated to the final output stream.
  The intermediate stream is sometimes called the discrete convolution of the
  two input streams.
\end{proof}
\subsubsection{Kleene Star}
While we lose some closures with the inclusion of infinite types, we gain some
others.
In particular, we have the Kleene star.
This means that we have closure under lists.
\begin{romtheorem}
  Split countability is closed under Kleene star.
  \begin{equation}
    \mathcal{E}!(A) \rightarrow \mathcal{E}!(\mathbf{List}(A))
  \end{equation}
\end{romtheorem}
\begin{proof}
  As with the proof of closure under \(\Sigma\), our main task here is to figure
  out a pattern that reaches any given finite list in finite time.
  Our first step is to split up the problem as we did for \(\Sigma\)-closure: we
  produce an intermediate stream of lists, which we then concatenate to give the
  final result.
  The intermediate stream is constructed like so:
  \begin{equation}
    \mathit{xs}^\star_i = \left\{ \text{map}(\mathit{xs} , x) \mid \mathit{x} \in \mathbf{List}(\mathbb{N}) , \text{sum}(\text{map}(1+, x)) \equiv i \right\}
  \end{equation}
  In other words, the \(i\)th element is all lists such that the sum of the
  successor of the indices in the list is equal to \(i\).
\end{proof}
\subsection{Other Types of Countability}
There are of course other forms of countability available to us: manifest
countability, cardinal, etc.
We have a similar structure of relationships to the finite types, with the
exception that we cannot construct an isomorphism with \(\mathbb{N}\) fiven a
surjection from \(\mathbb{N}\).
\begin{itemize}
  \item Definition
  \item \(\Sigma\)
  \item Kleene star
  \item Truncated
  \item Topos
\end{itemize}
\section{Search}
\subsection{Omniscience}
In this section we are interested in restricted forms of the limited principle
of omniscience \cite{myhillErrettBishopFoundations1972}.
\begin{romdefinition}[Limited Principle of Omniscience]
  For any type \(A\) and predicate \(P\) on \(A\), the limited principle of
  omniscience is as follows:
  \begin{equation}
    \left( \Pi {(x : A)} , \mathbf{Dec}(P(x)) \right) \rightarrow \mathbf{Dec} \left( \Sigma {(x : A)} , P(x) \right)
  \end{equation}
  In other words, for any decidable predicate the existential quantification of
  that predicate is also decidable.
\end{romdefinition}
The limited principle of omniscience is non-constructive, but individual types
can themselves satisfy omniscience.
In particular, \emph{finite} types are omniscient.

There is also a universal form of omniscience, which we call exhaustibility.
\begin{romdefinition}[Exhaustibility]
  We say a type \(A\) is exhaustible if, for any decidable predicate \(P\) on
  \(A\), the universal quantification of the predicate is decidable.
  \begin{equation}
    \left( \Pi {(x : A)} , \mathbf{Dec}(P(x)) \right) \rightarrow \mathbf{Dec} \left( \Pi {(x : A)} , P(x) \right)
  \end{equation}
\end{romdefinition}

All of the finiteness predicates we have seen justify exhaustibility.
We will only prove it once, then, for the weakest:
\begin{romtheorem}
  Kuratowski-finite types are exhaustible.
\end{romtheorem}

Omniscience is stronger than exhaustibility, as we can derive the latter from
the former:
\begin{romlemma} \label{omniscient-is-exhaustible}
  Any omniscient type is exhaustible.
\end{romlemma}
\begin{proof}
  For decidable propositions, we know the following:
  \begin{equation} \label{lem-conversion}
    \Pi (x : A) , P(x) \leftrightarrow \neg \Sigma (x : A) , \neg P(x) 
  \end{equation}
  To derive exhaustibility from omniscience, then, we run the predicate in its
  negated form, and then subsequently negate the result.
  The resulting decision over \(\neg \Sigma(x : A) , \neg P(x)\) can be
  converted into \(\Pi (x : A) , P(x)\).
\end{proof}
We cannot derive, however, that any exhaustible type is omniscient, as we do not
have the inverse of equation~\ref{lem-conversion}:
\begin{equation} \label{choice-conversion}
  \Sigma (x : A) , P(x) \leftrightarrow \neg \Pi (x : A) , \neg P(x)
\end{equation}
Such an equation would allow us to pick a representative element from any type,
which is therefore non-constructive.
In a sense, equation~\ref{lem-conversion} requires a form of LEM on the
proposition (i.e. requires it to be decidable), whereas
equation~\ref{choice-conversion} requires a form of choice.
Those finiteness predicates which are ordered do in fact give us this form of
choice, so the conversion is valid.
As such, all of the ordered finiteness predicates imply omniscience.
Again, we will prove it only for the weakest.
\begin{romtheorem}
  Manifest enumerable types are omniscient.
\end{romtheorem}
Finally, we do have a form of omniscience for prop-valued predicates, as they do
not care about the chosen representative.
\begin{romtheorem}
  Kuratowski finite types are omniscient about prop-valued predicates.
\end{romtheorem}
\subsection{Synthesising Pattern-Matching Proofs}
In particular, they can automate large proofs by analysing every possible case.
In \cite{firsovDependentlyTypedProgramming2015}, the \(\AgdaDatatype{Pauli}\)
group is used as an example.
\ExecuteMetaData[agda/Data/Pauli.tex]{def}
As \(\AgdaDatatype{Pauli}\) has 4 constructors, \(n\)-ary functions on
\(\AgdaDatatype{Pauli}\) may require up to \(4^n\) cases, making even simple
proofs prohibitively verbose.

The alternative is to derive the things we need from \(\mathcal{E}!\) somehow.
As \(\AgdaDatatype{Pauli}\) is a simple finite type, the instance can be defined
in a similar way to those in lemma~\ref{split-enum-bool-top-bot}.
From here we can already derive decidable equality, a function which requires 16
cases if implemented manually.

For proof search, the procedure is a well-known one in Agda
\cite{devrieseBrightSideType2011}: we ask for the result of a decision procedure
as an \emph{instance argument}, which will demand computation during
typechecking.
\subsection{Multiple Arguments}
The automation machinery above only deals with single-argument predicates.
This is not a problem, as we know that we can work with multiple arguments by
currying and uncurrying, since all of the finiteness predicates are closed under
\(\times\).
To automate away the curry/uncurry noise we will use instance search, building
on \cite{allaisGenericLevelPolymorphic2019} to develop a small interface to
generic \(n\)-ary functions and properties.
Our generic representation can handle dependent \(\Sigma\) and \(\prod\)
types (rather than their non-dependent counterparts, \(\times\) and
\(\rightarrow\)).
This extension was necessary for our use case: it is mentioned in the paper
as the obvious next step. 
We also implement the curry-uncurry combinators as (verified) isomorphisms.

A full explanation of our implementation is beyond the scope of this work, so we
only present the finished interface, which is used like so:
\ExecuteMetaData[agda/Data/Pauli.tex]{assoc-prf}
\subsection{Synthesising Functions}
Finally, thanks to extensionality provided to us by HoTT, and the computation
properties provided by CuTT, we can derive decidable equality on functions over
finite types.
We can also use functions in our proof search.
Here, for instance, is a automated procedure which finds the
\(\AgdaFunction{not}\) function on \(\mathbf{Bool}\), given a specification.
\ExecuteMetaData[agda/Data/Pauli.tex]{not-spec}


\todo[inline]{Add funding ack:

  This work has been supported by the Science Foundation Ireland under the
  following grant: 13/RC/2D94 to Irish Software Research Centre.
}
\bibliographystyle{splncs04}
\bibliography{bibliography.bib}
\end{document} 