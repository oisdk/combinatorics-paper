\input{preamble}
\title{Finiteness, Cardinality, and Combinatorics in Homotopy Type Theory}
\author{Donnacha Oisín Kidney}
\authorrunning{D. O. Kidney}
\institute{University College Cork \and
  \email{o.kidney@cs.ucc.ie}}
\begin{document}
\maketitle
\begin{abstract}
  We explore five notions of finiteness in Homotopy Type Theory \cite{hottbook}.
  We prove closure properties about all of these notions, culminating in a proof
  that decidable Kuratowski-finite sets form a topos.

  We extend the definitions to include infinite types, developing a similar
  classification of countable types.

  We use the definition of finiteness to formalise \emph{species}, in much
  the same way as in \cite{yorgeyCombinatorialSpeciesLabelled2014}.
  A clear duality with containers
  \cite{abbottContainersConstructingStrictly2005} falls out naturally from our
  definition.

  We formalise our work in Cubical Agda
  \cite{vezzosiCubicalAgdaDependently2019}, and we implement a library for proof
  search (including combinators for level-polymorphic fully generic currying),
  and demonstrate how it can be used to both prove properties and synthesise
  full functions given desired properties.
\end{abstract}
\section{Introduction}
In this work, we will explore finite types in Cubical Type Theory
\cite{cohenCubicalTypeTheory2016}, and expose their relationship to infinite
types, species, and demonstrate their practical uses for proofs in dependently
typed programming languages.
\subsubsection{Strong Finiteness Predicates}
We will first explore the ``strong'' notions of finiteness (i.e. those at least
as strong as Kuratowski finiteness \cite{kuratowskiNotionEnsembleFini1920}),
with a special focus on cardinal finiteness (section~\ref{cardinal}), and
manifest enumerability (section~\ref{manifest-enumerability}), which is new, to
our knowledge.

\input{figures/finite-classification}
Figure~\ref{finite-classification} organises the predicates according to
their ``strength''; i.e. how much information they provide about a conforming
type.
For instance, a proof that some type \(A\) is manifestly Bishop finite (the
strongest of the notions, explored in section~\ref{manifest-bishop}) also tells
us that \(A\) is discrete (has decidable equality), and gives us a linear order
on the type.
A type that is Kuratowski finite (section~\ref{kuratowski}) has no such extra
features: indeed, we will see examples of Kuratowski finite types which are not
even sets, never mind discrete ones.

We will go through each of the predicates, proving how to weaken each (i.e. we
will provide a proof that every cardinally finite type is Kuratowski finite),
and how to strengthen them, given the required property.
In terms of figure~\ref{finite-classification}, this amounts to providing proofs
for each arrow.

We will---through the use of containers
\cite{abbottContainersConstructingStrictly2005}---formally prove the equivalence
these predicates have with the usual function relations i.e. we will show that a
proof of manifest enumerability is precisely equivalent to a surjection from a
finite prefix of the natural numbers.

For each predicate, we will also prove its closure over sums and products in
both dependent and non-dependent forms, if such a closure exists.
This will culminate in our main result for this section: the formal proof that
decidable Kuratowski finite sets form a topos.
More specifically, we show that cardinal finite sets form a topos, that
decidable Kuratowski finite sets are equivalent in strength to cardinal finite
sets, and carry the proof over.
This result relies on proofs on each of the other finiteness predicates.
\subsubsection{Species}
\todo[inline]{Redo this next paragraph}

\subsubsection{Infinite Types}
In section~\ref{infinite-cardinalities}, we will extend our study of finite
types to infinite but countable types.
We will see that the finiteness predicates are mirrored with countable
counterparts, and we will prove closure under the Kleene star and plus.

\subsubsection{Practical Uses of Finiteness}
Proofs of finiteness have well-known practical applications in
constructive mathematics \cite{firsovDependentlyTypedProgramming2015}.
In section~\ref{practical}, we build a library which exploits these uses in
Cubical Agda \cite{vezzosiCubicalAgdaDependently2019}, allowing automation of
complex proofs over finite types.
We frame this in terms of the principle of omniscience for finite types.
Thanks to the flexibility afforded to us by Cubical Type Theory, we are able to
go further than the usual examples of this kind of proof automation: as well as
proving properties about functions, we can synthesise functions whole-cloth from
their desired properties.
Through the unified interface for finite and countable types, we can
reuse the automation machinery for \emph{partial} proof search over infinite
search spaces.
Along the way, we extend the work in \cite{allaisGenericLevelPolymorphic2019} to
prove isomorphisms between the curried and uncurried forms of \(n\)-ary
dependent functions.
\section{Split Enumerability} \label{split-enumerable}
We will start with the simplest definition of finiteness: we say a set is
enumerable if there is a list of its elements which contains every element in
the set.
More formally:
\begin{rm-definition}[Split Enumerable Set]
  \begin{equation}
    \mathcal{E}!(A) = \Sigma {(\mathit{xs} : \textbf{List}(A))} , \Pi {(x : A)} , x \in xs
  \end{equation}
  We call the first component of this pair the ``support'' list, and the second
  component the ``cover'' proof.
\end{rm-definition}

We will at this point take a moment to define some of the types we used to
define \(\mathcal{E}!\).
Lists, and membership thereof, are defined using \emph{containers}.
\begin{rm-definition}[Container] \label{container-def}
  A container \cite{abbottContainersConstructingStrictly2005} is a pair
  \(S \triangleright P\) where \(S\) is a type, the elements of which are called
  the \emph{shapes} of the container, and \(P\) is a type family on \(S\), where
  the elements of \(P(s)\) are called the \emph{positions} of a container.
  \begin{equation}
    \begin{aligned}
      S : \text{Type}, P : S \rightarrow \text{Type} \\
      \mathbf{Container} = S \triangleright P
    \end{aligned}
  \end{equation}
  We ``interpret'' a container into a functor defined like so:
  \begin{equation}
    \llbracket S \triangleright P \rrbracket = \Pi {(X : \text{Type})} , \Sigma {(s : S)} , \left( P(s) \rightarrow X \right)
  \end{equation}
  Membership of a container can be defined like so:
  \begin{equation}
    x \in \mathit{xs} = \text{fiber}(\text{snd}(\mathit{xs}), x)
  \end{equation}
\end{rm-definition}
Containers can be used to define a wide variety of functors (streams, trees,
etc.): lists are all that interest us now.
\begin{rm-definition}[\mathbf{Fin}]
  \(\mathbf{Fin}\)(n) is the type of natural numbers smaller than \(n\).
  It is defined inductively, as follows:
  \begin{equation}
    \begin{aligned}
      \mathbf{Fin}(0) &= \bot \\
      \mathbf{Fin}(n + 1) &= \top + \mathbf{Fin}(n)
    \end{aligned}
  \end{equation}
\end{rm-definition}
\begin{rm-definition}[Lists]
  The ``shape'' of lists is \(\mathbb{N}\), indicating the length of the list in
  question.
  \begin{equation}
    \mathbf{List} = \llbracket \mathbb{N} , \mathbf{Fin} \rrbracket
  \end{equation}
\end{rm-definition}

Internally, in our formalisation, we actually use the standard
inductive definition of lists more often (it tends to work better in more
complex algorithms, and functions on it seems to satisfy the termination
checker more readily).
However, since both types are equivalent, univalence allows us to transport to
whichever representation is more convenient in a given situation.
For the higher-level proofs we present here, though, the container-based
definition greatly simplifies certain steps, which is why we have chosen it as
our representation.
\subsection{Split Surjections}
Another, equivalent way to define ``finiteness'' is via a (split) surjection
from a finite prefix of the natural numbers.
In this section, we will prove that equivalence, formally.

\begin{rm-theorem} \label{split-enum-surj}
  Split enumerability is equivalent to a split surjection from a finite prefix
  of the natural numbers.
  \begin{equation}
    \mathcal{E}!(A) \simeq \Sigma {(n : \mathbb{N})} , \left( \mathbf{Fin}(n) \twoheadrightarrow ! \; A \right)
  \end{equation}
\end{rm-theorem}
\begin{proof}
  The proof is surprisingly short: after sufficient inlining, it emerges that
  our goal is simply a reassociation.
  \ExecuteMetaData[agda/Cardinality/Container/Finite.tex]{split-surj}
  To be clear: in Agda, the proof could simply be \(\AgdaFunction{reassoc}\); we
  have written out the extra lines for clarity alone.
\end{proof}
\subsection{Decidable Equality}
\begin{rm-lemma} \label{split-enum-discrete}
  Any split enumerable type has decidable equality (is discrete).
\end{rm-lemma}
\begin{proof}
  We use a corollary that if there is a split-surjection from \(A\) to \(B\),
  and \(A\) is discrete, then \(B\) is also discrete.
\end{proof}
\begin{rm-lemma}
  Any split enumerable type is a set.
\end{rm-lemma}
\begin{proof}
  By Hedberg's theorem \cite{hedbergCoherenceTheoremMartinLof1998}, since split
  enumerable types have decidable equality
  (proposition~\ref{split-enum-discrete}), they are sets.
\end{proof}
\subsection{Closure}
In this section we will prove closure under various operations for split
enumerable sets.
We are working towards a topos proof, which requires us to prove closure under
a variety of operations: for now, we only have enough machinery to demonstrate
the semiring operations, and dependent sums.
in order to show closure under exponentials (function arrows), we will need an
equivalence with \(\mathbf{Fin}\), which will be provided in
section~\ref{manifest-bishop}.
\begin{rm-lemma}
  \(\bot\), \(\top\), and \(\mathbf{Bool}\) are all split enumerable.
\end{rm-lemma}
\begin{proof}
  These non-recursive types have similar, simple proofs.
  For each we first provide the support list: they are \([]\), \([\text{tt}]\),
  and \([\text{false}, \text{true}]\) respectively.
  The cover proof should return an index which points at the given element: for
  \(\bot\) this function is present via the principle of explosion, for \(\top\)
  we always return a \(0\), and for \(\mathbf{Bool}\) we return a \(0\) for
  \(\text{false}\), and a \(1\) for \(\text{true}\).
  \begin{multicols}{3}
    \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{bool}
    \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{unit}
    \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{empty}
  \end{multicols}
\end{proof}
Next, we will look into how to combine proofs of split enumerability.
\begin{rm-theorem}
  Split-enumerability is closed under \(\sum\).
\end{rm-theorem}
\begin{proof}
  Let \(E_A\) be a proof of split enumerability for some type \(A\), and \(E_U\)
  be a function of the type:
  \begin{equation}
    E_U : \Pi {(x : A)} , \mathcal{E}!(U(x))
  \end{equation}
  In other words, a function which returns a proof of split enumerability for
  each member of the family \(U\).

  To obtain the support list, we concatenate the support lists of all the proofs
  of split-finiteness for \(U\) over the support list of \(E_A\).
  In Agda:
  \ExecuteMetaData[agda/Cardinality/Finite/SplitEnumerable.tex]{sigma-enum}
  ``do-notation'' is available to us as we're working in the list monad.
\end{proof}
\begin{rm-lemma}
  Split-enumerability is closed under disjoint union (non-dependent sum) and
  Cartesian product (non-dependent product).
\end{rm-lemma}
\begin{proof}
  Both of these closures can be derived from closure of the \(\sum\) type.
  The non-dependent product is equivalent to a special case of \(\sum\):
  \begin{equation}
    A \times B \simeq \Sigma {(x : A)} , B
  \end{equation}
  And disjoint union between two types \(A\) and \(B\) can be represented by the
  following type:
  \begin{equation}
    A + B = \Sigma {(x : \mathbf{Bool})} , \text{if} \; x \; \text{then} \; A \; \text{else} \; B
  \end{equation}
  Then, since all of \(\mathbf{Bool}\), \(A\), and \(B\) are split enumerable,
  the type \(A + B\) is split enumerable.
\end{proof}
\section{Manifest Bishop Finiteness} \label{manifest-bishop}
\begin{rm-definition}[Manifest Bishop Finiteness]
  \begin{equation}
    \mathcal{B}(A) = \Sigma {(\mathit{xs} : \textbf{List}(A))} , \Pi {(x : A)} , x \inunique xs
  \end{equation}
\end{rm-definition}
The only difference between this predicate and split enumerability is the list
membership term: we use \(\inunique\) here, where \(x \inunique \mathit{xs}\) is
to be read as ``\(x\) occurs exactly once in \(\mathit{xs}\)''.
\begin{rm-definition}[Unique Membership]
  We say an item \(x\) is ``uniquely in'' some container \(\mathit{xs}\) if its
  membership in that list is a \emph{contraction}; i.e. its membership proof
  exists, and all such proofs are equal.
  \begin{equation}
    x \inunique \mathit{xs} = \text{isContr}(x \in \mathit{xs})
  \end{equation}
\end{rm-definition}

A nice consequence of prohibiting duplicates is that now the length of the
support list is the same as the cardinality of the set.
\subsection{Equivalence}
Where split enumerability was the enumeration form of a surjection from
\(\mathbf{Fin}\), we see here that manifest Bishop finiteness is the enumeration
form of an \emph{equivalence} with \(\mathbf{Fin}\).
\begin{rm-lemma} \label{bishop-equiv}
  A proof of manifest Bishop finiteness is equivalent to an equivalence with a
  finite prefix of the natural numbers.
  \begin{equation}
    \mathcal{B}(A) \simeq \Sigma {(n : \mathbb{N})} , \left( \mathbf{Fin}(n) \simeq A \right)
  \end{equation}
\end{rm-lemma}
\begin{proof}
  There are many equivalent definitions of equivalence in HoTT.
  Here we take the version preferred in the Cubical Agda library: contractible
  maps \cite{hottbook}.
  Because of the parallels between contractible maps and split surjections,
  the proof proceeds much the same as \ref{split-enum-surj}.
  In other words, the definition of Bishop finiteness is itself a reassociation
  of a contractible map.
\end{proof}
\subsection{Relationship to Split Enumerability}
We now show that manifest Bishop finiteness has equal strength to split
enumerability.
\begin{rm-lemma}
  Any manifest Bishop finite set is split enumerable.
\end{rm-lemma}
\begin{proof}
  The support set carries over simply, and the cover proof can be taken from the
  first component of the cover proof from the proof of manifest Bishop
  finiteness.
\end{proof}
\begin{rm-theorem} \label{split-enum-to-manifest-bishop}
  Any split enumerable set is manifest Bishop finite.
\end{rm-theorem}
\begin{proof}
  Let \(E\) be a proof of split enumerability for some set \(A\).
  From proposition~\ref{split-enum-discrete} we can derive decidable equality on
  \(A\), and using this we can define a function \(\text{uniques}\) which filters
  out duplicates from lists of \(A\)s.
  \begin{equation}
    \text{uniques} : \textbf{List}(A) \rightarrow \textbf{List}(A)
  \end{equation}
  This gives us our support list.

  It suffices now to prove the following:
  \begin{equation}
    \Pi {(x : A)} , \Pi {(\mathit{xs} : \textbf{List}(A))} , x \in \mathit{xs} \rightarrow x \inunique \text{uniques}(\mathit{xs})
  \end{equation}
  And from that we can generate our cover proof.
\end{proof}
Note that while manifest Bishop finiteness as split enumerability are equivalent
in ``strength'', the two types are not equivalent.
In particular, there are infinitely many inhabitants of \(\mathcal{E}!\), while
for a type \(A\) with \(n\) inhabitants, there are only \(n!\) inhabitants of
\(\mathcal{B}(A)\).
\subsection{Closure}
Proving equal strength of split enumerability and manifest Bishop finiteness
allows us to carry all of the previous proofs of closure over to manifest Bishop
finite sets (and vice-versa).
Missing from our previous proofs was a proof of closure of functions.
We remedy that here.
\begin{rm-theorem}
  Manifest bishop finiteness is closed over dependent functions
  (\(\prod\)-types).
  \begin{equation}
    \frac{
      \mathcal{B}(A) \; \; \; \Pi {(x : A)} , \mathcal{B}\left( U(x) \right)
    }{
      \mathcal{B}\left(\Pi {(x : A)} , U(x)\right)
    }
  \end{equation}
\end{rm-theorem}
\begin{proof}
  This proof is essentially the composition of two transport operations, made
  available to us via univalence.
  
  First, we will simplify things slightly by working only with split
  enumerability.
  As this is equal in strength to manifest Bishop finiteness, any closure proofs
  carry over.

  Secondly, we will replace \(A\) in all places with \(\mathbf{Fin}(n)\).
  Since we have already seen an equivalence between these two types, we are
  permitted to transport along these lines.
  This is the first transport operation.

  The bulk of the proof now is concerned with proving the following:
  \begin{equation}
    \left( \Pi {(x : \mathbf{Fin}(n))} , \mathcal{E}!(A(x)) \right) \rightarrow \mathcal{E}!\left( \Pi {(x : \mathbf{Fin}(n))} , A(x) \right)
  \end{equation}
  Our strategy to accomplish this will be to consider functions from
  \(\mathbf{Fin}(n)\) as \(n\)-tuples over some type family \(T : \mathbb{N}
  \rightarrow \text{Type}\).
  \begin{equation}
    \begin{aligned}
      \mathbf{Tuple}(T, 0)   &= \top \\
      \mathbf{Tuple}(T, n+1) &= T(0) \times \mathbf{Tuple}(T \circ \text{suc}, n)
    \end{aligned}
  \end{equation}
  This type is manifestly Bishop finite, as it is constructed only from products
  and the unit type.
  
  We then prove an isomorphism between this representation and \(\Pi\)-types.
  \begin{equation}
    \mathbf{Tuple}(T, n) \iff \Pi {(x : \mathbf{Fin}(n))} , T(x)
  \end{equation}
  This allows us to transport our proof of finiteness on tuples to one on
  functions from \(\mathbf{Fin}\) (our second transport operation), proving our
  goal.
\end{proof}
\section{Manifest Enumerability} \label{manifest-enumerability}
A defining feature of split enumerability and Bishop finiteness is decidability:
both predicates imply a decidable equality function on the underlying type.
To find a predicate for finiteness which doesn't imply this, and therefore
works with types other than just sets, we \emph{truncate} the membership proof.
\begin{rm-definition}[Manifest Enumerability]
  \begin{equation}
    \mathcal{E}(A) = \Sigma {(\mathit{xs} : \mathbf{List}(A))} , \Pi {(x : A)} , \lVert x \in \mathit{xs} \rVert
  \end{equation}
\end{rm-definition}
\begin{rm-definition}[Propositional Truncation]a \label{prop-trunc}
  The type \(\lVert A \rVert\) on some type \(A\) is a propositionally truncated
  proof of \(A\).
  In other words, it is a proof that some \(A\) exists, but it does not tell you
  \emph{which} \(A\).

  It is defined as a Higher Inductive Type:
  \begin{equation}
    \begin{aligned}
      \lVert A \rVert &= \\
        &| \; \lvert \cdot \rvert : A \rightarrow \lVert A \rVert ; \\
        &| \; \text{squash} : \Pi {(x, y : \lVert A \rVert)} , x \equiv y  ; \\
    \end{aligned}
  \end{equation}

  We will use and consume values of the type \(\lVert A \rVert\) in three main
  ways.
  \begin{enumerate}
    \item \label{elim-prop-prop} We can first eliminate from \(\lVert A \rVert\)
      into any type which is a proposition.
      In other words, given a function \(f : A \rightarrow B\), and a proof that
      \(B\) is a proposition, we can construct a function \(\lVert A \rVert
      \rightarrow B\).
    \item \label{elim-prop-monad} As a consequence of this first point, we can
      always eliminate into another propositionally truncated type.
      As a result, \(\lVert \cdot \rVert\) forms a Monad: for our purposes, this
      simply means tat we can work ``under'' a propositional truncation in an
      ergonomic way.
    \item \label{elim-prop-coh} We can eliminate from \(\lVert A \rVert\) with a
      function \(f : A \rightarrow B\) iff \(f\) ``doesn't care'' about the
      choice of \(A\).
      \begin{equation}
        \Pi {(x , y : A)} , f(x) \equiv f(y)
      \end{equation}
      Formally speaking, \(f\) needs to be ``coherently constant''
      \cite{krausGeneralUniversalProperty2015}, and \(B\) needs to be an
      \(n\)-type for some finite \(n\).
  \end{enumerate}
\end{rm-definition}

By hiding the position, we have essentially removed the ``decidable'' component
from split enumerability.
Our predicate now becomes general enough to work with non-sets: we will show
here that the circle is manifestly enumerable.
\begin{rm-theorem}
  The circle \(S^1\) is manifestly enumerable.
\end{rm-theorem}
\begin{proof}
  As the cover proof is a truncated proposition, we need only consider the point
  constructors, making this poof the same as the proof of split enumerability on
  \(\top\).
\end{proof}
\subsection{Surjections}
This predicates relation to surjectivity is much the same as split
enumerability's relation to \emph{split} surjectivity.
\begin{rm-lemma}
  A proof of manifest enumerability is equivalent to a surjection from a finite
  prefix of the natural numbers.
\end{rm-lemma}
\begin{proof}
  As with the other surjection proof (lemma~\ref{split-enum-surj}), this is
  simply a reassociation.
\end{proof}
\subsection{Relation to Split Enumerability}
\begin{rm-lemma}
  Any split enumerable type is also manifestly enumerable.
\end{rm-lemma}
\begin{proof}
  The proof carries over via truncation of the cover proof.
\end{proof}
\begin{rm-theorem} \label{manifest-enum-to-split}
  A manifestly enumerable type with decidable equality is split enumerable.
\end{rm-theorem}
\begin{proof}
  The support list stays the same between both enumerability proofs.

  For the cover proof, we first need the following function which searches a
  list for a particular element (given decidable equality on \(A\)).
  \begin{equation}
    \decin \; : \Pi(x : A) , \Pi(\mathit{xs} : \mathbf{List}(A)) , \mathbf{Dec}(x \in \mathit{xs})
  \end{equation}
  Where \(\mathbf{Dec}(A)\) is a decision on some type \(A\).

  We then need to convert a value of type \(\mathbf{Dec}(x \in \mathit{xs})\) to
  \(x \in \mathit{xs}\).
  We use the following to do that:
  \begin{equation}
    \text{recompute} : \mathbf{Dec}(A) \rightarrow \lVert A \rVert \rightarrow A
  \end{equation}
  A propositionally truncated value can be used to \emph{refute} its negation.
\end{proof}
\subsection{Closure}
\begin{rm-lemma}
  Manifest enumerability is closed under dependent sum, disjoint union
  (non-dependent sum), and Cartesian product (non-dependent product).
\end{rm-lemma}
\begin{proof}
  For these three closures, the proofs on split enumerability consisted of a
  list manipulation followed by a proof that membership was preserved by the
  list manipulation.
  Because we separate these two concerns, the proofs carry over onto manifest
  enumerability: the support list manipulation stays the same, and the
  cover proofs are performed ``under'' the truncation.
\end{proof}
Notice that we do not have closure under functions: without decidability,
manifest enumerability is not closed under function arrows.
\section{Cardinal Finiteness} \label{cardinal}
For manifest enumerability, we removed the need for decidable equality: in these
next two finiteness predicates, we remove the need for a total order on the
underlying type.
\begin{rm-definition}[Cardinal Finiteness]
  A type \(A\) is cardinally finite, \(\mathcal{C}\), if it has a
  propositionally-truncated proof of bishop finiteness.
  \begin{equation}
    \mathcal{C}(A) = \lVert \mathcal{B}(A) \rVert
  \end{equation}
\end{rm-definition}
\subsection{Closure}
The closure proofs for cardinal finiteness are especially easy.
In contrast to manifest enumerability, under the propositional truncation we
have a full proof of bishop finiteness, meaning that all of the closure proofs
carry over.
\begin{rm-lemma}
  Cardinal finiteness is closed under dependent and non-dependent sums,
  products, and functions.
\end{rm-lemma}
\begin{proof}
  All closure functions can be lifted under propositional truncation.
  Therefore, cardinal finiteness has the same closure properties as manifest
  Bishop finiteness.
\end{proof}
\subsection{Decidable Equality}
\begin{rm-theorem} \label{cardinal-finite-discrete}
  Any cardinal-finite set has decidable equality.
\end{rm-theorem}
\begin{proof}
  We will use eliminator~\ref{elim-prop-prop} from definition~\ref{prop-trunc}.
  Manifest Bishop finiteness implies decidable equality already, so our task
  here is to prove that decidable equality itself is a proposition.

  We know that if a type \(A\) is a proposition, then the decision over that
  type is also a proposition.
  Then, via Hedberg's theorem, we know that any type with decidable equality is
  a set, meaning that paths in that type are themselves propositions.
  Therefore we can derive that a decision of equality on elements with decidable
  equality is a proposition, and by function extensionality we see that
  decidable equality is itself a proposition.
\end{proof}
\subsection{Cardinality}
\begin{rm-theorem}
  Given a cardinally finite type, we can derive the type's cardinality, as well
  as a propositionally truncated proof of equivalence with \(\textbf{Fin}\)s of
  the same cardinality.
  \begin{equation}
    \mathcal{C}(A) \rightarrow \Sigma {(n : \mathbb{N})} , \lVert \textbf{Fin}(n) \simeq A \rVert
  \end{equation}
\end{rm-theorem}
\begin{proof}
  Our task here is to ``pull out'' the cardinality of the set from under the
  propositional truncation.
  In effect, we need the following function:
  \begin{equation}
    \left\lVert \Sigma {(n : \mathbb{N})} , \left( \mathbf{Fin}(n) \simeq A \right) \right\rVert \rightarrow
    \Sigma {(n : \mathbb{N})} , \left\lVert \mathbf{Fin}(n) \simeq A \right\rVert
  \end{equation}

  We will use eliminator~\ref{elim-prop-coh} from definition~\ref{prop-trunc}.
  We eliminate with the following function:
  \ExecuteMetaData[agda/Cardinality/Finite/Cardinal.tex]{trunc-alg}

  To show that \(\text{alg}\) is coherently constant, we first notice that the
  second element of the output pair is propositionally truncated, meaning that
  it is trivially equal to any other element of the same type.
  Our task, then, simplifies to demonstrating that the first element of the
  output pair is coherently constant.
  \begin{equation}
    \Pi {(x : \Sigma {(n : \mathbb{N})} , \textbf{Fin}(n) \simeq A)} ,
    \Pi {(y : \Sigma {(m : \mathbb{N})} , \textbf{Fin}(m) \simeq A)} ,
    n \equiv m
  \end{equation}

  Notice that \(\mathbf{Fin}(n)\) and \(\mathbf{Fin}(m)\) are both equivalent to
  \(A\): we can join these proofs together, giving us the following:
  \begin{equation}
    \textbf{Fin}(n) \equiv \textbf{Fin}(m)
  \end{equation}
  All that remains now is to prove that \(\mathbf{Fin}\) is injective.
  Though the proof is surprisingly complex, it is a well-known puzzle in
  Martin-Löf type theory.
  Our proof does not differ significantly from standard approaches, so we will
  not detail it here.
\end{proof}
\subsection{Relation to Manifest Bishop Finiteness}
Cardinal finiteness tells us that there is an isomorphism between a type and
\(\mathbf{Fin}\); it just doesn't tell us \emph{which} isomorphism.
To take a simple example, \(\mathbf{Bool}\) has 2 possible isomorphisms with the
set \(\mathbf{Fin}(2)\): one where false maps to 0, and true to 1; and another
where false maps to 1 and true to 0.

To convert from Cardinal finiteness to Bishop finiteness, then, requires that we
supply enough information to identity a particular isomorphism.
A total order is sufficient here: it will give us enough to uniquely order the
support list invariant under permutations.
This tells us what we already knew in the introduction: manifest Bishop
finiteness is cardinal finiteness plus an order.

\begin{rm-theorem}
  Any cardinal finite type with a (decidable) total order is manifestly Bishop
  finite.
\end{rm-theorem}
\begin{proof}
  This proof is quite involved, and will rely on several subsequent lemmas, so
  we will give only its outline here.
  \begin{itemize}
    \item First, we will convert to manifest enumerability: knowing that the
      underlying type is discrete (theorem~\ref{cardinal-finite-discrete}) we can
      go from manifest enumerability to split enumerability
      (lemma~\ref{manifest-enum-to-split}), and subsequently to manifest Bishop
      finiteness (lemma~\ref{split-enum-to-manifest-bishop}).
    \item To convert to manifest enumerability, we need to provide a support
      list: this cannot simply be the support list hidden under the truncation,
      since that would violate the hiding promised by the truncation.
      Instead, we sort the list (using insertion sort).
      We must, therefore, prove that insertion sort is invariant under all
      support lists in cardinal finiteness proofs.
    \item We do this by first showing that all support lists in cardinal
      finiteness proofs are permutations of each other, and then that insertion
      sort is invariant under permutations.
    \item Given our particular definition of permutations, cover proofs
      transfers naturally between lists which are permutations of each other.
  \end{itemize} 
\end{proof}
Now we will build up the toolkit we need to perform the above steps.
First, permutations.
\begin{rm-definition}[List Permutations]
  We say that two lists are permutations of each other if there is an
  isomorphism between membership proofs
  \cite{danielssonBagEquivalenceProofRelevant2012}.
  \begin{equation}
    \mathit{xs} \leftrightsquigarrow \mathit{ys} = \Pi {(x : A)} , x \in \mathit{xs} \iff x \in \mathit{ys}
  \end{equation}
  Seen another way, a permutation is an isomorphism of cover proofs.
\end{rm-definition}
We also prove some of the identities you might expect with regards to
permutations.
\begin{rm-lemma}
  Insertion sort is invariant under permutations.
  \begin{equation}
    \mathit{xs} \leftrightsquigarrow \mathit{ys} \implies \text{sort}(\mathit{xs}) \equiv \text{sort}(\mathit{ys})
  \end{equation}
\end{rm-lemma}
\begin{proof}
  Again, this proof is quite complex, so we only give a sketch here.
  First, we prove two properties about insertion sort:
  \begin{enumerate}
    \item It returns a sorted list.
    \item It a returns a list that is a permutation of its input.
  \end{enumerate}
  The second of these points allows us to show that \(\text{sort}(\mathit{xs})\)
  is a permutation of \(\text{sort}(\mathit{ys})\).
  \begin{equation}
    \text{sort}(\mathit{xs}) \leftrightsquigarrow \mathit{xs} \leftrightsquigarrow \mathit{ys} \leftrightsquigarrow \text{sort}(\mathit{ys})
  \end{equation}
  Then, we show that any lists which are both sorted and permutations of each
  other are equal.
  Both of these conditions are true for the output of \(\text{sort}\).
\end{proof}
\section{Kuratowski Finiteness} \label{kuratowski}
Finally we arrive at Kuratowski finiteness
\cite{kuratowskiNotionEnsembleFini1920}.
\begin{rm-definition}[Kuratowski-Finite Set]
  The Kuratowski finite set is a free join semilattice (or, equivalently, a free
  commutative idempotent monoid).
  HITs are required to define this type
  \cite{altenkirchDefinableQuotientsType2011}:
  \begin{equation}
    \begin{aligned}
      \mathcal{K}(A) &=  \\
        &\left\vert \; \cdot \dblcolon \cdot : A \times \mathcal{K}(A) \rightarrow \mathcal{K}(A) \right; \\
        &\left\vert \; [] : \mathcal{K}(A) \right; \\
        &\left\vert \; \text{com} : \Pi (x, y: A) , \Pi (\mathit{xs}: \mathcal{K}(A)) , x \dblcolon y \dblcolon \mathit{xs} \equiv y \dblcolon x \dblcolon \mathit{xs} \right; \\
        &\left\vert \; \text{dup} : \Pi (\mathit{x}: A) , \Pi (\mathit{xs}: \mathcal{K}(A)) , x \dblcolon x \dblcolon \mathit{xs} \equiv x \dblcolon \mathit{xs} \right; \\
        &\left\vert \; \text{trunc} : \Pi (\mathit{xs}, \mathit{ys}: \mathcal{K}(A)) , \Pi (p, q : \mathit{xs} \equiv \mathit{ys}) , p \equiv q \right;
    \end{aligned}
  \end{equation}
  The \(\text{com}\) and \(\text{dup}\) constructors effectively add
  commutativity and idempotency to the free monoid (the list), which is made by
  the first two constructors.
  The last constructor makes \(\mathcal{K}(A)\) a set.

  To eliminate from \(\mathcal{K}(A)\), we have to provide equations for each of
  the point constructors which obey the equations of the path constructors.
  For \(\text{com}\) and \(\text{dup}\), this means ensuring that the fold is
  commutative and idempotent, whereas \(\text{trunc}\) means we can only
  eliminate into sets.
\end{rm-definition}

Other representations of \(\mathcal{K}\) \cite{fruminFiniteSetsHomotopy2018}
are more explicit constructions of the free join semilattice (i.e. there is a
point constructors for union instead of cons, and then path constructors for
the associativity and identity laws), but we have found this representation
easier to work with.
Nonetheless, the alternative representation is included in our formalisation,
and proven equivalent to the representation here.
\begin{rm-definition}[Membership of \mathcal{K}]
  First, we need to provide equations for the two point constructors.
  \begin{equation}
    \begin{alignat}{2}
      x &\in& [] &= \bot \\
      x &\in& y \dblcolon \mathit{xs} &= \lVert (x \equiv y) + (x \in \mathit{xs}) \rVert
    \end{alignat}
  \end{equation}
  The \(\text{com}\) and \(\text{dup}\) constructors are handled by proving that
  the truncated form of \(+\) is itself commutative and idempotent.
  The type of propositions is itself a set, satisfying the \(\text{trunc}\)
  constructor.
\end{rm-definition}
\begin{rm-definition}[Kuratowski Finiteness]
  A type is Kuratowski finite iff there exists a Kuratowski Set which contains
  all of its elements.
  \begin{equation}
    \mathcal{K}^{f}(A) = \Sigma {(\mathit{xs} : \mathcal{K}(A))} , \Pi (x : A) , x \in \mathit{xs}
  \end{equation}
\end{rm-definition}

\subsection{Strength}
Since the Kuratowski set is a departure in structure from our previous
list-based notions of finiteness, it makes sense to first look for the closest
list-based analogue.
As it turns out, that analogue is manifestly enumerable finiteness, with the
order removed.
\begin{rm-theorem}
  A proof of Kuratowski finiteness is equivalent to a propositionally truncated
  proof of enumerability.
  \begin{equation}
    \mathcal{K}^f(A) \simeq \lVert \mathcal{E}(A) \rVert
  \end{equation}
\end{rm-theorem}
\begin{proof}
  We prove by way of an isomorphism.
  In the first direction (from \(\mathcal{K}\) to \(\mathcal{E}\)), because we
  are eliminating into a proposition, we need only deal with the point
  constructors.
  For these, we convert the \(\mathcal{K}\) cons to its list counterpart, and
  similarly for the nil constructor.

  The other direction is proven in \cite{fruminFiniteSetsHomotopy2018}, so we
  will not describe it here.
\end{proof}
Based on previous proofs, we can derive that if we add decidability to a
Kuratowski finite type we retrieve cardinal finiteness.
\begin{rm-lemma}
  Any Kuratowski finite set with decidable equality is cardinally finite.
\end{rm-lemma}
\begin{proof}
  We first convert to a propositionally truncated proof of manifest
  enumerability.
  From here, we can convert to manifest Bishop finiteness under the truncation
  with our decidable equality proof.
\end{proof}
\subsection{Topos}
At this point, we see that a ``decidable Kuratowski finite set'' is precisely
equivalent to a cardinal finite set.
From this, we can lift over all of the properties of cardinal finite sets.
In particular, we see that decidable Kuratowski finite sets form a \emph{topos}.
\todo[inline]{Fill in rest}
\subsection{Closure}
\begin{rm-theorem}
  Kuratowski finite sets are closed under \(\sum\).
\end{rm-theorem}
\begin{proof}
  This follows from the \(\sum\) closure proof on manifestly enumerable types.
\end{proof}
\section{Species and Containers} \label{species-and-containers}
\todo[inline]{Figure out this section}
\section{Infinite Cardinalities} \label{infinite-cardinalities}
While the previous section purported to be about finite sets, we can now see
that it was really only studying surjections and isomorphisms of different
flavours between types and \(\mathbf{Fin}\).
The natural next question which arises, then, is if we can extend that work to
surjections and isomorphisms with \(\mathbb{N}\).
In more standard language, what we're referring to here is of course
countable infinity and related concepts.
However, as with finite types, the ``countably infinite'' types have more
varieties in constructive mathematics than their classical counterparts.
\subsection{Split Countable Types}
Our first foray into the world of countable types will be a straightforward
analogue to the split enumerable types.
We need change only one element: instead of a support \emph{list}, we instead
have a support \emph{stream}, which is its infinite, coinductive counterpart.
\begin{rm-definition}[Stream]
  We will work with two isomorphic definitions of streams.
  The first is the following:
  \begin{equation}
    \mathbf{Stream}(A) = \mathbb{N} \rightarrow A
  \end{equation}
  Conceptually, a stream is like a list without an end.
  Of course, such a type can not be defined in the same way as a list: it would
  be impossible to construct a value, as inductive types do not admit
  infinitely-sized inhabitants.
\end{rm-definition}
We can now define the split countable types.
\begin{rm-definition}[Split Countability]
  \begin{equation}
    \mathcal{E}!(A) = \Sigma {(\mathit{xs} : \mathbf{Stream}(A))} , \Pi {(x : A)} , x \in \mathit{xs}
  \end{equation}
\end{rm-definition}
\subsubsection{\(\Sigma\) Closure}
We know that countable infinity is not closed under the exponential (function
arrow), so the only closure we need to prove is \(\Sigma\) to cover all of
what's left.
To do this we have to take a slightly different approach to the functions we
defined before.
Figure~\ref{pairings} illustrates the reason why: previously, we used the
``Cartesian'' product pairing for each support list.
This diverges if the first list is infinite, never exploring anything other than
the first element in the second list.
Instead, we use here the cantor pairing function, which performs a breadth-first
search of the pairings of both lists.
\begin{figure}
  \centering
  \begin{subfigure}[b]{.5\linewidth}
    \begin{tikzcd}[sep=tiny,font=\footnotesize]
      (1,e) \ar[rdddd, out=-45, in=135] & (2,e) \ar[rdddd, out=-45, in=135] & (3,e) \ar[rdddd, out=-45, in=135] & (4,e) \ar[rdddd, out=-45, in=135] & (5,e)        \\
      (1,d) \ar[u]     & (2,d) \ar[u]    & (3,d) \ar[u]    & (4,d) \ar[u]    & (5,d) \ar[u] \\
      (1,c) \ar[u]     & (2,c) \ar[u]    & (3,c) \ar[u]    & (4,c) \ar[u]    & (5,c) \ar[u] \\
      (1,b) \ar[u]     & (2,b) \ar[u]    & (3,b) \ar[u]    & (4,b) \ar[u]    & (5,b) \ar[u] \\
      (1,a) \ar[u]     & (2,a) \ar[u]    & (3,a) \ar[u]    & (4,a) \ar[u]    & (5,a) \ar[u]
    \end{tikzcd}
    \caption{Cartesian}
    \label{cartesian}
  \end{subfigure}%
  \begin{subfigure}[b]{.5\linewidth}
    \begin{tikzcd}[sep=tiny,font=\footnotesize]
      (1,e) \ar[dr] & (2,e) \ar[dr]  & (3,e) \ar[dr]    & (4,e) \ar[dr] & (5,e) \\
      (1,d) \ar[dr] & (2,d) \ar[dr]  & (3,d) \ar[dr]    & (4,d) \ar[dr] & (5,d) \ar[u] \\
      (1,c) \ar[dr] & (2,c) \ar[dr]  & (3,c) \ar[dr]    & (4,c) \ar[dr] & (5,c) \ar[uul] \\
      (1,b) \ar[dr] & (2,b) \ar[dr]  & (3,b) \ar[dr]    & (4,b) \ar[dr] & (5,b) \ar[uuull, out=130, in=-50] \\
      (1,a) \ar[u]  & (2,a) \ar[uul, out=130, in=-50] & (3,a) \ar[uuull, out=130, in=-50] & (4,a) \ar[uuuulll, out=130, in=-50] & (5,a) \ar[uuuulll, out=130, in=-50]
    \end{tikzcd}
    \caption{Cantor}
    \label{cantor}
  \end{subfigure}
  \caption{Two possible products for the sets \(\left[ 1 \dots 5 \right]\) and
    \(\left[  a \dots e \right]\)}
  \label{pairings}
\end{figure}
\begin{rm-theorem} \label{split-countability-sigma}
  Split countability is closed under \(\Sigma\).
\end{rm-theorem}
\begin{proof}
  This final proof consists of the support stream, and the proof that the
  support stream covers the input.

  As mentioned, we will have to use a more sophisticated pairing function than
  the Cartesian product we used before.
  We instead will mirror the pattern in figure~\ref{cantor}.
  To greatly simplify the algorithm, we will produce an intermediate stream of
  lists which consists of the diagonals in the diagram.
  We then concatenate these streams into the final support stream.
\end{proof}
\begin{rm-lemma}
  Split countability is closed under non-dependent product and sum.
\end{rm-lemma}
\begin{proof}
  Follows from theorem~\ref{split-countability-sigma}.
\end{proof}
\subsubsection{Kleene Star}
While we lose some closures with the inclusion of infinite types, we gain some
others.
In particular, we have the Kleene star.
This means, in effect, that we have closure under lists.
\begin{rm-theorem}
  Split countability is closed under Kleene star.
  \begin{equation}
    \mathcal{E}!(A) \rightarrow \mathcal{E}!(\mathbf{List}(A))
  \end{equation}
\end{rm-theorem}
\begin{proof}
  As with the proof of closure under \(\sum\), our main task here is to figure
  out a way to arrange the indices such that 
\end{proof}
\subsection{Manifest Countability}
As we can quotient out the position information with finite types, so can we with
countable types.
\todo[inline]{fill in rest here}
\section{Practical Uses} \label{practical}
The theory of finite types in constructive mathematics, and in HoTT in
particular, is rich and interesting, as we hope we have demonstrated thus far.
As well as being theoretically interesting, however, the proofs and combinators
we have defined here are \emph{practically} useful.
\subsection{Omniscience}
In this section we are interested in restricted forms of the limited principle
of omniscience \cite{myhillErrettBishopFoundations1972}.
\begin{rm-definition}[Limited Principle of Omniscience]
  For any type \(A\) and predicate \(P\) on \(A\), the limited principle of
  omniscience is as follows:
  \begin{equation}
    \left( \Pi {(x : A)} , \mathbf{Dec}(P(x)) \right) \rightarrow \mathbf{Dec} \left( \Sigma {(x : A)} , P(x) \right)
  \end{equation}
  In other words, for any decidable predicate the existential quantification of
  that predicate is also decidable.
\end{rm-definition}
The limited principle of omniscience is non-constructive, but individual types
can themselves satisfy omniscience.
In particular, \emph{finite} types are omniscient.

There is also a universal form of omniscience, which we call exhaustibility.
\begin{rm-definition}[Exhaustibility]
  We say a type \(A\) is exhaustible if, for any decidable predicate \(P\) on
  \(A\), the universal quantification of the predicate is decidable.
  \begin{equation}
    \left( \Pi {(x : A)} , \mathbf{Dec}(P(x)) \right) \rightarrow \mathbf{Dec} \left( \Pi {(x : A)} , P(x) \right)
  \end{equation}
\end{rm-definition}

All of the finiteness predicates we have seen justify exhaustibility.
We will only prove it once, then, for the weakest:
\begin{rm-theorem}
  Kuratowski-finite types are exhaustible.
\end{rm-theorem}
\begin{proof}
  \todo[inline]{Proof}
\end{proof}

Omniscience is stronger than exhaustibility, as we can derive the latter from
the former:
\begin{rm-lemma} \label{omniscient-is-exhaustible}
  Any omniscient type is exhaustible.
\end{rm-lemma}
\begin{proof}
  For decidable propositions, we know the following:
  \begin{equation} \label{lem-conversion}
    \Pi (x : A) , P(x) \leftrightarrow \neg \Sigma (x : A) , \neg P(x) 
  \end{equation}
  To derive exhaustibility from omniscience, then, we run the predicate in its
  negated form, and then subsequently negate the result.
  The resulting decision over \(\neg \Sigma(x : A) , \neg P(x)\) can be
  converted into \(\Pi (x : A) , P(x)\).
\end{proof}
We cannot derive, however, that any exhaustible type is omniscient, as we do not
have the inverse of equation~\ref{lem-conversion}:
\begin{equation} \label{choice-conversion}
  \Sigma (x : A) , P(x) \leftrightarrow \neg \Pi (x : A) , \neg P(x)
\end{equation}
Such an equation would allow us to pick a representative element from any type,
which is therefore non-constructive.
In a sense, equation~\ref{lem-conversion} requires a form of LEM on the
proposition (i.e. requires it to be decidable), whereas
equation~\ref{choice-conversion} requires a form of choice.
Those finiteness predicates which are ordered do in fact give us this form of
choice, so the conversion is valid.
As such, all of the ordered finiteness predicates imply omniscience.
Again, we will prove it only for the weakest.
\begin{rm-theorem}
  Manifest enumerable types are omniscient.
\end{rm-theorem}
\begin{proof}
  \todo[inline]{Proof}
\end{proof}
Finally, we do have a form of omniscience for prop-valued predicates, as they do
not care about the chosen representative.
\begin{rm-theorem}
  Kuratowski finite types are omniscient about prop-valued predicates.
\end{rm-theorem}
\begin{proof}
  \todo[inline]{Proof}
\end{proof}
\subsection{Synthesising Pattern-Matching Proofs}
In particular, they can automate large proofs by analysing every possible case.
In \cite{firsovDependentlyTypedProgramming2015}, the \(\AgdaDatatype{Pauli}\)
group is used as an example.
\ExecuteMetaData[agda/Data/Pauli.tex]{def}
For this type, there are several practical tasks we hope to achieve with the
help of our finiteness combinators:
\begin{itemize}
  \item Define decidable equality on the type
  \item Define the group operation on the type
  \item Prove properties about the group operation
\end{itemize}
Unfortunately, the simple pattern-matching way to do many of these tasks is
prohibitively verbose.
As \(\AgdaDatatype{Pauli}\) has 4 constructors, \(n\)-ary functions on
\(\AgdaDatatype{Pauli}\) may require up to \(4^n\) cases.
A proof of decidable equality is one such function: it can be seen fully
worked-through in the appendix.

The alternative is to derive the things we need from \(\Enum!\) somehow.
First, then, we need an instance for \(\AgdaDatatype{Pauli}\):
\ExecuteMetaData[agda/Data/Pauli.tex]{inst}
From here we can already derive decidable equality, a function which requires 16
cases if implemented manually.

For proof search, the procedure is a well-known one in Agda
\cite{devrieseBrightSideType2011}: we ask for the result of a decision procedure
as an \emph{instance argument}, which will demand computation during
typechecking.
\ExecuteMetaData[agda/Cardinality/Finite/Search.tex]{auto}
And finally we can prove the property we wanted to on \(\AgdaDatatype{Pauli}\)
like so:
\ExecuteMetaData[agda/Data/Pauli.tex]{noninst-prf} 

As a quick aside, when the property is \emph{not} true, for instance:
\ExecuteMetaData[agda/Data/Pauli.tex]{contra}
Agda will fail by not finding an instance of \(\bot\).
The error message specifically is:
\begin{displayquote}
  \verb+No instance of type ⊥ was found in scope.+
\end{displayquote}
We can actually display a counterexample, by defining a custom empty type
parameterised by the counterexample itself.
\ExecuteMetaData[agda/Cardinality/Finite/Search.tex]{counterexample-def}
Combined with some other changes to the combinators, this will give the
following more helpful error message:
\begin{displayquote}
  \verb+No instance of type Counterexample X was found in scope.+
\end{displayquote}
\subsection{Instances}
Running decision procedures during typechecking isn't the only use of instances:
we will also use them to automate the finding of a proof of finiteness for a
given type.
The change to our \(\AgdaFunction{∀↯}\) is simple: we just change the first
parameter from explicit to an instance.
\ExecuteMetaData[agda/Cardinality/Finite/Search.tex]{auto-inst}

The change to the \(\AgdaDatatype{Pauli}\) proof of cancellation isn't
groundbreaking at first:
\ExecuteMetaData[agda/Data/Pauli.tex]{cancel-auto}
The real benefit is that we have provided instances for things like tuples,
meaning we can now prove \(n\)-ary properties.
\ExecuteMetaData[agda/Data/Pauli.tex]{comm-uncurried}
\subsection{Generic Currying and Uncurrying}
While we have arguably removed the bulk of the boilerplate from the automated
proofs, there is still the case of the ugly noise of currying and uncurrying.
In this section, we take inspiration from
\cite{allaisGenericLevelPolymorphic2019} to develop a small interface to generic
\(n\)-ary functions and properties.
What we provide here differs from that work in the following ways:
\begin{itemize}
  \item Our generic representation can handle dependent \(\sum\) and \(\prod\)
    types (rather than their non-dependent counterparts, \(\times\) and
    \(\rightarrow\)).
    This extension was necessary for our use case: it is mentioned in the paper
    as the obvious next step. 
  \item We implement the curry-uncurry combinators as (verified) isomorphisms.
    Since we are in a cubical setting, this gives us equivalences between the
    types, a feature not available in standard Agda.
  \item We deal with implicit and instance arguments generically.
\end{itemize}
A full explanation of our implementation is beyond the scope of this work, so we
only present the finished interface.
\ExecuteMetaData[agda/Cardinality/Finite/Search.tex]{all-nary}
Which is used like so:
\ExecuteMetaData[agda/Data/Pauli.tex]{prf-curried}
\bibliographystyle{splncs04}
\bibliography{bibliography.bib}
\end{document}